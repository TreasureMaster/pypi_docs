# Документация по конструктору шаблонов

Этот документ описывает синтаксис и семантику механизма шаблонов и будет наиболее полезен в качестве справки для тех, кто создает шаблоны **Jinja**. Поскольку механизм шаблонов очень гибкий, конфигурация из приложения может немного отличаться от кода, представленного здесь, с точки зрения разделителей и поведения неопределенных значений.

## Краткий обзор

Шаблон **Jinja** - это просто текстовый файл. **Jinja** может генерировать любой текстовый формат (HTML, XML, CSV, LaTeX и т. д.). Шаблон **Jinja** не обязательно должен иметь конкретное расширение: вполне подойдет `.html`, `.xml` или любое другое расширение.

Шаблон содержит переменные _**variables**_ и/или выражения _**expressions**_, которые заменяются значениями при визуализации шаблона; и теги, которые управляют логикой шаблона. Синтаксис шаблона во многом вдохновлен **Django** и Python.

Ниже приведен минимальный шаблон, который иллюстрирует некоторые основы использования конфигурации **Jinja** по умолчанию. Мы рассмотрим детали позже в этом документе:

```markup
<!DOCTYPE html>
<html lang="en">
<head>
    <title>My Webpage</title>
</head>
<body>
    <ul id="navigation">
    {% raw %}
{% for item in navigation %}
        <li><a href="{{ item.href }}">{{ item.caption }}</a></li>
    {% endfor %}
{% endraw %}
    </ul>

    <h1>My Webpage</h1>
    {{ a_variable }}

    {# a comment #}
</body>
</html>
```

В следующем примере показаны параметры конфигурации по умолчанию. Разработчик приложения может изменить конфигурацию синтаксиса с `{% foo %}` на `<% foo %>` или что-то подобное.

Есть несколько видов разделителей. Разделители **Jinja** по умолчанию настроены следующим образом:

* `{% ... %}` - для операторов (**Statements**)
* `{{ ... }}` - для выражений (**Expressions**) для печати в выводе шаблона
* `{# ... #}` - для комментариев (**Comments**), не включенных в вывод шаблона
* `# ... ##` - для строковых операторов (**Line Statements**)

## Расширения файлов шаблона

Как указано выше, в качестве шаблона можно загрузить любой файл, независимо от расширения файла. Добавление расширения `.jinja`, например `user.html.jinja`, может упростить работу некоторых IDE или плагинов редактора, но это не обязательно. Автоматическое экранирование, представленное позже, может применяться в зависимости от расширения файла, поэтому в этом случае вам нужно будет учитывать дополнительный суффикс.

Еще одна хорошая эвристика для определения шаблонов заключается в том, что они находятся в папке шаблонов `templates` независимо от расширения. Это обычный макет для проектов.

## Переменные (Variables)

Переменные шаблона определяются контекстным словарем, переданным в шаблон.

Вы можете возиться с переменными в шаблонах, если они передаются приложением. Переменные могут иметь атрибуты или элементы, к которым вы также можете получить доступ. Какие атрибуты имеют переменные, сильно зависит от приложения, предоставляющего эту переменную.

Вы можете использовать точку (`.`) для доступа к атрибутам переменной в дополнение к стандартному синтаксису «нижнего индекса» Python `__getitem__` (`[]`).

Следующие строки делают то же самое:

```python
{{ foo.bar }}
{{ foo['bar'] }}
```

Важно знать, что внешние двойные фигурные скобки не являются частью переменной, а являются частью оператора печати. Если вы обращаетесь к переменным внутри тегов, не заключайте их в фигурные скобки.

Если переменная или атрибут не существует, вы получите неопределенное (_**undefined**_) значение. То, что вы можете сделать с таким значением, зависит от конфигурации приложения: поведение по умолчанию - вычислить пустую строку при печати или повторении и не выполнить все остальные операции.

{% hint style="info" %}
**Реализация:**

Для удобства _**foo.bar**_ в **Jinja** выполняет следующие действия на уровне Python:

* проверяет атрибут с именем _**bar**_ в _**foo**_ (`getattr (foo, 'bar')`)
* если нет, проверяет элемент `'bar'` в _**foo**_ (`foo.__getitem__('bar')`)
* если нет, возвращает неопределенный объект.

**foo \['bar']** работает в основном так же, с небольшой разницей в последовательности:

* проверяет элемент `'bar'` в _**foo**_ (`foo.__getitem__('bar')`)
* если нет, проверяет атрибут с именем _**bar**_ в _**foo**_ (`getattr (foo, 'bar')`)
* если нет, возвращает неопределенный объект.

Это важно, если у объекта есть элемент и атрибут с тем же именем. Кроме того, фильтр **attr ()** ищет только атрибуты.
{% endhint %}

## Фильтры (Filters)

Переменные можно изменять с помощью фильтров _**filters**_. Фильтры отделяются от переменной вертикальной чертой (`|`) и могут иметь необязательные аргументы в круглых скобках. Можно объединить несколько фильтров. Выходные данные одного фильтра применяются к следующему.

Например,  `{{ name|striptags|title }}` удалит все HTML-теги из переменной _**name**_ и создаст вывод заглавного регистра (`title (striptags (name))`).

Фильтры, которые принимают аргументы, заключают аргументы в круглые скобки, как и при вызове функции. Например:  `{{ listx|join(', ') }}` присоединит список с запятыми (`str.join (', ', listx)`).

В списке встроенных фильтров ниже описаны все встроенные фильтры (**List of Builtins Filters**).

## Тесты (Tests)

Помимо фильтров, доступны так называемые «тесты». Тесты могут использоваться для проверки переменной на соответствие общему выражению. Чтобы проверить переменную или выражение, вы добавляете _**is**_ плюс имя теста после переменной. Например, чтобы узнать, определена ли переменная, вы можете сделать `name is defined`, которое затем вернет `True` или `False` в зависимости от того, определено ли имя в текущем контексте шаблона.

Тесты тоже могут принимать аргументы. Если тест принимает только один аргумент, скобки можно опустить. Например, следующие два выражения делают то же самое:

```python
{% raw %}
{% if loop.index is divisibleby 3 %}
{% if loop.index is divisibleby(3) %}
{% endraw %}
```

В приведенном ниже списке встроенных тестов описаны все встроенные тесты (**List of Builtins Tests**).

## Комментарии (Comments)

Чтобы закомментировать часть строки в шаблоне, используйте синтаксис комментария, который по умолчанию установлен на `{# ... #}`. Это полезно, чтобы закомментировать части шаблона для отладки или добавить информацию для других разработчиков шаблона или для себя:

```python
{# примечание: шаблон закомментирован, потому что мы больше не используем его
    {% raw %}
{% for user in users %}
        ...
    {% endfor %}
{% endraw %}
#}
```

## Контроль пробелов

В конфигурации по умолчанию:

* один завершающий символ новой строки удаляется, если он присутствует
* остальные пробелы (пробелы, табуляции, новые строки и т. д.) возвращаются без изменений

Если приложение настраивает **Jinja** на _**trim\_blocks**_, первая новая строка после тега шаблона удаляется автоматически (как в PHP). Параметр _**lstrip\_blocks**_ также может быть установлен для удаления табуляции и пробелов от начала строки до начала блока. (Ничего не будет удалено, если перед началом блока есть другие символы.)

Если включены как _**trim\_blocks**_, так и _**lstrip\_blocks**_, вы можете помещать теги блоков в их собственные строки, и вся строка блока будет удалена при визуализации, сохраняя пробелы в содержимом. Например, без параметров _**trim\_blocks**_ и _**lstrip\_blocks**_ этот шаблон:

```python
<div>
    {% raw %}
{% if True %}
        yay
    {% endif %}
{% endraw %}
</div>
```

отображается с пустыми строками внутри _**div**_:

```markup
<div>

        yay

</div>
```

Но при включении как _**trim\_blocks**_, так и _**lstrip\_blocks**_ строки блока шаблона удаляются, а остальные пробелы сохраняются:

```markup
<div>
        yay
</div>
```

Вы можете вручную отключить поведение _**lstrip\_blocks**_, поставив знак плюса (`+`) в начале блока:

```python
<div>
        {% raw %}
{%+ if something %}yay{% endif %}
{% endraw %}
</div>
```

Вы также можете удалить пробелы в шаблонах вручную. Если вы добавите знак минус (`-`) в начало или конец блока (например, тега **For**), комментария или выражения переменной, пробелы до или после этого блока будут удалены:

```python
{% raw %}
{% for item in seq -%}
    {{ item }}
{%- endfor %}
{% endraw %}
```

Это даст все элементы без пробелов между ними. Если бы _**seq**_ был списком чисел от `1` до `9`, на выходе было бы `123456789`.

Если операторы строки (**Line Statements**) включены, они автоматически удаляют начальные пробелы до начала строки.

По умолчанию **Jinja** также удаляет завершающие символы новой строки. Чтобы сохранить одиночные завершающие символы новой строки, настройте **Jinja** на _**keep\_trailing\_newline**_.

{% hint style="info" %}
**Примечание:**

Вы не должны добавлять пробелы между тегом и знаком минус.

**действительный:**

```python
{% raw %}
{%- if foo -%}...{% endif %}
{% endraw %}
```

**недействительный:**

```python
{% raw %}
{% - if foo - %}...{% endif %}
{% endraw %}
```
{% endhint %}

## Экранирование (Escaping)

Иногда желательно - даже необходимо - чтобы **Jinja** игнорировал части, которые в противном случае он обрабатывал бы как переменные или блоки. Например, если с синтаксисом по умолчанию вы хотите использовать `{{` как необработанную строку в шаблоне, а не запускать переменную, вы должны использовать уловку.

```python
{{ '{{' }}
```

Для больших разделов имеет смысл пометить блок как необработанный. Например, чтобы включить пример синтаксиса **Jinja** в шаблон, вы можете использовать этот фрагмент:

```python
{% raw %}
    <ul>
    {% for item in seq %}
        <li>{{ item }}</li>
    {% endfor %}
    </ul>
{% endraw %}
```

{% hint style="info" %}
**Примечание:**

Знак минус в конце тега `{% raw -%}` очищает все пробелы и символы новой строки, предшествующие первому символу ваших исходных данных.
{% endhint %}

## Операторы строки (Line Statements)

Если в приложении разрешены строковые операторы, можно отметить строку как инструкцию. Например, если для префикса оператора строки задано значение `#`, следующие два примера эквивалентны:

```python
<ul>
# for item in seq
    <li>{{ item }}</li>
# endfor
</ul>

<ul>
{% raw %}
{% for item in seq %}
    <li>{{ item }}</li>
{% endfor %}
{% endraw %}
</ul>
```

Префикс оператора строки может появляться в любом месте строки, если ему не предшествует текст. Для удобства чтения операторы, которые начинают блок (например, _**for**_, _**if**_, _**elif**_ и т. д.), могут заканчиваться двоеточием:

```python
# for item in seq:
    ...
# endfor
```

{% hint style="info" %}
**Примечание:**

Операторы строки могут охватывать несколько строк, если есть открытые круглые скобки, фигурные скобки или квадратные скобки:

```python
<ul>
# for href, caption in [('index.html', 'Index'), ('about.html', 'About')]:
    <li><a href="{{ href }}">{{ caption }}</a></li>
# endfor
</ul>
```
{% endhint %}

Начиная с **Jinja** 2.2, также доступны построчные комментарии. Например, если для префикса комментария к строке задано значение `##`, все от `##` до конца строки игнорируется (за исключением знака новой строки):

```python
# for item in seq:
    <li>{{ item }}</li>     ## this comment is ignored
# endfor
```

## Наследование шаблона

Самая мощная часть **Jinja** - это наследование шаблонов. Наследование шаблонов позволяет вам создать базовый «скелетный» шаблон, который содержит все общие элементы вашего сайта и определяет блоки _**blocks**_, которые дочерние шаблоны могут переопределить.

Звучит сложно, но очень просто. Проще всего это понять, начав с примера.

### Базовый шаблон

Этот шаблон, который мы назовем `base.html`, определяет простой скелет HTML-документа, который вы можете использовать для простой страницы с двумя столбцами. Задача «дочерних» шаблонов - заполнить пустые блоки контентом:

```python
<!DOCTYPE html>
<html lang="en">
<head>
    {% raw %}
{% block head %}
    <link rel="stylesheet" href="style.css" />
    <title>{% block title %}{% endblock %} - My Webpage</title>
    {% endblock %}
</head>
<body>
    <div id="content">{% block content %}{% endblock %}</div>
    <div id="footer">
        {% block footer %}
        &copy; Copyright 2008 by <a href="http://domain.invalid/">you</a>.
        {% endblock %}
{% endraw %}
    </div>
</body>
</html>
```

В этом примере теги `{% block %}` определяют четыре блока, которые могут быть заполнены дочерними шаблонами. Все, что делает тег блока, это сообщает механизму шаблонов, что дочерний шаблон может переопределить эти заполнители в шаблоне.

Теги блока `block` могут находиться внутри других блоков, таких как `if`, но они всегда будут выполняться независимо от того, действительно ли отображается блок `if`.

### Дочерний шаблон

Дочерний шаблон может выглядеть так:

```python
{% raw %}
{% extends "base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    <style type="text/css">
        .important { color: #336699; }
    </style>
{% endblock %}
{% block content %}
    <h1>Index</h1>
    <p class="important">
      Welcome to my awesome homepage.
    </p>
{% endblock %}
{% endraw %}
```

Тег `{% extends %}` является здесь ключевым. Он сообщает механизму шаблонов, что этот шаблон «расширяет» другой шаблон. Когда система шаблонов оценивает этот шаблон, она сначала находит родителя. Тег _**extends**_ должен быть первым тегом в шаблоне. Все, что до этого, распечатывается нормально и может вызвать путаницу. Подробные сведения об этом поведении и о том, как им воспользоваться, см. в разделе [резервное копирование с нулевым мастером](sovety-i-priemy.md) (**Null-Master Fallback**). Также блок всегда будет заполнен, независимо от того, оценивается ли окружающее условие как истинное или ложное.

Имя файла шаблона зависит от загрузчика шаблона. Например, **FileSystemLoader** позволяет вам получить доступ к другим шаблонам, указав имя файла. Вы можете получить доступ к шаблонам в подкаталогах с помощью косой черты:

```python
{% raw %}
{% extends "layout/default.html" %}
{% endraw %}
```

Но это поведение может зависеть от приложения, встраивающего **Jinja**. Обратите внимание: поскольку дочерний шаблон не определяет блок нижнего колонтитула `footer`, вместо него используется значение из родительского шаблона.

Вы не можете определить несколько тегов `{% block %}` с одним и тем же именем в одном шаблоне. Это ограничение существует, потому что тег блока работает «в обоих» направлениях. То есть тег блока не просто предоставляет заполнитель для заполнения - он также определяет содержимое, которое заполняет заполнитель в родительском элементе _**parent**_. Если бы в шаблоне было два тега с одинаковыми именами `{% block %}` , родительский элемент этого шаблона не знал бы, какой из содержимого блока использовать.

Однако если вы хотите напечатать блок несколько раз, вы можете использовать специальную переменную _**self**_ и вызвать блок с этим именем:

```python
<title>{% raw %}
{% block title %}{% endblock %}</title>
<h1>{{ self.title() }}</h1>
{% block body %}{% endblock %}
{% endraw %}
```

### Супер блоки ( super() )

Можно отобразить содержимое родительского блока, вызвав `super ()`. Это возвращает результаты родительского блока:

```python
{% raw %}
{% block sidebar %}
    <h3>Table Of Contents</h3>
    ...
    {{ super() }}
{% endblock %}
{% endraw %}
```

### Вложенные расширения

В случае нескольких уровней `{% extends %}` _**super**_ ссылки могут быть связаны (как в `super.super ()`), чтобы пропустить уровни в дереве наследования.

Например:

```python
# parent.tmpl
body: {% raw %}
{% block body %}Hi from parent.{% endblock %}

# child.tmpl
{% extends "parent.tmpl" %}
{% block body %}Hi from child. {{ super() }}{% endblock %}

# grandchild1.tmpl
{% extends "child.tmpl" %}
{% block body %}Hi from grandchild1.{% endblock %}

# grandchild2.tmpl
{% extends "child.tmpl" %}
{% block body %}Hi from grandchild2. {{ super.super() }} {% endblock %}
{% endraw %}
```

Визуализация `child.tmpl` даст `body: High from child. High from parent.`

Визуализация `grandchild1.tmpl` даст `body: High from grandchild1.`

Визуализация `grandchild2.tmpl` даст `body: High from grandchild2. High from parent.`

### Конечные теги именованных блоков

**Jinja** позволяет помещать название блока после закрывающего тега для лучшей читаемости:

```python
{% raw %}
{% block sidebar %}
    {% block inner_sidebar %}
        ...
    {% endblock inner_sidebar %}
{% endblock sidebar %}
{% endraw %}
```

Однако имя после слова конечного блока должно совпадать с именем блока.

### Вложенность блоков и область действия

Блоки можно вкладывать в более сложные схемы. Однако блоки по умолчанию не могут обращаться к переменным из внешних областей:

```python
{% raw %}
{% for item in seq %}
    <li>{% block loop_item %}{{ item }}{% endblock %}</li>
{% endfor %}
{% endraw %}
```

В этом примере будут выведены пустые элементы `<li>`, поскольку элемент _**item**_ недоступен внутри блока. Причина в том, что если блок заменен дочерним шаблоном, появится переменная, которая не была определена в блоке или передана в контекст.

Начиная с **Jinja** 2.2, вы можете явно указать, что переменные доступны в блоке, установив для блока значение «scoped», добавив модификатор _**scoped**_ к объявлению блока:

```python
{% raw %}
{% for item in seq %}
    <li>{% block loop_item scoped %}{{ item }}{% endblock %}</li>
{% endfor %}
{% endraw %}
```

При переопределении блока модификатор _**scoped**_ указывать не обязательно.

### Объекты шаблона

_Изменено в версии 2.4_.

Если объект шаблона был передан в контексте шаблона, вы также можете расширить его. Предполагая, что вызывающий код передает шаблон макета как _**layout\_template**_ в среду, этот код работает:

```python
{% raw %}
{% extends layout_template %}
{% endraw %}
```

Раньше переменная _**layout\_template**_ должна была быть строкой с именем файла шаблона макета, чтобы это работало.

## HTML экранирование (HTML escaping)

При создании HTML из шаблонов всегда существует риск того, что переменная будет включать символы, влияющие на результирующий HTML. Есть два подхода:

1. экранирование каждой переменной вручную; или же
2. автоматически экранировать все по умолчанию.

**Jinja** поддерживает и то, и другое. Что используется, зависит от конфигурации приложения. По умолчанию автоматическое экранирование отсутствует; по разным причинам:

* Экранирование всего, кроме безопасных значений, также будет означать, что **Jinja** экранирует переменные, которые, как известно, не включают HTML (например, числа, логические значения), что может сильно снизить производительность.
* Информация о безопасности переменной очень хрупкая. Может случиться так, что в результате принуждения безопасных и небезопасных значений возвращаемое значение будет HTML с двойным экранированием.

### Работа с ручным экранированием

Если включено экранирование вручную, вы несете ответственность за экранирование переменных, если это необходимо. Что экранировать? Если у вас есть переменная, которая может включать любой из следующих символов (`>`, `<`, `&` или `"`), вам **СЛЕДУЕТ** экранировать ее, если переменная не содержит правильно сформированный и надежный HTML. Экранирование работает путем передачи переменной по конвейеру через фильтр `|e`:

```python
{{ user.username|e }}
```

### Работа с автоматическим экранированием

Когда автоматическое экранирование включено, по умолчанию экранируется все, кроме значений, явно отмеченных как безопасные. Переменные и выражения можно пометить как безопасные в:

1. Словарь контекста приложения с **markupsafe.Markup**
2. Шаблон с безопасным фильтром `|safe`.

Если строка, помеченная вами как безопасная, передается через другой код Python, который не понимает эту метку, она может быть потеряна. Прежде чем перейти к шаблону, узнайте, когда ваши данные помечены как безопасные и как они обрабатываются.

Если значение было экранировано, но не помечено как безопасное, автоматическое экранирование все равно будет иметь место и приведет к появлению двойных экранированных символов. Если вы знаете, что у вас есть данные, которые уже являются безопасными, но не отмечены, обязательно поместите их в разметку **Markup** или используйте безопасный фильтр `|safe`.

Функции **Jinja** (макросы, _**super**_, **self.BLOCKNAME**) всегда возвращают данные шаблона, отмеченные как безопасные.

Строковые литералы в шаблонах с автоматическим экранированием считаются небезопасными, поскольку встроенные строки Python (_**str**_, _**unicode**_, _**basestring**_) не являются строками **MarkupSafe.Markup** с атрибутом `__html__`.

## Список структур управления

Управляющая структура относится ко всем тем вещам, которые управляют ходом программы - условным операторам (например, _**if**_ / _**elif**_ / _**else**_), циклам _**for**_, а также таким вещам, как макросы и блоки. При синтаксисе по умолчанию управляющие структуры появляются внутри блоков `{% ... %}`.

### For

Перебирает каждый элемент в последовательности. Например, чтобы отобразить список пользователей, указанный в переменной с именем _**users**_:

```python
<h1>Members</h1>
<ul>
{% raw %}
{% for user in users %}
  <li>{{ user.username|e }}</li>
{% endfor %}
{% endraw %}
</ul>
```

Поскольку переменные в шаблонах сохраняют свои свойства объекта, можно перебирать контейнеры, такие как _**dict**_:

```python
<dl>
{% raw %}
{% for key, value in my_dict.items() %}
    <dt>{{ key|e }}</dt>
    <dd>{{ value|e }}</dd>
{% endfor %}
{% endraw %}
</dl>
```

Обратите внимание, однако, что словари Python **не упорядочены**; поэтому вы можете либо передать отсортированный список _**list**_ кортежей _**tuples**_, либо **collections.OrderedDict** - в шаблон, либо использовать фильтр _**dictsort**_.

Внутри блока цикла _**for**_ вы можете получить доступ к некоторым специальным переменным:

| Переменная                | Описание                                                                                            |
| ------------------------- | --------------------------------------------------------------------------------------------------- |
| _**loop.index**_          | Текущая итерация цикла. (1 проиндексировано)                                                        |
| _**loop.index0**_         | Текущая итерация цикла. (0 проиндексировано)                                                        |
| _**loop.revindex**_       | Количество итераций от конца цикла (1 индексируется)                                                |
| _**loop.revindex0**_      | Количество итераций от конца цикла (0 индексируется)                                                |
| _**loop.first**_          | True, если первая итерация.                                                                         |
| _**loop.last**_           | True, если последняя итерация.                                                                      |
| _**loop.length**_         | Количество элементов в последовательности.                                                          |
| _**loop.cycle**_          | Вспомогательная функция для переключения между списком последовательностей. См. объяснение ниже.    |
| _**loop.depth**_          | Указывает, насколько глубоко в рекурсивном цикле находится текущий рендеринг. Начинается с уровня 1 |
| _**loop.depth0**_         | Указывает, насколько глубоко в рекурсивном цикле находится текущий рендеринг. Начинается с уровня 0 |
| _**loop.previtem**_       | Элемент из предыдущей итерации цикла. Не определено во время первой итерации.                       |
| _**loop.nextitem**_       | Элемент из следующей итерации цикла. Не определено на последней итерации.                           |
| _**loop.changed(\*val)**_ | True, если ранее вызывалась с другим значением (или не вызывалась вообще).                          |

Внутри цикла **for** можно каждый раз переключаться между списком строк/переменных, используя специальный помощник _**loop.cycle**_:

```python
{% raw %}
{% for row in rows %}
    <li class="{{ loop.cycle('odd', 'even') }}">{{ row }}</li>
{% endfor %}
{% endraw %}
```

Начиная с **Jinja** 2.1, существует дополнительный помощник по циклу _**cycle**_, который позволяет циклический цикл без привязки к циклу. Для получения дополнительной информации ознакомьтесь со списком глобальных функций (**List of Global Function**).

В отличие от Python, невозможно прервать или продолжить цикл. Однако вы можете фильтровать последовательность во время итерации, что позволяет пропускать элементы. В следующем примере пропускаются все скрытые пользователи:

```python
{% raw %}
{% for user in users if not user.hidden %}
    <li>{{ user.username|e }}</li>
{% endfor %}
{% endraw %}
```

Преимущество в том, что специальная переменная цикла будет подсчитывать правильно; таким образом, не считая пользователей, которые не прошли итерацию.

Если итерации не было, потому что последовательность была пустой или фильтрация удалила все элементы из последовательности, вы можете визуализировать блок по умолчанию, используя _**else**_:

```python
<ul>
{% raw %}
{% for user in users %}
    <li>{{ user.username|e }}</li>
{% else %}
    <li><em>no users found</em></li>
{% endfor %}
{% endraw %}
</ul>
```

Обратите внимание, что в Python блоки _**else**_ выполняются всякий раз, когда соответствующий цикл **не прерывается** _**break**_. Поскольку циклы **Jinja** в любом случае не могут прерваться _**break**_, было выбрано несколько иное поведение ключевого слова _**else**_.

Также возможно использовать циклы рекурсивно. Это полезно, если вы имеете дело с рекурсивными данными, такими как карты сайта или RDFa. Чтобы использовать циклы рекурсивно, вам в основном нужно добавить модификатор _**recursive**_ к определению цикла и вызвать переменную цикла _**loop**_ с новой итерацией, где вы хотите выполнить рекурсию.

В следующем примере карта сайта реализуется с рекурсивными циклами:

```python
<ul class="sitemap">
{% raw %}
{%- for item in sitemap recursive %}
    <li><a href="{{ item.href|e }}">{{ item.title }}</a>
    {%- if item.children -%}
        <ul class="submenu">{{ loop(item.children) }}</ul>
    {%- endif %}</li>
{%- endfor %}
{% endraw %}
</ul>
```

Переменная цикла _**loop**_ всегда относится к ближайшему (самому внутреннему) циклу. Если у нас более одного уровня циклов, мы можем повторно связать цикл _**loop**_ переменных, написав после цикла `{% set outer_loop = loop %}` , который мы хотим использовать рекурсивно. Затем мы можем вызвать его с помощью `{{ outer_loop(...) }}` .

Обратите внимание, что назначения в циклах будут очищены в конце итерации и не могут пережить область действия цикла. В более старых версиях **Jinja** была ошибка, из-за которой при некоторых обстоятельствах казалось, что задания будут работать. Это не поддерживается. См. задания для получения дополнительной информации о том, как с этим справиться (**Assignments**).

Если все, что вам нужно сделать, это проверить, изменилось ли какое-либо значение с момента последней итерации или изменится ли оно на следующей итерации, вы можете использовать _**previtem**_ и _**nextitem**_:

```python
{% raw %}
{% for value in values %}
    {% if loop.previtem is defined and value > loop.previtem %}
        The value just increased!
    {% endif %}
    {{ value }}
    {% if loop.nextitem is defined and loop.nextitem > value %}
        The value will increase even more!
    {% endif %}
{% endfor %}
{% endraw %}
```

Если вас заботит только, изменилось ли значение вообще, использовать _**changed**_ еще проще:

```python
{% raw %}
{% for entry in entries %}
    {% if loop.changed(entry.category) %}
        <h2>{{ entry.category }}</h2>
    {% endif %}
    <p>{{ entry.message }}</p>
{% endfor %}
{% endraw %}
```

### If

Оператор _**if**_ в **Jinja** сравним с оператором _**if**_ Python. В простейшей форме вы можете использовать его, чтобы проверить, определена ли переменная, не пуста и не ложна:

```python
{% raw %}
{% if users %}
<ul>
{% for user in users %}
    <li>{{ user.username|e }}</li>
{% endfor %}
</ul>
{% endif %}
{% endraw %}
```

Для нескольких веток можно использовать _**elif**_ и _**else**_, как в Python. Вы также можете использовать более сложные выражения (**Expressions**):

```python
{% raw %}
{% if kenny.sick %}
    Kenny is sick.
{% elif kenny.dead %}
    You killed Kenny!  You bastard!!!
{% else %}
    Kenny looks okay --- so far
{% endif %}
{% endraw %}
```

**If** также можно использовать как встроенное выражение (**inline expression**) и для фильтрации цикла (**loop filtering**).

### Макрос (Macros)

Макросы можно сравнить с функциями обычных языков программирования. Они полезны для помещения часто используемых идиом в функции многократного использования, чтобы не повторяться («DRY»).

Вот небольшой пример макроса, который отображает элемент формы:

```python
{% raw %}
{% macro input(name, value='', type='text', size=20) -%}
    <input type="{{ type }}" name="{{ name }}" value="{{
        value|e }}" size="{{ size }}">
{%- endmacro %}
{% endraw %}
```

Затем макрос можно вызывать как функцию в пространстве имен:

```python
<p>{{ input('username') }}</p>
<p>{{ input('password', type='password') }}</p>
```

Если макрос был определен в другом шаблоне, вы должны сначала импортировать его (**import**).

Внутри макросов у вас есть доступ к трем специальным переменным:

* _**varargs**_ - Если в макрос передается больше позиционных аргументов, чем принято макросом, они попадают в специальную переменную _**varargs**_ в виде списка значений.
* _**kwargs**_ - Как _**varargs**_, но для аргументов ключевого слова. Все неиспользованные аргументы ключевых слов хранятся в этой специальной переменной.
* _**caller**_ - Если макрос был вызван из тега вызова _**call**_, вызывающий сохраняется в этой переменной как вызываемый макрос.

Макросы также раскрывают некоторые из своих внутренних деталей. Для объекта макроса доступны следующие атрибуты:

* _**name**_ - Имя макроса `{{ input.name }}` напечатает ввод `input`.
* _**arguments**_ - Кортеж имен аргументов, которые принимает макрос.
* _**defaults**_ - Кортеж значений по умолчанию.
* _**catch\_kwargs**_ - Имеет значение `True`, если макрос принимает дополнительные ключевые аргументы (то есть: обращается к специальной переменной _**kwargs**_).
* _**catch\_varargs**_ - Имеет значение `True`, если макрос принимает дополнительные позиционные аргументы (то есть: обращается к специальной переменной _**varargs**_).
* _**caller**_ - Имеет значение `True`, если макрос обращается к специальной переменной _**caller**_ вызывающего объекта и может быть вызван из тега вызова.

Если имя макроса начинается с подчеркивания, он не экспортируется и не может быть импортирован.

### Вызов (Call)

В некоторых случаях может быть полезно передать макрос другому макросу. Для этого можно использовать специальный блок вызова. В следующем примере показан макрос, который использует преимущества функции вызова и как его можно использовать:

```python
{% raw %}
{% macro render_dialog(title, class='dialog') -%}
    <div class="{{ class }}">
        <h2>{{ title }}</h2>
        <div class="contents">
            {{ caller() }}
        </div>
    </div>
{%- endmacro %}

{% call render_dialog('Hello World') %}
    This is a simple dialog rendered by using a macro and
    a call block.
{% endcall %}
{% endraw %}
```

Также можно передавать аргументы обратно в блок вызова. Это делает его полезным в качестве замены циклов. Вообще говоря, блок вызова работает точно так же, как макрос без имени.

Вот пример того, как блок вызова может использоваться с аргументами:

```python
{% raw %}
{% macro dump_users(users) -%}
    <ul>
    {%- for user in users %}
        <li><p>{{ user.username|e }}</p>{{ caller(user) }}</li>
    {%- endfor %}
    </ul>
{%- endmacro %}

{% call(user) dump_users(list_of_user) %}
    <dl>
        <dl>Realname</dl>
        <dd>{{ user.realname|e }}</dd>
        <dl>Description</dl>
        <dd>{{ user.description }}</dd>
    </dl>
{% endcall %}
{% endraw %}
```

### Фильтры (Filters)

Разделы фильтров позволяют применять обычные фильтры **Jinja** к блоку данных шаблона. Просто оберните код в специальный раздел _**filter**_:

```python
{% raw %}
{% filter upper %}
    This text becomes uppercase
{% endfilter %}
{% endraw %}
```

### Присваивания (Assignments)

Внутри блоков кода вы также можете присваивать значения переменным. Назначения на верхнем уровне (вне блоков, макросов или циклов) экспортируются из шаблона, как макросы верхнего уровня, и могут быть импортированы другими шаблонами.

Присваивания используют тег _**set**_ и могут иметь несколько целей:

```python
{% raw %}
{% set navigation = [('index.html', 'Index'), ('about.html', 'About')] %}
{% set key, value = call_something() %}
{% endraw %}
```

#### Режим определения:

Имейте в виду, что невозможно установить переменные внутри блока и сделать так, чтобы они отображались за его пределами. Это касается и циклов. Единственным исключением из этого правила являются операторы **if**, которые не вводят область видимости. В результате следующий шаблон не будет делать то, что вы ожидаете:

```python
{% raw %}
{% set iterated = false %}
{% for item in seq %}
    {{ item }}
    {% set iterated = true %}
{% endfor %}
{% if not iterated %} did not iterate {% endif %}
{% endraw %}
```

Это невозможно сделать с помощью синтаксиса **Jinja**. Вместо этого используйте альтернативные конструкции, такие как блок цикла _**else**_ или специальная переменная цикла _**loop**_:

```python
{% raw %}
{% for item in seq %}
    {{ item }}
{% else %}
    did not iterate
{% endfor %}
{% endraw %}
```

Начиная с версии 2.10, более сложные варианты использования можно обрабатывать с помощью объектов пространства имен, которые позволяют распространять изменения по областям:

```python
{% raw %}
{% set ns = namespace(found=false) %}
{% for item in items %}
    {% if item.check_something() %}
        {% set ns.found = true %}
    {% endif %}
    * {{ item.title }}
{% endfor %}
{% endraw %}
Found item having something: {{ ns.found }}
```

Обратите внимание, что запись `obj.attr` в теге _**set**_ разрешена только для объектов пространства имен; попытка присвоить атрибут любому другому объекту вызовет исключение.

_Новое в версии 2.10:_ добавлена поддержка объектов пространства имен.

### Присоединение блоков (Block Assignments)

_Новое в версии 2.8_.

Начиная с **Jinja** 2.8, можно также использовать назначения блоков для захвата содержимого блока в имя переменной. Это может быть полезно в некоторых ситуациях в качестве альтернативы макросам. В этом случае вместо того, чтобы использовать знак равенства и значение, вы просто пишете имя переменной, а затем все, пока `{% endset %}` не будет захвачен.

Пример:

```python
{% raw %}
{% set navigation %}
    <li><a href="/">Index</a>
    <li><a href="/downloads">Downloads</a>
{% endset %}
{% endraw %}
```

Переменная _**navigation**_ содержит теперь исходный HTML-код для навигации.

_Изменено в версии 2.10_.

Начиная с **Jinja** 2.10, присоединение блоков поддерживает фильтры.

Пример:

```python
{% raw %}
{% set reply | wordwrap %}
    You wrote:
    {{ message }}
{% endset %}
{% endraw %}
```

### Расширения (Extends)

Тег _**extends**_ можно использовать для расширения одного шаблона из другого. В файле может быть несколько тегов _**extends**_, но одновременно может выполняться только один из них.

См. раздел о наследовании шаблонов выше (**Template Inheritance**).

### Блоки (Blocks)

Блоки используются для наследования и одновременно действуют как заполнители и замены. Они подробно описаны в разделе "Наследование шаблонов" (**Template Inheritance**).

### Включения (Includs)

Тег _**include**_ полезен для включения шаблона и возврата визуализированного содержимого этого файла в текущее пространство имен:

```python
{% raw %}
{% include 'header.html' %}
    Body
{% include 'footer.html' %}
{% endraw %}
```

Включенные шаблоны по умолчанию имеют доступ к переменным активного контекста. Дополнительные сведения о поведении контекста при импорте и включении см. в разделе Поведение контекста импорта (**Import Context Behavior**).

Начиная с **Jinja** 2.2 и далее, вы можете пометить включение как `ignore missing`; в этом случае **Jinja** проигнорирует инструкцию, если включаемый шаблон не существует. В сочетании с `with` или `without context` он должен быть помещен перед _**befor**_ оператором видимости контекста. Вот несколько действенных примеров:

```python
{% raw %}
{% include "sidebar.html" ignore missing %}
{% include "sidebar.html" ignore missing with context %}
{% include "sidebar.html" ignore missing without context %}
{% endraw %}
```

_Новое в версии 2.2_.

Вы также можете предоставить список шаблонов, существование которых проверяется перед включением. Будет включен первый существующий шаблон. Если задано значение _**ignore missing**_, он вернется к отсутствию рендеринга, если ни один из шаблонов не существует, в противном случае возникнет исключение.

Пример:

```python
{% raw %}
{% include ['page_detailed.html', 'page.html'] %}
{% include ['special_sidebar.html', 'sidebar.html'] ignore missing %}
{% endraw %}
```

_Изменено в версии 2.4:_ если объект шаблона был передан в контекст шаблона, вы можете включить этот объект с помощью _**include**_.

### Импорт (Import)

**Jinja** поддерживает включение часто используемого кода в макросы. Эти макросы могут входить в разные шаблоны и импортироваться оттуда. Это работает аналогично операторам импорта в Python. Важно знать, что импорт кэшируется, а импортированные шаблоны не имеют доступа к текущим переменным шаблона, а только к глобальным переменным по умолчанию. Дополнительные сведения о поведении контекста при импорте и включении см. В разделе Поведение контекста импорта (**Import Context Behavior**).

Есть два способа импортировать шаблоны. Вы можете импортировать полный шаблон в переменную или запросить из него определенные макросы/экспортируемые переменные.

Представьте, что у нас есть вспомогательный модуль, который отображает формы (называемый `forms.html`):

```python
{% raw %}
{% macro input(name, value='', type='text') -%}
    <input type="{{ type }}" value="{{ value|e }}" name="{{ name }}">
{%- endmacro %}

{%- macro textarea(name, value='', rows=10, cols=40) -%}
    <textarea name="{{ name }}" rows="{{ rows }}" cols="{{ cols
        }}">{{ value|e }}</textarea>
{%- endmacro %}
{% endraw %}
```

Самый простой и гибкий способ получить доступ к шаблонным переменным и макросам - это импортировать весь модуль шаблона в переменную. Таким образом, вы можете получить доступ к атрибутам:

```python
{% raw %}
{% import 'forms.html' as forms %}
{% endraw %}
<dl>
    <dt>Username</dt>
    <dd>{{ forms.input('username') }}</dd>
    <dt>Password</dt>
    <dd>{{ forms.input('password', type='password') }}</dd>
</dl>
<p>{{ forms.textarea('comment') }}</p>
```

Как вариант, вы можете импортировать определенные имена из шаблона в текущее пространство имен:

```python
{% raw %}
{% from 'forms.html' import input as input_field, textarea %}
{% endraw %}
<dl>
    <dt>Username</dt>
    <dd>{{ input_field('username') }}</dd>
    <dt>Password</dt>
    <dd>{{ input_field('password', type='password') }}</dd>
</dl>
<p>{{ textarea('comment') }}</p>
```

Макросы и переменные, начинающиеся с одного или нескольких символов подчеркивания, являются частными и не могут быть импортированы.

_Изменено в версии 2.4:_ если объект шаблона был передан в контекст шаблона, вы можете импортировать его из этого объекта.

## Поведение контекста импорта (Import Context Behavior)

По умолчанию включенным шаблонам передается текущий контекст, а импортированным шаблонам - нет. Причина этого в том, что импорт, в отличие от включения, кэшируется; поскольку импорт часто используется как модуль, содержащий макросы.

Это поведение можно изменить явно: добавив _**with context**_ или _**without context**_ в директиву `import/include`, текущий контекст может быть передан в шаблон, и кеширование автоматически отключится.

Вот два примера:

```python
{% raw %}
{% from 'forms.html' import input with context %}
{% include 'header.html' without context %}
{% endraw %}
```

{% hint style="info" %}
**Примечание:**

В **Jinja** 2.0 контекст, который был передан во включенный шаблон, не включал переменные, определенные в шаблоне. На самом деле это не сработало:

```python
{% raw %}
{% for box in boxes %}
    {% include "render_box.html" %}
{% endfor %}
{% endraw %}
```

Включенный шаблон `render_box.html` не может получить доступ к полю в **Jinja** 2.0. Начиная с **Jinja** 2.1, `render_box.html` может это делать.
{% endhint %}

## Выражения (Expressions)

**Jinja** позволяет использовать базовые выражения везде. Они работают очень похоже на обычный Python; даже если вы не работаете с Python, вам должно быть комфортно с ним.

### Литералы (Literals)

Самая простая форма выражения - литералы. Литералы - это представления таких объектов Python, как строки и числа. Существуют следующие литералы:

* _**"Hello World"**_ - Все, что находится между двумя двойными или одинарными кавычками, является строкой. Они полезны всякий раз, когда вам нужна строка в шаблоне (например, в качестве аргументов для вызовов функций и фильтров или просто для расширения или включения шаблона).
* **42 / 123\_456** - Целые числа - это целые числа без десятичной части. Символ «\_» может использоваться для разделения групп для удобства чтения.
* **42.23 / 42.1e2 / 123\_456.789** - Числа с плавающей запятой могут быть записаны с использованием знака «.» в качестве десятичного знака. Они также могут быть записаны в экспоненциальной системе счисления с заглавной или строчной буквой «е» для обозначения экспоненты. Символ «\_» может использоваться для разделения групп для удобства чтения, но не может использоваться в экспоненциальной части.
* **\['list', 'of', 'objects'] -** Все, что находится в двух скобках, представляет собой список. Списки полезны для хранения последовательных данных для повторения. Например, вы можете легко создать список ссылок, используя списки и кортежи для (и с) цикла _**for**_:

```python
<ul>
{% for href, caption in [('index.html', 'Index'), ('about.html', 'About'),
                         ('downloads.html', 'Downloads')] %}
    <li><a href="{{ href }}">{{ caption }}</a></li>
{% raw %}
{% endfor %}
{% endraw %}
</ul>
```

* **('tuple', 'of', 'values') -** Кортежи похожи на списки, которые нельзя изменить («неизменяемые»). Если кортеж содержит только один элемент, за ним должна стоять запятая (`('1-tuple',)`). Кортежи обычно используются для представления элементов из двух или более элементов. См. пример списка выше для получения более подробной информации.
* **{'dict': 'of', 'key': 'and', 'value': 'pairs'} -** В Python словарь - это структура, объединяющая ключи и значения. Ключи должны быть уникальными и всегда иметь одно значение. Словари редко используются в шаблонах; они полезны в некоторых редких случаях, таких как фильтр **xmlattr ()**.
* **true / false - "**True" всегда `True`, а "False" всегда `False`.

{% hint style="info" %}
**Примечание:**

Специальные константы _**true**_, _**false**_ и _**none**_ действительно являются строчными. Поскольку в прошлом это вызывало путаницу (**True** использовалось для расширения до неопределенной переменной, которая считалась ложной), все три теперь также могут быть записаны в регистре заголовков (**True**, **False** и **None**). Однако для единообразия (все идентификаторы **Jinja** в нижнем регистре) следует использовать версии в нижнем регистре.
{% endhint %}

### Математика (Math)

**Jinja** позволяет выполнять вычисления со значениями. Это редко используется в шаблонах, но существует для полноты картины. Поддерживаются следующие операторы:

* **`+`** - Складывает два объекта вместе. Обычно объекты представляют собой числа, но если оба являются строками или списками, вы можете объединить их таким образом. Однако это не лучший способ объединения строк! Для конкатенации строк посмотрите на оператор `~`.  `{{ 1 + 1 }}` равно 2.
* **`-`**- Вычитает второе число из первого. `{{ 3 - 2 }}` равно `1`.
* **`/`** - Делит два числа. Возвращаемое значение будет числом с плавающей запятой. `{{ 1 / 2 }}` равно `{{ 0.5 }}` .
* **`//`** - Делит два числа и возвращает усеченный целочисленный результат. `{{ 20 // 7 }}` равно `2`.
* **`%`** - Вычисляет остаток от целочисленного деления. `{{ 11 % 7 }}` равно `4`.
* **`*`**- Умножает левый операнд на правый. `{{ 2 * 2 }}` вернет `4`. Это также можно использовать для повторения строки несколько раз. `{{ '=' * 80 }}` выведет полосу из 80 знаков равенства.
* **`**`** - Возвести левый операнд в степень правого операнда. `{{ 2 ** 3 }}` вернет `8`.

### Сравнения (Comparisons)

* **`==`** - Сравнивает два объекта на равенство.
* **`!=`** - Сравнивает два объекта на предмет неравенства.
* **`>`**- Значение `True`, если левая часть больше правой.
* **`>=`** - `True`, если левая часть больше или равна правой части.
* **`<`** - Значение `True`, если левая сторона меньше правой.
* **`<=`** - `True`, если левая сторона меньше или равна правой стороне.

### Логика (Logic)

Для операторов **if**, для фильтрации **for** и выражений **if** может быть полезно объединить несколько выражений:

* **and** - Возвращает `True`, если правый и левый операнды истинны.
* **or** - Возвращает `True`, если левый или правый операнд истинны.
* **not** - отрицает утверждение (см. ниже).
* **(expr)** - Скобки группируют выражение.

{% hint style="info" %}
**Примечание:**

Операторы **is** и **in** также поддерживают отрицание с использованием инфиксной нотации: **foo is not bar** и **foo not in bar**, вместо **not foo is bar** и **not foo in bar**. Для всех остальных выражений требуется префиксная запись: **not (foo and bar)**.
{% endhint %}

### Другие операторы

Следующие операторы очень полезны, но не входят ни в одну из двух других категорий:

* **`in`** - Выполняет тест на вхождение в последовательность/отображение. Возвращает `True`, если левый операнд содержится в правом. `{{ 1 in [1, 2, 3] }}` , например, вернет `True`.
* **`is`** - Выполняет тест.
* **`|`** - Применяет фильтр.
* **`~`** - Преобразует все операнды в строки и объединяет их. `{{ "Hello" ~ name ~ "!" }}` вернет (при условии, что _**name**_ установлено на `'John'`) `Hello John !`.
* **`()`** - Вызов вызываемого объекта: `{{ post.render() }}`. Внутри скобок вы можете использовать позиционные аргументы и аргументы ключевых слов, как в Python:  `{{ post.render(user, full=true) }}`.
* **`.`** / **`[]` -** Получить атрибут объекта. (См. переменные (Variables)).

### Выражение if

Также можно использовать встроенные выражения **if**. Это полезно в некоторых ситуациях. Например, вы можете использовать это для расширения из одного шаблона, если переменная определена, в противном случае из шаблона макета по умолчанию:

```python
{% raw %}
{% extends layout_template if layout_template is defined else 'master.html' %}
{% endraw %}
```

Общий синтаксис:  `<do something> if <something is true> else <do something else>`.

Часть _**else**_ не является обязательной. Если не указан, блок _**else**_ неявно преобразуется в объект **Undefined** (независимо от того, какое значение `undefined` в среде установлено):

```python
{{ "[{}]".format(page.title) if page.title }}
```

### Методы Python

Вы также можете использовать любой из методов, определенных для типа переменной. Значение, возвращаемое при вызове метода, используется как значение выражения. Вот пример, в котором используются методы, определенные для строк (где `page.title` - это строка):

```python
{{ page.title.capitalize() }}
```

Это работает для методов с пользовательскими типами. Например, если для переменной _**f**_ типа **Foo** определен метод _**bar**_, вы можете сделать следующее:

```python
{{ f.bar(value) }}
```

Методы операторов также работают должным образом. Например, `%` реализует стиль `printf` для строк:

```python
{{ "Hello, %s!" % name }}
```

Хотя в этом случае вам следует предпочесть метод `.format` (который немного надуман в контексте отрисовки шаблона):

```python
{{ "Hello, {}!".format(name) }}
```

## Список встроенных фильтров

| Список               | Список        | Список           | Список          |
| -------------------- | ------------- | ---------------- | --------------- |
| **abs()**            | **groupby()** | **reject()**     | **title()**     |
| **attr()**           | **indent()**  | **rejectattr()** | **tojson()**    |
| **batch()**          | **int()**     | **replace()**    | **trim()**      |
| **capitalize()**     | **join()**    | **reverse()**    | **truncate()**  |
| **center()**         | **last()**    | **round()**      | **unique()**    |
| **default()**        | **length()**  | **safe()**       | **upper()**     |
| **dictsort()**       | **list()**    | **select()**     | **urlencode()** |
| **escape()**         | **lower()**   | **selectattr()** | **urlize()**    |
| **filesizeformat()** | **map()**     | **slice()**      | **wordcount()** |
| **first()**          | **max()**     | **sort()**       | **wordwrap()**  |
| **float()**          | **min()**     | **string()**     | **xmlattr()**   |
| **forceescape()**    | **pprint()**  | **striptags()**  |                 |
| **format()**         | **random()**  | **sum()**        |                 |

* &#x20;**abs**(_x_, _/_ ) - Возвращает абсолютное значение аргумента.
* &#x20;**attr**(_obj_, _name_) - Получает атрибут объекта. `foo | attr ("bar")` работает так же, как `foo.bar`, только всегда возвращается атрибут, а элементы не просматриваются. Подробнее см. примечания к подпискам (**Notes on subscriptions**).
* &#x20;**batch**(_value_, _linecount_, _fill\_with=None_) - Фильтр, который группирует элементы. Это работает почти так же, как _**slice**_, только наоборот. Он возвращает список списков с заданным количеством элементов. Если вы указываете второй параметр, он используется для заполнения недостающих элементов. См. этот пример:

```python
<table>
{% raw %}
{%- for row in items|batch(3, '&nbsp;') %}
  <tr>
  {%- for column in row %}
    <td>{{ column }}</td>
  {%- endfor %}
  </tr>
{%- endfor %}
{% endraw %}
</table>
```

{% hint style="success" %}
**Примечание:** Позволяет сгруппировать элементы одного списка в несколько сегментов, каждый из которых содержит до _**linecount**_ элементов, где _**linecount**_ - это номер, который мы указываем. При желании мы также можем попросить _**batch()**_ дополнить строку записями по умолчанию _**fill\_with**_, чтобы все строки имели длину ровно _**linecount**_. Результат - список списков. В примере выше один список разбивается на список списков с 3 элементами в каждой строке. Если элементов не хватает, то пустые ячейки заполняются символом `'&nbsp;'`.
{% endhint %}

* &#x20;**capitalize**(_s_) - Создает значение с заглавной буквы. Первый символ будет заглавным, все остальные - строчными.
* &#x20;**center**(_value_, _width=80_) - Центрирует значение в поле заданной ширины.
* &#x20;**default**(_value_, _default\_value=''_, _boolean=False_) - Если значение не определено, оно вернет переданное значение по умолчанию, в противном случае значение переменной:

```python
{{ my_variable|default('my_variable is not defined') }}
```

Это выведет значение `my_variable`, если переменная была определена, иначе выведет _**default\_value**_ - `'y_variable is not defined'`. Если вы хотите использовать значение по умолчанию для переменных, которые оцениваются как `False`, вы должны установить для второго параметра _**boolean**_ значение `True`:

```python
{{ ''|default('the string was empty', true) }}
```

_Изменено в версии 2.11:_ теперь можно настроить среду с помощью **ChainableUndefined**, чтобы фильтр по умолчанию работал с вложенными элементами и атрибутами, которые могут содержать неопределенные значения в цепочке без получения **UndefinedError**.

**Псевдонимы:** **`d`**

* &#x20;**dictsort**(_value_, _case\_sensitive=False_, _by='key'_, _reverse=False_) - Сортирует пары _**dict**_ и _**yield**_ `(key, value)`. Поскольку слова Python не отсортированы, вы можете использовать эту функцию, чтобы упорядочить их по ключу или значению:

```python
{% raw %}
{% for item in mydict|dictsort %}
    отсортировать словарь по ключу, без учета регистра

{% for item in mydict|dictsort(reverse=true) %}
    сортировать словарь по ключу, без учета регистра, в обратном порядке

{% for item in mydict|dictsort(true) %}
    сортировать словарь по ключу, с учетом регистра

{% for item in mydict|dictsort(false, 'value') %}
{% endraw %}
    отсортировать словарь по значению, без учета регистра
```

* &#x20;**escape**(_s_) - Конвертирует символы `&`, `<`, `>`, `'` и `"` в строке _**s**_ в безопасные для HTML последовательности. Используйте это, если вам нужно отобразить текст, который может содержать такие символы в HTML. Помечает возвращаемое значение как строку разметки.

**Псевдонимы:** **`e`**

* &#x20;**filesizeformat**(_value_, _binary=False_) - Форматирует значение как «удобочитаемый» файл (например, 13 кБ, 4,1 МБ, 102 байта и т. д.). По умолчанию используются десятичные префиксы (Mega, Giga и т. д.), Если для второго параметра установлено значение `True`, используются двоичные префиксы (Mebi, Gibi).
* &#x20;**first**(_seq_) - Возвращает первый элемент последовательности.
* &#x20;**float**(_value_, _default=0.0_) - Преобразует значение в число с плавающей запятой. Если преобразование не работает, возвращается 0,0. Вы можете изменить это значение по умолчанию, используя первый параметр.
* &#x20;**forceescape**(_value_) - Принудительное экранирование HTML. Это, вероятно, удвоит escape-переменные.
* &#x20;**format**(_value_, _\*args_, _\*\*kwargs_) - Примените заданные значения к строке формата в стиле `printf`, например `string % values`.

```python
{{ "%s, %s!"|format(greeting, name) }}
Hello, World!
```

В большинстве случаев удобнее и эффективнее использовать оператор `%` или `str.format ()`.

```python
{{ "%s, %s!" % (greeting, name) }}
{{ "{}, {}!".format(greeting, name) }}
```

* &#x20;**groupby**(_value_, _attribute_) - Группирует последовательность объектов по атрибуту с помощью Python **`itertools.groupby ()`**. Атрибут может использовать точечную нотацию для вложенного доступа, например `address.city`. В отличие от Python **groupby**, значения сортируются первыми, поэтому для каждого уникального значения возвращается только одна группа. Например, список объектов «`User`» с атрибутом «`city`» может отображаться в группах. В этом примере `grouper` относится к значению города `city` в группе.

```python
<ul>{% raw %}
{% for city, items in users|groupby("city") %}
  <li>{{ city }}
    <ul>{% for user in items %}
      <li>{{ user.name }}
    {% endfor %}</ul>
  </li>
{% endfor %}
{% endraw %}</ul>
```

**groupby** возвращает именованный кортеж `(grouper, list)`, которые можно использовать вместо распаковки кортежей, описанной выше. `grouper` - это значение атрибута, а `list` - это элементы с этим значением.

```python
<ul>{% raw %}
{% for group in users|groupby("city") %}
  <li>{{ group.grouper }}: {{ group.list|join(", ") }}
{% endfor %}
{% endraw %}</ul>
```

_Изменено в версии 2.6:_ Атрибут поддерживает точечную нотацию для вложенного доступа.

* &#x20;**indent**(_s_, _width=4_, _first=False_, _blank=False_, _indentfirst=None_) - Возвращает копию строки с отступом в 4 пробела для каждой строки. По умолчанию первая строка и пустые строки не имеют отступа. Параметры:
  * _**width**_ - Количество пробелов, на которые нужно сделать отступ.
  * _**first**_ - Не пропускает отступ в первой строке.
  * _**blank**_ - Не пропускает отступы для пустых строк.

_Изменено в версии 2.10:_ по умолчанию пустые строки не имеют отступа. Переименован аргумент _**indentfirst**_ в _**first**_.

* &#x20;**int**(_value_, _default=0_, _base=10_) - Конвертирует значение в целое число. Если преобразование не работает, возвращается `0`. Вы можете изменить это значение по умолчанию, используя первый параметр. Вы также можете переопределить базу по умолчанию (`10`) во втором параметре, который обрабатывает ввод с такими префиксами, как `0b`, `0o` и `0x` для оснований `2`, `8` и `16` соответственно. База игнорируется для десятичных чисел и нестроковых значений.
* &#x20;**join**(_value_, _d=''_, _attribute=None_) - Возвращает строку, которая является объединением строк в последовательности. Разделителем между элементами по умолчанию является пустая строка, вы можете определить его с помощью необязательного параметра:

```python
{{ [1, 2, 3]|join('|') }}
    -> 1|2|3

{{ [1, 2, 3]|join }}
    -> 123
```

Также возможно присоединение определенных атрибутов объекта:

```python
{{ users|join(', ', attribute='username') }}
```

_Новое в версии 2.6:_ добавлен параметр _**attribute**_.

* &#x20;**last**(_seq_) - Возвращает последний элемент последовательности. Примечание: не работает с генераторами. Вы можете явно преобразовать его в список:

```python
{{ data | selectattr('name', '==', 'Jinja') | list | last }}
```

* &#x20;**length**(_obj_, _/_) - Возвращает количество предметов в контейнере.

**Псевдонимы:** **`count`**

* &#x20;**list**(_value_) - Конвертирует значение в список. Если это была строка, возвращаемый список будет списком символов.
* &#x20;**lower**(_s_) - Преобразуйте значение в нижний регистр.
* &#x20;**map**(_\*args_, _\*\*kwargs_) - Применяет фильтр к последовательности объектов или ищет атрибут. Это полезно при работе со списками объектов, но на самом деле вас интересует только его определенное значение. Основное использование - отображение атрибута. Представьте, что у вас есть список пользователей, но вас интересует только список имен пользователей:

```python
Users on this page: {{ users|map(attribute='username')|join(', ') }}
```

Вы можете указать значение по умолчанию _**default**_, которое будет использоваться, если объект в списке не имеет данного атрибута.

```python
{{ users|map(attribute="username", default="Anonymous")|join(", ") }}
```

В качестве альтернативы вы можете позволить ему вызывать фильтр, передав имя фильтра и аргументы впоследствии. Хорошим примером может быть применение фильтра преобразования текста к последовательности:

```python
Users on this page: {{ titles|map('lower')|join(', ') }}
```

Подобно пониманию генератора, например:

```python
(u.username for u in users)
(u.username or "Anonymous" for u in users)
(do_lower(x) for x in titles)
```

_Новое в версии 2.7_.

_Изменено в версии 2.11.0:_ Добавлен параметр по умолчанию _**default**_.

*   &#x20;**max**(_value_, _case\_sensitive=False_, _attribute=None_) - Возвращает самый большой элемент из последовательности.

    ```python
    {{ [1, 2, 3]|max }}
        -> 3
    ```

    Параметры _**max**_:

    * _**case\_sensitive**_ - Обращайтесь к строкам верхнего и нижнего регистра по отдельности.
    * _**attribute**_ - Получает объект с максимальным значением этого атрибута.
*   **min**(_value_, _case\_sensitive=False_, _attribute=None_) - Возвращает самый маленький элемент из последовательности.

    ```python
    {{ [1, 2, 3]|min }}
        -> 1
    ```

    Параметры _**min**_:

    * _**case\_sensitive**_ - Обращайтесь к строкам верхнего и нижнего регистра по отдельности.
    * _**attribute**_ - Получает объект с максимальным значением этого атрибута.
* &#x20;**pprint**(_value_, _verbose=False_) - Печатает красиво оформленный вывод. Полезно для отладки. Начиная с **Jinja** 1.2, вы можете передавать ему параметр. Если этот параметр `True`, вывод будет более подробным (для этого требуется довольно).
* &#x20;**random**(_seq_) - Возвращает случайный элемент из последовательности.
* &#x20;**reject**(_\*args_, _\*\*kwargs_) - Фильтрует последовательность объектов, применяя тест к каждому объекту и отклоняя объекты при успешном завершении теста. Если тест не указан, каждый объект будет оцениваться как логическое. Пример использования:

```python
{{ numbers|reject("odd") }}
```

Подобно пониманию генератора, например:

```python
(n for n in numbers if not test_odd(n))
```

_Новое в версии 2.7_.

* &#x20;**rejectattr**(_\*args_, _\*\*kwargs_) - Фильтрует последовательность объектов, применяя тест к указанному атрибуту каждого объекта и отклоняя объекты при успешном завершении теста. Если проверка не указана, значение атрибута будет оцениваться как логическое.

```python
{{ users|rejectattr("is_active") }}
{{ users|rejectattr("email", "none") }}
```

Подобно пониманию генератора, например:

```python
(u for user in users if not user.is_active)
(u for user in users if not test_none(user.email))
```

_Новое в версии 2.7_.

* &#x20;**replace**(_s_, _old_, _new_, _count=None) -_ Возвращает копию значения со всеми вхождениями подстроки, замененной новой. Первый аргумент - это подстрока, которую следует заменить, второй - строка замены. Если указан необязательный третий аргумент _**count**_, заменяются только первые вхождения _**count**_:

```python
{{ "Hello World"|replace("Hello", "Goodbye") }}
    -> Goodbye World

{{ "aaaaargh"|replace("a", "d'oh, ", 2) }}
    -> d'oh, d'oh, aaargh
```

* &#x20;**reverse**(_value_) - Разворачивает объект или верните итератор, который перебирает его в обратном порядке.
* &#x20;**round**(_value_, _precision=0_, _method='common'_) - Округляет число до заданной точности. Первый параметр указывает точность _**precision**_ (по умолчанию 0), второй - метод округления _**method**_:
  * _**common**_ - округляет вверх или вниз
  * _**ceil**_ - всегда округляет вверх
  * _**floor**_ - всегда округляет вниз

Если вы не укажете метод, будет использован «_**common**_».

```python
{{ 42.55|round }}
    -> 43.0
{{ 42.55|round(1, 'floor') }}
    -> 42.5
```

Обратите внимание, что даже при округлении до `0` точности возвращается число с плавающей запятой. Если вам нужно действительное целое число, пропустите его через _**int**_:

```python
{{ 42.55|round|int }}
    -> 43
```

* &#x20;**safe**(_value_) - Отмечает значение как безопасное, что означает, что в среде с включенным автоматическим экранированием эта переменная не будет экранирована.
* &#x20;**select**(_\*args_, _\*\*kwargs_) - Фильтрует последовательность объектов, применяя тест к каждому объекту и выбирая только те объекты, которые завершаются успешно. Если тест не указан, каждый объект будет оцениваться как логическое значение. Пример использования:

```python
{{ numbers|select("odd") }}
{{ numbers|select("odd") }}
{{ numbers|select("divisibleby", 3) }}
{{ numbers|select("lessthan", 42) }}
{{ strings|select("equalto", "mystring") }}
```

Подобно действию генератора, например:

```python
(n for n in numbers if test_odd(n))
(n for n in numbers if test_divisibleby(n, 3))
```

_Новое в версии 2.7_.

* &#x20;**selectattr**(_\*args_, _\*\*kwargs_) - Фильтрует последовательность объектов, применяя тест к указанному атрибуту каждого объекта и выбирая только те объекты, которые прошли успешно. Если проверка не указана, значение атрибута будет оцениваться как логическое значение. Пример использования:

```python
{{ users|selectattr("is_active") }}
{{ users|selectattr("email", "none") }}
```

Подобно действию генератора, например:

```python
(u for user in users if user.is_active)
(u for user in users if test_none(user.email))
```

_Новое в версии 2.7_.

* &#x20;**slice**(_value_, _slices_, _fill\_with=None_) - Разрезает итератор и возвращает список списков, содержащих эти элементы. Полезно, если вы хотите создать _**div**_, содержащий три тега _**ul**_, представляющих столбцы:

```python
<div class="columnwrapper">
  {% raw %}
{%- for column in items|slice(3) %}
    <ul class="column-{{ loop.index }}">
    {%- for item in column %}
      <li>{{ item }}</li>
    {%- endfor %}
    </ul>
  {%- endfor %}
{% endraw %}
</div>
```

Если вы передадите ему второй аргумент _**fill\_with**_, он будет использоваться для заполнения пропущенных значений на последней итерации.

* &#x20;**sort**(_value_, _reverse=False_, _case\_sensitive=False_, _attribute=None_) - Сортирует итерацию с помощью функции Python `sorted ()`.

```python
{% raw %}
{% for city in cities|sort %}
    ...
{% endfor %}
{% endraw %}
```

Параметры _**sort**_:

*
  * _**reverse**_ - Сортировка по убыванию, а не по возрастанию.
  * _**case\_sensitive**_ - При сортировке строк сортируйте верхний и нижний регистр отдельно.
  * _**attribute**_ - При сортировке объектов или словарей, применяет атрибут или ключ для сортировки. Можно использовать точечную нотацию, например "`address.city`". Может быть списком атрибутов, например «`age, name`».

Сортировка стабильна, она не меняет относительный порядок сравниваемых элементов. Это позволяет объединять сортировки в цепочки по различным атрибутам и порядку.

```python
{% for user in users|sort(attribute="name")
    |sort(reverse=true, attribute="age") %}
    ...
{% raw %}
{% endfor %}
{% endraw %}
```

Для быстрого перехода к цепочке, когда направление одинаково для всех атрибутов, передайте список атрибутов, разделенный запятыми.

```python
{% raw %}
{% for user users|sort(attribute="age,name") %}
    ...
{% endfor %}
{% endraw %}
```

_Изменено в версии 2.6:_ Добавлен параметр _**attribute**_.

_Изменено в версии 2.11.0:_ Параметр атрибута может быть списком атрибутов, разделенных запятыми, например "`age, name`".

* &#x20;**string**(_object_) - Создает строковый **Unicode**, если это еще не сделано. Таким образом, строка разметки не преобразуется обратно в **Unicode**.
* &#x20;**striptags**(_value_) - Удаляет теги SGML/XML и заменяет соседние пробелы одним пробелом.
* &#x20;**sum**(_iterable_, _attribute=None_, _start=0_) - Возвращает сумму последовательности чисел плюс значение параметра «_**start**_» (по умолчанию `0`). Когда последовательность пуста, возвращается _**start**_. Также можно суммировать только определенные атрибуты:

```python
Total: {{ items|sum(attribute='price') }}
```

_Изменено в версии 2.6:_ добавлен параметр _**attribute**_, позволяющий суммировать атрибуты. Также начальный параметр был перемещен вправо.

* &#x20;**title**(_s_) - Возвращает версию значения в заголовке. Т.е. слова начинаются с прописных букв, все остальные символы - строчными.
* &#x20;**tojson**(_value_, _indent=None_) - Сохраняет структуру в JSON, чтобы ее можно было безопасно использовать в тегах `<script>` . Он принимает те же аргументы и возвращает строку JSON. Обратите внимание, что это доступно в шаблонах через фильтр `| tojson`, который также пометит результат как безопасный. Благодаря тому, как эта функция экранирует определенные символы, это безопасно даже при использовании вне тегов `<script>`. Следующие символы экранируются в строках: `<`, `>`, `&`, `'`. Это позволяет безопасно встраивать такие строки в любое место HTML, за исключением атрибутов, заключенных в двойные кавычки. В этом случае одиночные кавычки для ваших атрибутов или HTML дополнительно экранируют его. Параметр _**indent**_ можно использовать для включения красивой печати. Установите количество пробелов, с которыми должны быть отступы структуры. Обратите внимание, что этот фильтр предназначен для использования только в контексте HTML. _Новое в версии 2.9_.
* &#x20;**trim**(_value_, _chars=None_) - Удаляет начальные и конечные символы, по умолчанию пробелы.
* &#x20;**truncate**(_s_, _length=255_, _killwords=False_, _end='...'_, _leeway=None_) - Возвращает усеченную копию строки. Длина _**length**_ указывается в первом параметре, который по умолчанию равен `255`. Если значение второго параметра _**killwords**_ истинно, фильтр будет обрезать текст по длине. В противном случае последнее слово будет отброшено. Если текст действительно был обрезан, к нему будет добавлен знак многоточия (`"..."`). Если вам нужен другой знак многоточия, чем `"..."`, вы можете указать его с помощью третьего параметра _**end**_. Строки, длина которых превышает допустимый предел, указанный в четвертом параметре _**leeway**_, не будут усечены.

```python
{{ "foo bar baz qux"|truncate(9) }}
    -> "foo..."
{{ "foo bar baz qux"|truncate(9, True) }}
    -> "foo ba..."
{{ "foo bar baz qux"|truncate(11) }}
    -> "foo bar baz qux"
{{ "foo bar baz qux"|truncate(11, False, '...', 0) }}
    -> "foo bar..."
```

По умолчанию для новых версий **Jinja** используется `5`, а раньше было `0`, но его можно изменить глобально.

* &#x20;**unique**(_value_, _case\_sensitive=False_, _attribute=None_) - Возвращает список уникальных элементов из заданного итеративного объекта.

```python
{{ ['foo', 'bar', 'foobar', 'FooBar']|unique|list }}
    -> ['foo', 'bar', 'foobar']
```

Уникальные элементы выводятся в том же порядке, что и их первое вхождение в итерации, переданной фильтру. Параметры:

*
  * _**case\_sensitive**_ - При сортировке строк сортируйте верхний и нижний регистр отдельно.
  * _**attribute**_ - Отфильтруйте объекты с уникальными значениями этого атрибута.
* &#x20;**upper**(_s_) - Преобразует значение в верхний регистр.
* &#x20;**urlencode**(_value_) - Цитирует данные для использования в пути URL или запросе с использованием UTF-8. Базовая оболочка для **urllib.parse.quote ()** при задании строки или **urllib.parse.urlencode ()** для словаря или итерации. Параметры:
  * _**value**_ - Данные для цитирования. Строка будет заключена в кавычки напрямую. Словарь или итерация пар `(key, value)` будет объединена как строка запроса.

Если дана строка, «`/`» не помещается кавычки. Серверы HTTP обрабатывают пути «`/`» и «`%2F`» одинаково. Если вам нужны кавычки, используйте фильтр `|replace("/", "%2F")`. _Новое в версии 2.7_.

* &#x20;**urlize**(_value_, _trim\_url\_limit=None, nofollow=False, target=None, rel=None) -_ Преобразует URL-адреса в виде обычного текста в интерактивные ссылки. Если вы передадите фильтру дополнительное целое число _ **trim\_url\_limit**_, он сократит URL-адреса до этого числа. Также существует третий аргумент _**nofollow**_, который делает URL-адреса «_**nofollow**_»:

```python
{{ mytext|urlize(40, true) }}
    links are shortened to 40 chars and defined with rel="nofollow"
```

Если указан _**target**_, целевой атрибут `target` будет добавлен в тег `<a>`:

```python
{{ mytext|urlize(40, target='_blank') }}
```

_Изменено в версии 2.8+:_ добавлен параметр _**target**_.

* &#x20;**wordcount**(_s_) - Подсчитывает слова в этой строке _**s**_.
* &#x20;**wordwrap**(_s_, _width=79_, _break\_long\_words=True_, _wrapstring=None_, _break\_on\_hyphens=True_) - Оборачивает строку до заданной ширины. Существующие символы новой строки обрабатываются как абзацы, которые нужно переносить отдельно. Параметры:
  * _**s**_ - Исходный текст для переноса.
  * _**width**_ - Максимальная длина обертываемых строк.
  * _**break\_long\_words**_ - Если слово длиннее _**width**_, переносит его на другую строку.
  * _**break\_on\_hyphens**_ - Если слово содержит дефис, оно может быть перенесено на другую строку.
  * _**wrapstring**_ - Строка для присоединения к каждой обернутой строке. По умолчанию **Environment.newline\_sequence**.

_Изменено в версии 2.7:_ Добавлен параметр _**wrapstring**_.

_Изменено в версии 2.11:_ существующие символы новой строки обрабатываются как отдельные абзацы.

_Изменено в версии 2.11:_ Добавлен параметр _**break\_on\_hyphens**_.

* &#x20;**xmlattr**(_d_, _autospace=True_) - Создает строку атрибута SGML/XML на основе элементов в словаре. Все значения, которые не являются ни _**none**_, ни _**undefined**_, автоматически экранируются:

```python
<ul{{ {'class': 'my_list', 'missing': none,
        'id': 'list-%d'|format(variable)}|xmlattr }}>
...
</ul>
```

Результат примерно такой:

```python
<ul class="my_list" id="list-42">
...
</ul>
```

Как вы можете видеть, он автоматически добавляет пробел перед элементом, если фильтр что-то возвращает, если только второй параметр _**autospace**_ не равен `False`.

## Список встроенных тестов

| Списки        | Списки     | Списки    | Списки      |
| ------------- | ---------- | --------- | ----------- |
| boolean()     | false()    | le()      | odd()       |
| callable()    | float()    | lower()   | sameas()    |
| defined()     | ge()       | lt()      | sequence()  |
| divisibleby() | gt()       | mapping() | string()    |
| eq()          | in()       | ne()      | true()      |
| escaped()     | integer()  | none()    | undefined() |
| even()        | iterable() | number()  | upper()     |

* &#x20;**boolean**(_value_) - Возвращает `True`, если объект является логическим значением. _Новое в версии 2.11_.
* &#x20;**callable**(_obj_, _/_) - Возвращает, является ли объект вызываемым (то есть какой-то функцией). Обратите внимание, что классы являются вызываемыми, как и экземпляры классов с методом `__call()__`.
* &#x20;**defined**(_value_) - Возвращает `True`, если переменная определена:

```python
{% raw %}
{% if variable is defined %}
    value of variable: {{ variable }}
{% else %}
    variable is not defined
{% endif %}
{% endraw %}
```

См. `default ()`, чтобы узнать простой способ установить неопределенные переменные.

* &#x20;**divisibleby**(_value_, _num_) - Проверяет, делится ли переменная на число.
* &#x20;**eq**(_a_, _b_, _/_) - То же, что `a == b`. **Псевдонимы**: **`==`**, **`equalto`**.
* &#x20;**escaped**(_value_) - Проверяет, экранировано ли значение.
* &#x20;**even**(_value_) - Возвращает `True`, если переменная четная.
* &#x20;**false**(_value_) - Возвращает `True`, если объект `False`. _Новое в версии 2.11_.
* &#x20;**float**(_value_) - Возвращает `True`, если объект является числом с плавающей точкой. _Новое в версии 2.11_.
* &#x20;**ge**(_a_, _b_, _/_) - То же, что и `a >= b`. **Псевдонимы**: **`>=`**.
* &#x20;**gt**(_a_, _b_, _/_) - То же, что и `a > b`. **Псевдонимы**: **`>`**, **`greaterthan`**.
* **in**(_value, seq_) - Проверьте, входит ли указанное значение _**value**_ в последовательность _**seq**_. _Новое в версии 2.10_.
* &#x20;**integer**(_value_) - Возвращает `True`, если объект является целым числом. _Новое в версии 2.11_.
* &#x20;**iterable**(_value_) - Проверяет, можно ли перебирать объект.
* &#x20;**le**(_a_, _b_, _/_) - То же, что и `a <= b`. **Псевдонимы**: **`<=`**.
* &#x20;**lower**(_value_) - Возвращает `True`, если переменная в нижнем регистре.
* &#x20;**lt**(_a_, _b_, _/_) - То же, что и `a < b`. **Псевдонимы**: **`<`**, **`lessthan`**.
* &#x20;**mapping**(_value_) - Возвращает `True`, если объект является отображением (dict и т. д.). _Новое в версии 2.6_.
* &#x20;**ne**(_a_, _b_, _/_) - То же, что `a != b`. **Псевдонимы**: **`!=`**.
* &#x20;**none**(_value_) - Возвращает `True`, если переменная равна `None`.
* &#x20;**number**(_value_) - Возвращает `True`, если переменная является числом.
* &#x20;**odd**(_value_) - Возвращает `True`, если переменная нечетная.
* &#x20;**sameas**(_value_, _other_) - Проверьте, указывает ли объект на тот же адрес памяти, что и другой объект:

```python
{% raw %}
{% if foo.attribute is sameas false %}
    the foo attribute really is the `False` singleton
{% endif %}
{% endraw %}
```

* &#x20;**sequence**(_value_) - Возвращает `True`, если переменная является последовательностью. Последовательности - это переменные, которые можно повторять.
* &#x20;**string**(_value_) - Возвращает `True`, если объект является строкой.
* &#x20;**true**(_value_) - Верните `true`, если объект `True`. _Новое в версии 2.11_.
* &#x20;**undefined**(_value_) - Как `defined ()`, но наоборот.
* &#x20;**upper**(_value_) - Возвращает `True`, если переменная написана в верхнем регистре.

## Список глобальных функций

По умолчанию в глобальной области видимости доступны следующие функции:

### функция range()

#### &#x20;range( \[ _start_, ] _stop_ \[, _step_ ] )

Возвращает список, содержащий арифметическую прогрессию целых чисел. `range (i, j)` возвращает `[i, i + 1, i + 2, ..., j-1]`; _**start**_ (!) по умолчанию `0`. Когда задан шаг, он указывает приращение (или уменьшение). Например, `range (4)` и `range (0, 4, 1)` возвращают `[0, 1, 2, 3]`. Конечная точка опущена! Это как раз правильные индексы для списка из 4 элементов.

Это полезно для повторения блока шаблона несколько раз, например заполнить список. Представьте, что у вас есть 7 пользователей в списке, но вы хотите отобразить три пустых элемента, чтобы задать высоту с помощью CSS:

```python
<ul>
{% raw %}
{% for user in users %}
    <li>{{ user.username }}</li>
{% endfor %}
{% for number in range(10 - users|count) %}
    <li class="empty"><span>...</span></li>
{% endfor %}
{% endraw %}
</ul>
```

### функция lipsum()

#### &#x20;lipsum(_n=5_, _html=True_, _min=20_, _max=100_)

Создает некоторую `lorem ipsum` для шаблона. По умолчанию создается пять абзацев HTML _**n**_ с каждым абзацем от _**min**_ 20 до _**max**_ 100 слов. Если _**html**_ имеет значение `False`, возвращается обычный текст. Это полезно для создания простого содержимого для тестирования макета.

### функция dict()

#### &#x20;dict(_\*\*items_)

Удобная альтернатива литералам словаря. `{'foo': 'bar'}` то же самое, что и `dict (foo = 'bar')`.

### класс cycler

#### &#x20;_class_ cycler(_\*items_)

Прокручивает значения, выдавая их по одному, а затем перезапускает, когда будет достигнут конец.

Аналогичен `loop.cycle`, но может использоваться вне циклов или в нескольких циклах. Например, отобразите список папок и файлов в списке, поочередно присваивая им нечетные _**odd**_ и четные _**even**_ классы.

```python
{% raw %}
{% set row_class = cycler("odd", "even") %}
<ul class="browser">
{% for folder in folders %}
  <li class="folder {{ row_class.next() }}">{{ folder }}
{% endfor %}
{% for file in files %}
  <li class="file {{ row_class.next() }}">{{ file }}
{% endfor %}
{% endraw %}
</ul>
```

#### Параметры cycler:

* _**items**_ - Каждый позиционный аргумент будет выдаваться в порядке, указанном для каждого цикла.

_Новое в версии 2.1_.

### свойство current

#### &#x20;_property_ current

Возвращает текущий элемент. Эквивалентно элементу, который будет возвращен при следующем вызове **next ()**.

### функция next()

Возвращает текущий элемент, затем переходит к следующему элементу.

### функция reset()

Сбрасывает текущий элемент на первый элемент.

### класс joiner

#### &#x20;_class_ joiner(_sep='_, _'_)

Небольшой помощник, который можно использовать для «объединения» нескольких разделов. Соединителю передается строка, и он будет возвращать эту строку при каждом вызове, кроме первого раза (в этом случае он возвращает пустую строку). Вы можете использовать это для объединения вещей:

```python
{% raw %}
{% set pipe = joiner("|") %}
{% if categories %} {{ pipe() }}
    Categories: {{ categories|join(", ") }}
{% endif %}
{% if author %} {{ pipe() }}
    Author: {{ author() }}
{% endif %}
{% if can_edit %} {{ pipe() }}
    <a href="?action=edit">Edit</a>
{% endif %}
{% endraw %}
```

_Новое в версии 2.1_.

### класс namespace

#### &#x20;_class_ namespace(_..._)

Создает новый контейнер, который позволяет назначать атрибуты с помощью тега `{% set %}` :

```python
{% raw %}
{% set ns = namespace() %}
{% set ns.foo = 'bar' %}
{% endraw %}
```

Основная цель этого - позволить переносить значение из тела цикла во внешнюю область. Начальные значения могут быть предоставлены как словарь, как аргументы ключевого слова или и то, и другое (поведение конструктора _**dict**_ в Python):

```python
{% raw %}
{% set ns = namespace(found=false) %}
{% for item in items %}
    {% if item.check_something() %}
        {% set ns.found = true %}
    {% endif %}
    * {{ item.title }}
{% endfor %}
{% endraw %}
Found item having something: {{ ns.found }}
```

_Новое в версии 2.10_.

## Расширения (Extensions)

В следующих разделах описаны встроенные расширения Jinja, которые могут быть включены приложением. Приложение может также предоставлять дополнительные расширения, не описанные в этой документации; в этом случае должен быть отдельный документ, объясняющий указанные [расширения](rasshireniya-jinja.md).

### i18n

Если [расширение i18n](rasshireniya-jinja.md) включено, можно пометить текст в шаблоне как переводимый. Чтобы пометить раздел как переводимый, используйте блок _**trans**_:

```python
{% raw %}
{% trans %}Hello, {{ user }}!{% endtrans %}
{% endraw %}
```

Внутри блока не допускаются никакие операторы, только текст и простые теги переменных.

Теги переменных могут быть только именем, а не доступом к атрибутам, фильтрами или другими выражениями. Чтобы использовать выражение, привяжите его к имени в теге _**trans**_ для использования в блоке.

```python
{% raw %}
{% trans user=user.username %}Hello, {{ user }}!{% endtrans %}
{% endraw %}
```

Чтобы связать более одного выражения, разделите их запятыми (`,`).

```python
{% raw %}
{% trans book_title=book.title, author=author.name %}
This is {{ book_title }} by {{ author }}
{% endtrans %}
{% endraw %}
```

Для множественного числа укажите формы единственного и множественного числа, разделенные тегом _**pluralize**_.

```python
{% raw %}
{% trans count=list|length %}
There is {{ count }} {{ name }} object.
{% pluralize %}
There are {{ count }} {{ name }} objects.
{% endtrans %}
{% endraw %}
```

По умолчанию первая переменная в блоке используется, чтобы определить, использовать ли форму единственного или множественного числа. Если это неверно, укажите переменную, используемую для множественного числа, как параметр для _**pluralize**_.

```python
{% raw %}
{% trans ..., user_count=users|length %}...
{% pluralize user_count %}...{% endtrans %}
{% endraw %}
```

При переводе блоков текста пробелы и разрывы строк приводят к тому, что строки перевода становятся трудночитаемыми и подверженными ошибкам. Чтобы избежать этого, транс-блок можно пометить как _**trimmed**_, при этом все разрывы строк и окружающие их пробелы будут заменены одним пробелом и будут удалены начальные и конечные пробелы.

```python
{% raw %}
{% trans trimmed book_title=book.title %}
    This is {{ book_title }}.
    You should read it!
{% endtrans %}
{% endraw %}
```

В результате получается `This is %(book_title)s. You should read it!` в файле перевода.

Если обрезка включена глобально, можно использовать модификатор _**notrimmed**_, чтобы отключить ее для блока.

_Новое в версии 2.10:_ добавлены модификаторы _**trimmed**_ и _**notrimmed**_.

Строки в выражениях можно переводить с помощью следующих функций:

* _**gettext**_ - перевести одну строку
* _**ngettext**_ - перевести множество строк
* **`_`** - псевдоним для _**gettext**_

Вы можете напечатать переведенную строку следующим образом:

```python
{{ _("Hello, World!") }}
```

Чтобы использовать заполнители, используйте фильтр _**format**_.

```python
{{ _("Hello, %(user)s!")|format(user=user.username) }}
```

Всегда используйте аргументы ключевого слова для форматирования _**format**_, поскольку другие языки могут не использовать слова в том же порядке.

Если активированы вызовы [Gettext в новом стиле](rasshireniya-jinja.md) (New Style Gettext), использовать заполнители проще. Форматирование является частью вызова _**gettext**_ вместо использования фильтра _**format**_.

```python
{{ gettext('Hello World!') }}
{{ gettext('Hello %(name)s!', name='World') }}
{{ ngettext('%(num)d apple', '%(num)d apples', apples|count) }}
```

Строка формата функции _**ngettext**_ автоматически получает счетчик как параметр _**num**_ в дополнение к заданным параметрам.

### Выражение-оператор

Если загружено расширение выражения-оператора, доступен тег с именем _**do**_, который работает точно так же, как выражение регулярной переменной (`{{ ... }}`); кроме того, что он ничего не печатает. Это можно использовать для изменения списков:

```python
{% raw %}
{% do navigation.append('a string') %}
{% endraw %}
```

### Управление циклами

Если приложение включает элементы [управления циклом](rasshireniya-jinja.md) (**Loop Controls**), можно использовать прерывание _**break**_ и продолжение _**continue**_ в циклах. При достижении _**break**_ цикл завершается; при достижении _**continue**_ обработка останавливается и продолжается со следующей итерации. Вот цикл, в котором пропускается каждый второй элемент:

```python
{% raw %}
{% for user in users %}
    {%- if loop.index is even %}{% continue %}{% endif %}
    ...
{% endfor %}
{% endraw %}
```

Точно так же цикл, который прекращает обработку после 10-й итерации:

```python
{% raw %}
{% for user in users %}
    {%- if loop.index >= 10 %}{% break %}{% endif %}
{%- endfor %}
{% endraw %}
```

Обратите внимание, что `loop.index` начинается с `1`, а `loop.index0` начинается с `0` (см .: **For**).

### Оператор отладки (Debug Statement)

Если [расширение отладки](rasshireniya-jinja.md) включено, будет доступен тег `{% debug %}` для вывода текущего контекста, а также доступных фильтров и тестов. Это полезно, чтобы увидеть, что можно использовать в шаблоне, не настраивая отладчик.

```python
<pre>{% raw %}
{% debug %}
{% endraw %}</pre>
```

```python
{'context': {'cycler': <class 'jinja2.utils.Cycler'>,
             ...,
             'namespace': <class 'jinja2.utils.Namespace'>},
 'filters': ['abs', 'attr', 'batch', 'capitalize', 'center', 'count', 'd',
             ..., 'urlencode', 'urlize', 'wordcount', 'wordwrap', 'xmlattr'],
 'tests': ['!=', '<', '<=', '==', '>', '>=', 'callable', 'defined',
           ..., 'odd', 'sameas', 'sequence', 'string', 'undefined', 'upper']}
```

### Оператор With (With Statement)

_Новое в версии 2.3_.

Оператор _**with**_ позволяет создать новую внутреннюю область видимости. Переменные, установленные в этой области, не видны за пределами области.

В двух словах:

```python
{% raw %}
{% with %}
    {% set foo = 42 %}
    {{ foo }}           foo is 42 here
{% endwith %}
{% endraw %}
foo is not visible here any longer
```

Поскольку обычно переменные устанавливаются в начале области видимости, это можно сделать с помощью оператора _**with**_. Следующие два примера эквивалентны:

```python
{% raw %}
{% with foo = 42 %}
    {{ foo }}
{% endwith %}

{% with %}
    {% set foo = 42 %}
    {{ foo }}
{% endwith %}
{% endraw %}
```

Важное примечание об области охвата здесь. В версиях **Jinja** до 2.9 обращение одной переменной к другой имело непредвиденные последствия. В частности, одна переменная может ссылаться на другую, определенную в той же инструкции открытия блока. Это вызвало проблемы с поведением очищенной области действия и с тех пор было улучшено. В частности, в более новых версиях **Jinja** следующий код всегда обращается к переменной _**a**_ извне блока _**with**_:

```python
{% raw %}
{% with a={}, b=a.attribute %}...{% endwith %}
{% endraw %}
```

В более ранних версиях **Jinja** атрибут _**b**_ будет относиться к результатам первого атрибута. Если вы зависите от этого поведения, вы можете переписать его, чтобы использовать тег _**set**_:

```python
{% raw %}
{% with a={} %}
    {% set b = a.attribute %}
{% endwith %}
{% endraw %}
```

{% hint style="info" %}
**Расширение:**

В более старых версиях **Jinja** (до 2.9) требовалось включить эту функцию с помощью расширения. Теперь он включен по умолчанию.
{% endhint %}

## Переопределение автоэкранирования (Autoescape Overrides)

_Новое в версии 2.4_.

При желании вы можете активировать и деактивировать автоэкранирование из шаблонов.

Пример:

```python
{% raw %}
{% autoescape true %}
    Autoescaping is active within this block
{% endautoescape %}

{% autoescape false %}
    Autoescaping is inactive within this block
{% endautoescape %}
{% endraw %}
```

После _**endautoescape**_ поведение возвращается к тому, что было раньше.

{% hint style="info" %}
**Расширение:**

В более старых версиях **Jinja** (до 2.9) требовалось включить эту функцию с помощью расширения. Теперь он включен по умолчанию.
{% endhint %}
