# Песочница Jinja

Песочницу **Jinja** можно использовать для оценки ненадежного кода. Доступ к небезопасным атрибутам и методам запрещен.

Предполагая, что _**env**_ является **SandboxedEnvironment** в конфигурации по умолчанию, следующий фрагмент кода показывает, как это работает:

```python
>>> env.from_string("{{ func.func_code }}").render(func=lambda:None)
u''
>>> env.from_string("{{ func.func_code.do_something }}").render(func=lambda:None)
Traceback (most recent call last):
  ...
SecurityError: access to attribute 'func_code' of 'function' object is unsafe.
```

## Sandbox API

### класс sandbox.SandboxedEnvironment

#### &#x20;_class_ jinja2.sandbox.SandboxedEnvironment(\[_options_])

Изолированная среда. Работает как обычная среда, но сообщает компилятору о необходимости создания изолированного кода. Кроме того, подклассы этой среды могут переопределять методы, которые сообщают среде выполнения, какие атрибуты или функции безопасны для доступа.

Если шаблон пытается получить доступ к небезопасному коду, возникает ошибка **SecurityError**. Однако во время рендеринга могут возникать и другие исключения, поэтому вызывающий должен убедиться, что все исключения перехватываются.

#### Методы sandbox.SandboxedEnvironment

* &#x20;**call\_binop**(_context_, _operator_, _left_, _right_) - Для перехваченных вызовов бинарного оператора (_**intercepted\_binops ()**_) эта функция выполняется вместо встроенного оператора. Это можно использовать для точной настройки поведения определенных операторов. _Новое в версии 2.6_.
* &#x20;**call\_unop**(_context_, _operator_, _arg_) - Для перехваченных вызовов унарного оператора (_**intercepted\_unops ()**_) эта функция выполняется вместо встроенного оператора. Это можно использовать для точной настройки поведения определенных операторов. _Новое в версии 2.6_.

#### Атрибуты sandbox.SandboxedEnvironment

* &#x20;**default\_binop\_table** _= {'%': \<built-in function mod>, '\*': \<built-in function mul>, '\*\*': \<built-in function pow>, '+': \<built-in function add>, '-': \<built-in function sub>, '/': \<built-in function truediv>, '//': \<built-in function floordiv>} -_ таблица обратного вызова по умолчанию для бинарных операторов. Его копия доступна в каждом экземпляре изолированной среды как _**binop\_table**_.
* &#x20;**default\_unop\_table** _= {'+': \<built-in function pos>, '-': \<built-in function neg>} -_ таблица обратного вызова по умолчанию для унарных операторов. Его копия доступна в каждом экземпляре изолированной среды как _**unop\_table**_.
* &#x20;**intercepted\_binops** _= frozenset({}) -_ набор бинарных операторов, которые следует перехватить. Каждый оператор, добавляемый в этот набор (по умолчанию пустой), делегируется методу **call\_binop ()**, который будет выполнять этот оператор. Обратный вызов оператора по умолчанию указывается _**binop\_table**_. Перехватываются следующие бинарные операторы: `//`, `%`, `+`, `*`_, `-`, `/` и `**`._ Операция по умолчанию из таблицы операторов соответствует встроенной функции. Перехваченные вызовы всегда медленнее, чем вызов собственного оператора, поэтому убедитесь, что перехватываете только те, которые вам интересны. _Новое в версии 2.6_.
* &#x20;**intercepted\_unops** _= frozenset({}) -_ набор унарных операторов, которые следует перехватить. Каждый оператор, добавляемый в этот набор (по умолчанию пустой), делегируется методу **call\_unop ()**, который будет выполнять этот оператор. Обратный вызов оператора по умолчанию указывается _**unop\_table**_. Перехватываются следующие унарные операторы: `+`, `-`. Операция по умолчанию из таблицы операторов соответствует встроенной функции. Перехваченные вызовы всегда медленнее, чем вызов собственного оператора, поэтому убедитесь, что перехватываете только те, которые вам интересны. _Новое в версии 2.6_.
* &#x20;**is\_safe\_attribute**(_obj_, _attr_, _value_) - Изолированная среда вызовет этот метод, чтобы проверить, безопасен ли доступ к атрибуту объекта. По умолчанию все атрибуты, начинающиеся с символа подчеркивания, считаются частными, а также специальные атрибуты внутренних объектов Python, возвращаемые функцией **sandbox.is\_internal\_attribute ()**.
* &#x20;**is\_safe\_callable**(_obj_) - Проверяет, можно ли безопасно вызвать объект. По умолчанию функция считается безопасной, если атрибут _**unsafe\_callable**_ не существует и не имеет значения `True`. Переопределите этот метод, чтобы изменить поведение, но это не повлияет на декоратор _**unsafe**_ из этого модуля.

### класс sandbox.ImmutableSandboxedEnvironment

#### &#x20;_class_ jinja2.sandbox.ImmutableSandboxedEnvironment(\[_options_])

Работает точно так же, как обычная среда **SandboxedEnvironment**, но не позволяет вносить изменения во встроенный список изменяемых объектов, _**set**_ и _**dict**_ с помощью функции **sandbox.modify\_known\_mutable ()**.

### исключение sandbox.SecurityError

#### &#x20;_exception_ jinja2.sandbox.SecurityError(_message=None_)

Возникает, если шаблон пытается сделать что-то небезопасное, когда песочница включена.

### функция sandbox.unsafe()

#### &#x20;jinja2.sandbox.unsafe(_f_ )

Помечает функцию или метод как небезопасные.

```python
@unsafe
def delete(self):
    pass
```

### функция sandbox.is\_internal\_attribute()

#### &#x20;jinja2.sandbox.is\_internal\_attribute(_obj_, _attr_)

Проверяет, является ли указанный атрибут внутренним атрибутом Python. Например, эта функция возвращает `True` для атрибута _**func\_code**_ объектов Python. Это полезно, если метод среды **sandbox.SandboxedEnvironment.is\_safe\_attribute ()** переопределен.

```python
>>> from jinja2.sandbox import is_internal_attribute
>>> is_internal_attribute(str, "mro")
True
>>> is_internal_attribute(str, "upper")
False
```

### функция sandbox.modifies\_known\_mutable()

#### &#x20;jinja2.sandbox.modifies\_known\_mutable(_obj_, _attr_ )

Эта функция проверяет, изменит ли атрибут встроенного изменяемого объекта (_**list**_, _**dict**_, _**set**_ или _**deque**_) его при вызове. Он также поддерживает «пользовательские» версии объектов (`sets.Set`, `UserDict.*` и т. д.), А начиная с Python 2.6 - абстрактные базовые классы **MutableSet**, **MutableMapping** и **MutableSequence**.

```python
>>> modifies_known_mutable({}, "clear")
True
>>> modifies_known_mutable({}, "keys")
False
>>> modifies_known_mutable([], "append")
True
>>> modifies_known_mutable([], "index")
False
```

Если вызывается с неподдерживаемым объектом (например, **Unicode**), возвращается `False`.

```python
>>> modifies_known_mutable("foo", "upper")
False
```

{% hint style="info" %}
**Примечание:**

Сама по себе песочница **Jinja** не может обеспечить идеальную безопасность. Особенно для веб-приложений вы должны иметь в виду, что пользователи могут создавать шаблоны с произвольным HTML, поэтому крайне важно убедиться, что (если вы используете несколько пользователей на одном сервере), они не могли навредить друг другу с помощью вставок JavaScript и многого другого.

Также песочница хороша ровно настолько, насколько хороша конфигурация. Мы настоятельно рекомендуем передавать в шаблон только необщие ресурсы и использовать какие-то белые списки для атрибутов.

Также имейте в виду, что шаблоны могут вызывать ошибки времени выполнения или компиляции, поэтому обязательно их отловите.
{% endhint %}

## Оператор перехвата

_Новое в версии 2.6_.

Для максимальной производительности **Jinja** позволит операторам напрямую вызывать методы обратного вызова конкретного типа. Это означает, что это невозможно перехватить, переопределив **Environment.call ()**. Более того, преобразование из оператора в специальный метод не всегда возможно напрямую из-за того, как работают операторы. Например, для подразделений существует более одного специального метода.

В **Jinja** 2.6 теперь есть поддержка явного перехвата оператора. При необходимости это можно использовать для настройки конкретных операторов. Для перехвата оператора необходимо переопределить атрибут **SandboxedEnvironment.intercepted\_binops**. После добавления оператора, который необходимо перехватить, к этому набору **Jinja** сгенерирует байт-код, который вызывает функцию **SandboxedEnvironment.call\_binop ()**. Вместо унарных операторов следует использовать унарные атрибуты и методы.

Реализация по умолчанию **SandboxedEnvironment.call\_binop** будет использовать **SandboxedEnvironment.binop\_table** для преобразования символов операторов в обратные вызовы, выполняющие поведение оператора по умолчанию.

В этом примере показано, как в **Jinja** можно отключить оператор возведения в степень (`**`):

```python
from jinja2.sandbox import SandboxedEnvironment


class MyEnvironment(SandboxedEnvironment):
    intercepted_binops = frozenset(['**'])

    def call_binop(self, context, operator, left, right):
        if operator == '**':
            return self.undefined('the power operator is unavailable')
        return SandboxedEnvironment.call_binop(self, context,
                                               operator, left, right)
```

Обязательно всегда вызывайте супер-метод, даже если вы не перехватываете вызов. **Jinja** может внутренне вызывать метод для оценки выражений.
