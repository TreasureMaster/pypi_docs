# API Jinja

В этом документе описывается API для **Jinja**, а не язык шаблонов (см. [документацию по шаблонам](dokumentaciya-po-konstruktoru-shablonov.md)). Это будет наиболее полезно в качестве ссылки для тех, кто реализует интерфейс шаблона для приложения, а не для тех, кто создает шаблоны **Jinja**.

## Основы

**Jinja** использует центральный объект, называемый шаблоном **Environment**. Экземпляры этого класса используются для хранения конфигурации и глобальных объектов, а также для загрузки шаблонов из файловой системы или других мест. Даже если вы создаете шаблоны из строк с помощью конструктора класса **Template**, среда создается автоматически для вас, хотя и совместно используемая.

Большинство приложений создают один объект **Environment** при инициализации приложения и используют его для загрузки шаблонов. Однако в некоторых случаях полезно располагать несколько сред рядом, если используются разные конфигурации.

Самый простой способ настроить **Jinja** для загрузки шаблонов для вашего приложения выглядит примерно так:

```python
from jinja2 import Environment, PackageLoader, select_autoescape
env = Environment(
    loader=PackageLoader('yourapplication', 'templates'),
    autoescape=select_autoescape(['html', 'xml'])
)
```

Это создаст среду шаблонов с настройками по умолчанию и загрузчик, который будет искать шаблоны в папке шаблонов внутри пакета python _**yourapplication**_. Доступны разные загрузчики, и вы также можете написать свой собственный, если хотите загружать шаблоны из базы данных или других ресурсов. Это также позволяет автоматически экранировать файлы HTML и XML.

Чтобы загрузить шаблон из этой среды, вам просто нужно вызвать метод `get_template ()`, который затем возвращает загруженный шаблон **Template**:

```python
template = env.get_template('mytemplate.html')
```

Чтобы отобразить его с некоторыми переменными, просто вызовите метод `render ()`:

```python
print(template.render(the='variables', go='here'))
```

Использование загрузчика шаблонов вместо передачи строк в **Template** или `Environment.from_string ()` имеет несколько преимуществ. Помимо того, что он намного проще в использовании, он также позволяет наследование шаблонов.

{% hint style="info" %}
**Примечания по автоэкранированию:**

В будущих версиях **Jinja** мы можем включить автоматическое экранирование по умолчанию из соображений безопасности. Таким образом, вам рекомендуется явно настроить автоматическое экранирование, а не полагаться на значение по умолчанию.
{% endhint %}

## Unicode

**Jinja** внутренне использует Unicode, что означает, что вы должны передавать объекты Unicode в функцию рендеринга или строки байтов, которые состоят только из символов ASCII. Кроме того, новые строки нормализуются до конца строки, что соответствует стилю UNIX по умолчанию (`'\n'`).

Python 2.x поддерживает два способа представления строковых объектов. Один из них - это тип _**str**_, а другой - тип _**Unicode**_, оба из которых расширяют тип, называемый _**basestring**_. К сожалению, по умолчанию используется _**str**_, который не следует использовать для хранения текстовой информации, если не используются только символы ASCII. С Python 2.6 можно сделать _**Unicode**_ по умолчанию на уровне модуля, а с Python 3 он будет по умолчанию.

Чтобы явно использовать строку Unicode, вы должны поставить перед строковым литералом префикс _**u:**_ `u'Hänsel und Gretel sagen Hallo'`. Таким образом Python сохранит строку как Unicode, декодируя строку с кодировкой символов из текущего модуля Python. Если кодировка не указана, по умолчанию используется «ASCII», что означает, что вы не можете использовать любой идентификатор, отличный от ASCII.

Чтобы установить лучшую кодировку модуля, добавьте следующий комментарий к первой или второй строке модуля Python, используя литерал Unicode:

```python
# -*- coding: utf-8 -*-
```

Мы рекомендуем utf-8 в качестве кодировки для модулей и шаблонов Python, так как он может представлять каждый символ Unicode в utf-8 и потому что он обратно совместим с ASCII. Для **Jinja** предполагается, что кодировка шаблонов по умолчанию - utf-8.

**Jinja** невозможно использовать для обработки данных, отличных от Unicode. Причина этого в том, что **Jinja** использует Unicode уже на уровне языка. Например, **Jinja** рассматривает неразрывный пробел как допустимый пробел внутри выражений, что требует знания кодировки или работы со строкой Unicode.

Дополнительные сведения о Unicode в Python можно найти в отличной [документации по Unicode](https://docs.python.org/3/howto/unicode.html).

Еще одна важная вещь - это то, как **Jinja** обрабатывает строковые литералы в шаблонах. Наивная реализация будет использовать строки Unicode для всех строковых литералов, но в прошлом выяснилось, что это проблематично, поскольку некоторые библиотеки явно проверяют типы по _**str**_. Например, `datetime.strftime` не принимает аргументы Unicode. Чтобы не нарушить его полностью, **Jinja** возвращает _**str**_ для строк, которые соответствуют ASCII, а для всего остального - _**unicode:**_

```python
>>> m = Template(u"{% raw %}
{% set a, b = 'foo', 'föö' %}
{% endraw %}").module
>>> m.a
'foo'
>>> m.b
u'f\xf6\xf6'
```

## Высокоуровневый API

API высокого уровня - это API, который вы будете использовать в приложении для загрузки и рендеринга шаблонов **Jinja**. Низкоуровневый API с другой стороны полезен только в том случае, если вы хотите глубже изучить **Jinja** или разработать [расширения](rasshireniya-jinja.md).

### класс Enviroment

#### &#x20;_class_ jinja2.Environment( \[_options_ ] )

Основной компонент **Jinja** - это **Enviroment**. Он содержит важные общие переменные, такие как конфигурация, фильтры, тесты, глобальные переменные и другие. Экземпляры этого класса могут быть изменены, если они не являются общими и пока не был загружен ни один шаблон. Изменения в средах после загрузки первого шаблона приведут к неожиданным эффектам и неопределенному поведению.

#### Вот возможные параметры инициализации:

* _**block\_start\_string**_ - Строка, обозначающая начало блока. По умолчанию `"{%"`.
* _**block\_end\_string**_ - Строка, обозначающая конец блока. По умолчанию `"%}"`.
* _**variable\_start\_string**_ - Строка, обозначающая начало оператора печати. По умолчанию `'{{'`.
* _**variable\_end\_string**_ - Строка, обозначающая конец оператора печати. По умолчанию `'}}'`.
* _**comment\_start\_string**_ - Строка, обозначающая начало комментария. По умолчанию `'{#'`.
* _**comment\_end\_string**_ - Строка, обозначающая конец комментария. По умолчанию `'#}'`.
* _**line\_statement\_prefix**_ - Если задано и является строкой, это будет использоваться как префикс для строковых операторов. См. также [операторы строки](dokumentaciya-po-konstruktoru-shablonov.md).
* _**line\_comment\_prefix**_ - Если задано и является строкой, это будет использоваться как префикс для строковых операторов. См. также [операторы строки](dokumentaciya-po-konstruktoru-shablonov.md). _Новое в версии 2.2._
* _**trim\_blocks** -_ Если для него установлено значение `True`, первая новая строка после удаления блока (блока, а не тега переменной!). По умолчанию `False`.
* _**lstrip\_blocks**_ - Если для этого параметра установлено значение `True`, начальные пробелы и табуляция удаляются от начала строки до блока. По умолчанию `False`.
* _**newline\_sequence**_ - Последовательность, с которой начинается новая строка. Должен быть одним из `'\r'`, `'\n'` или `'\r\n'`. По умолчанию используется `'\n'`, что полезно по умолчанию для систем Linux и OS X, а также для веб-приложений.
* _**keep\_trailing\_newline**_ - Сохраняет завершающую новую строку при рендеринге шаблонов. Значение по умолчанию - `False`, что приводит к удалению одной новой строки, если она есть, из конца шаблона. _Новое в версии 2.7_.
* _**extensions**_ - Список используемых расширений **Jinja**. Это могут быть либо пути импорта в виде строк, либо классы расширения. Для получения дополнительной информации см. [документацию по расширениям](rasshireniya-jinja.md).
* _**optimized**_ - должен быть включен оптимизатор? По умолчанию `True`.
* _**undefined**_ - **Undefined** или его подкласс, который используется для представления неопределенных значений в шаблоне.
* _**finalize**_ - Вызываемый объект, который можно использовать для обработки результата выражения переменной перед его выводом. Например, здесь можно неявно преобразовать `None` в пустую строку.
* _**autoescape**_ - Если установлено значение `True`, функция автоматического экранирования XML/HTML включена по умолчанию. Дополнительные сведения об автоэкранировании см. **Markup**. Начиная с **Jinja** 2.4, это также может быть вызываемый объект, которому передается имя шаблона и который должен возвращать `True` или `False` в зависимости от того, что _**autoescape**_ должен быть включен по умолчанию. _Изменено в версии 2.4:_ теперь _**autoescape**_ может быть функцией.
* _**loader**_ - Загрузчик шаблонов для этой среды.
* _**cache\_size**_ - Размер кеша. По умолчанию это `400`, что означает, что если загружено более 400 шаблонов, загрузчик очистит последний использованный шаблон. Если для размера кэша установлено значение `0`, шаблоны все время перекомпилируются, если размер кэша равен `-1`, кэш не будет очищаться. _Изменено в версии 2.8:_ размер кеш-памяти был увеличен с 50 до 400.
* _**auto\_reload**_ - Некоторые загрузчики загружают шаблоны из мест, где источники шаблонов могут изменяться (например, файловая система или база данных). Если _**auto\_reload**_ имеет значение `True` (по умолчанию) каждый раз, когда запрашивается шаблон, загрузчик проверяет, изменился ли источник, и если да, он перезагружает шаблон. Для большей производительности это можно отключить.
* _**bytecode\_cache**_ - Если установлен объект кэша байт-кода, этот объект будет обеспечивать кеш для внутреннего байт-кода **Jinja**, так что шаблоны не нужно анализировать, если они не были изменены. См. **Bytecode Cache** для получения дополнительной информации.
* _**enable\_async**_ - Если установлено значение `True`, это разрешает выполнение асинхронного шаблона, что позволяет использовать преимущества новых функций Python. Для этого требуется Python 3.6 или новее.

#### Атрибуты класса Enviroment

* _**shared**_ - Если шаблон был создан с помощью конструктора **Template**, среда создается автоматически. Эти среды создаются как общие среды, что означает, что несколько шаблонов могут иметь одну и ту же анонимную среду. Для всех общих сред этот атрибут имеет значение `True`, в противном случае - `False`.
* _**sandboxed**_ - Если среда изолирована, этот атрибут имеет значение `True`. Для режима песочницы ознакомьтесь с документацией к [SandboxedEnvironment](pesochnica-jinja.md).
* _**filters**_ - Словарь фильтров для этой среды. Пока не загружен шаблон, можно безопасно добавлять новые фильтры или удалять старые. Для пользовательских фильтров см. **Пользовательские фильтры**. Допустимые имена фильтров см. в **Примечаниях к идентификаторам**.
* _**tests**_ - Набор тестовых функций для этой среды. Пока не загружен шаблон, можно безопасно изменять этот словарь. Для пользовательских тестов см. **Пользовательские тесты**. Чтобы узнать допустимые имена тестов, см. **Примечания к идентификаторам**.
* _**globals**_ - Словарь глобальных переменных. Эти переменные всегда доступны в шаблоне. Пока не загружен шаблон, можно безопасно изменять этот словарь. Для получения дополнительной информации см. **Глобальное пространство имен**. Чтобы узнать о допустимых именах объектов, см. **Примечания к идентификаторам**.
* _**policies**_ - Словарь с политиками. Их можно перенастроить, чтобы изменить поведение среды выполнения или определенные функции шаблона. Обычно это связано с безопасностью.
* _**code\_generator\_class**_ - Класс, используемый для генерации кода. В большинстве случаев это не следует менять, если только вам не нужно изменять код Python, в который компилируется шаблон.
* _**context\_class**_ - Контекст, используемый для шаблонов. В большинстве случаев это не следует изменять, если только вам не нужно изменять внутренние механизмы обработки переменных шаблона. Подробнее см. **Context**.

#### Методы класса Enviroment

* &#x20;_**overlay**_(\[ _options_ ]) - Создает новую среду наложения, которая разделяет все данные с текущей средой, кроме кеша и переопределенных атрибутов. Расширения нельзя удалить для наложенной среды. Наложенная среда автоматически получает все расширения среды, с которой она связана, а также дополнительные дополнительные расширения. Создание наложений должно происходить после того, как исходная среда была полностью настроена. Не все атрибуты действительно связаны, некоторые просто копируются, поэтому изменения в исходной среде могут не проявиться.
* &#x20;_**undefined**_(\[ _hint_, _obj_, _name_, _exc_ ]) - Создает новый объект **Undefined** для имени _**name**_. Это полезно для фильтров или функций, которые могут возвращать неопределенные объекты для некоторых операций. Все параметры, кроме подсказки _**hint**_, должны быть предоставлены как параметры ключевого слова для лучшей читаемости. Подсказка _**hint**_ используется как сообщение об ошибке для исключения, если оно предоставлено, в противном случае сообщение об ошибке будет автоматически сгенерировано из объекта _**obj**_ и имени _**name**_. Исключение, представленное как _**exc**_, возникает, если со сгенерированным неопределенным объектом делается что-то, что не позволяет использовать неопределенный объект. Исключение по умолчанию - **UndefinedError**. Если дана подсказка _**hint**_, имя _**name**_ можно не указывать. Самый распространенный способ создать неопределенный объект - указать только имя:

```python
return environment.undefined(name='some_name')
```

Это означает, что имя _**some\_name**_ не определено. Если имя было из атрибута объекта, имеет смысл сообщить неопределенному объекту объект-держатель, чтобы улучшить сообщение об ошибке:

```python
if not hasattr(obj, 'attr'):
    return environment.undefined(obj=obj, name='attr')
```

Для более сложного примера вы можете дать подсказку. Например, фильтр `first ()` таким образом создает неопределенный объект:

```python
return environment.undefined('no first item, sequence was empty')
```

Если имя _**name**_ или объект _**obj**_ известны (например, из-за доступа к атрибуту), его следует передать неопределенному объекту, даже если предоставлена настраиваемая подсказка _**hint**_. Это дает неопределенным объектам возможность улучшить сообщение об ошибке.

* &#x20;**add\_extension**(_extension_ ) - Добавляет расширение после создания среды. _Новое в версии 2.5_.
* &#x20;**compile\_expression**(_source_, _undefined\_to\_none=True_) - Удобный вспомогательный метод, который возвращает вызываемый объект, который принимает аргументы ключевого слова, которые появляются как переменные в выражении. При вызове возвращает результат выражения. Это полезно, если приложения хотят использовать те же правила, что и **Jinja**, в «файлах конфигурации» шаблонов или подобных ситуациях. Пример использования:

```python
>>> env = Environment()
>>> expr = env.compile_expression('foo == 42')
>>> expr(foo=23)
False
>>> expr(foo=42)
True
```

По умолчанию возвращаемое значение преобразуется в `None`, если выражение возвращает неопределенное значение. Это можно изменить, установив _**undefined\_to\_none**_ в `False`.

```python
>>> env.compile_expression('var')() is None
True
>>> env.compile_expression('var', undefined_to_none=False)()
Undefined
```

_Новое в версии 2.1_.

* &#x20;**compile\_templates**(_target_, _extensions=None_, _filter\_func=None_, _zip='deflated'_, _log\_function=None_, _ignore\_errors=True_, _py\_compile=False_) - Находит все шаблоны, которые может найти загрузчик, компилирует их и сохраняет в _**target**_. Если _**zip**_ равен `None`, то шаблоны будут храниться в каталоге, а не в zip-файле. По умолчанию используется алгоритм `'deflate'` _**zip**_. Чтобы переключиться на сохраненный алгоритм, можно установить _**zip**_ на `'stored'`. _**extension**_ и _**filter\_func**_ передаются в `list_templates ()`. Каждый возвращенный шаблон будет скомпилирован в целевую папку или zip-файл. По умолчанию ошибки компиляции шаблона игнорируются. Если предусмотрена функция журнала, регистрируются ошибки. Если вы хотите, чтобы синтаксические ошибки шаблона прервали компиляцию, вы можете установить для _**ignore\_errors**_ значение `False`, и вы получите исключение при синтаксических ошибках. Если для _**py\_compile**_ установлено значение `True`, в целевой объект будут записываться файлы `.pyc` вместо стандартных файлов `.py`. Этот флаг ничего не делает в pypy и Python 3, где файлы `pyc` не собираются сами по себе и не дают большой пользы. _Новое в версии 2.4_.
* &#x20;**extend**(_\*\*attributes_) - Добавьте элементы в экземпляр среды, если они еще не существуют. Это используется [расширениями](rasshireniya-jinja.md) для регистрации обратных вызовов и значений конфигурации без нарушения наследования.
* &#x20;**from\_string**(_source_, _globals=None_, _template\_class=None_) - Загружает шаблон из строки. Анализирует данный источник и возвращает объект **Template**.
* &#x20;**get\_or\_select\_template**(_template\_name\_or\_list_, _parent=None_, _globals=None_) - Выполняет проверку типа и отправляет в `select_template ()`, если задано итеративное имя шаблона, в противном случае - в `get_template ()`. _Новое в версии 2.3_.
* &#x20;**get\_template**(_name_, _parent=None_, _globals=None_) - Загружает шаблон из загрузчика. Если загрузчик настроен, этот метод запрашивает у загрузчика шаблон и возвращает **Template**. Если родительский параметр не равен `None`, вызывается `join_path ()` для получения настоящего имени шаблона перед загрузкой. Параметр _**globals**_ можно использовать для предоставления глобальных объектов шаблона. Эти переменные доступны в контексте во время рендеринга. Если шаблон не существует, возникает исключение **TemplateNotFound**. _Изменено в версии 2.4:_ если имя _**name**_ является объектом шаблона, оно возвращается из функции без изменений.
* &#x20;**join\_path**(_template_, _parent_ ) - Присоединяет шаблону к родителю. По умолчанию все поиски выполняются относительно корня загрузчика, поэтому этот метод возвращает параметр _**template**_ без изменений, но если пути должны быть относительно родительского шаблона, эту функцию можно использовать для вычисления реального имени шаблона. Подклассы могут переопределить этот метод и реализовать здесь соединение пути к шаблону.
* &#x20;**list\_templates**(_extensions=None_, _filter\_func=None_) - Возвращает список шаблонов для этой среды. Для этого необходимо, чтобы загрузчик поддерживал метод загрузчика `list_templates ()`. Если в папке шаблона есть другие файлы, помимо фактических шаблонов, возвращенный список можно отфильтровать. Есть два способа: либо для расширений _**extensions**_ задается список расширений файлов для шаблонов, либо может быть предоставлен _**filter\_func**_, который является вызываемым, которому передается имя шаблона и который должен возвращать `True`, если он должен оказаться в списке результатов. Если загрузчик не поддерживает это, возникает ошибка **TypeError**. _Новое в версии 2.4_.
* &#x20;**select\_template**(_names_, _parent=None_, _globals=None_) - Работает как `get_template ()`, но пробует несколько шаблонов, прежде чем потерпит неудачу. Если он не может найти ни один из шаблонов, он вызовет исключение **TemplatesNotFound**. _Изменено в версии 2.11_: если для _**names**_ установлено значение **Undefined**, вместо этого возникает **UndefinedError**. Если шаблоны не найдены, а в именах указано **Undefined**, сообщение будет более полезным. _Изменено в версии 2.4:_ если имена содержат объект **Template**, он возвращается из функции без изменений. _Новое в версии 2.3_.

### класс Template

#### &#x20;_class_ jinja2.Template

Центральный объект шаблона. Этот класс представляет собой скомпилированный шаблон и используется для его оценки. Обычно объект шаблона создается из **Environment**, но у него также есть конструктор, который позволяет создать экземпляр шаблона напрямую с помощью конструктора. Он принимает те же аргументы, что и конструктор среды **Environment**, но невозможно указать загрузчик _**loader**_. Каждый объект шаблона имеет несколько методов и членов, которые гарантированно существуют. Однако важно, чтобы объект шаблона считался неизменным. Модификации объекта не поддерживаются. Объекты шаблонов, созданные из конструктора, а не из среды **Environment**, имеют атрибут среды, указывающий на временную среду, которая, вероятно, используется совместно с другими шаблонами, созданными с помощью конструктора и совместимых настроек.

```python
>>> template = Template('Hello {{ name }}!')
>>> template.render(name='John Doe') == u'Hello John Doe!'
True
>>> stream = template.stream(name='John Doe')
>>> next(stream) == u'Hello John Doe!'
True
>>> next(stream)
Traceback (most recent call last):
    ...
StopIteration
```

#### Атрибуты класса Template

* _**globals**_ - Словарь с глобальными объектами этого шаблона. Изменять этот словарь небезопасно, поскольку он может использоваться другими шаблонами или средой, в которой был загружен шаблон.
* _**name**_ - Имя загрузки шаблона. Если шаблон был загружен из строки, это `None`.
* _**filename**_ - Имя файла шаблона в файловой системе, если он был загружен оттуда. В противном случае это `None`.

#### Методы класса Template

* &#x20;**render**( \[ _context_ ] ) - Этот метод принимает те же аргументы, что и словарь конструктора: сам словарь, словарь подкласса или некоторые аргументы ключевого слова. Если аргументы не указаны, контекст будет пустым. Эти два вызова делают то же самое:

```python
template.render(knights='that say nih')
template.render({'knights': 'that say nih'})
```

Это вернет визуализированный шаблон в виде строки Unicode.

* &#x20;**generate**(\[ _context_ ]) - Для очень больших шаблонов может быть полезно не отображать весь шаблон сразу, а оценивать каждый оператор за другим и уступать часть за частью. Этот метод в основном делает именно это и возвращает генератор, который выдает один элемент за другим в виде строк Unicode. Он принимает те же аргументы, что и `render ()`.
* &#x20;**stream**(\[ _context_ ]) - Работает точно так же, как `generate ()`, но возвращает **TemplateStream**.
* &#x20;**render\_async**(\[ _context_ ]) - Это работает аналогично `render ()`, но возвращает сопрограмму, которая при ожидании возвращает всю визуализированную строку шаблона. Для этого требуется, чтобы была включена функция асинхронности. Пример использования:

```python
await template.render_async(knights='that say nih; asynchronously')
```

* &#x20;**generate\_async**(\[ _context_ ]) - Асинхронная версия `generate ()`. Работает очень аналогично, но вместо этого возвращает асинхронный итератор.
* &#x20;**make\_module**(_vars=None_, _shared=False_, _locals=None_) - Этот метод работает как атрибут модуля _**module**_ при вызове без аргументов, но он будет оценивать шаблон при каждом вызове, а не кэшировать его. Также возможно предоставить _**dict**_, который затем будет использоваться в качестве контекста. Аргументы такие же, как и для метода `new_context ()`.

#### Свойство класса Template

* &#x20;_property_ **module -** Шаблон как модуль. Это используется для импорта во время выполнения шаблона, но также полезно, если кто-то хочет получить доступ к экспортированным переменным шаблона из уровня Python:

```python
>>> t = Template('{% raw %}
{% macro foo() %}42{% endmacro %}
{% endraw %}23')
>>> str(t.module)
'23'
>>> t.module.foo() == u'42'
True
```

Этот атрибут недоступен, если включен асинхронный режим.

### класс TemplateStream

#### &#x20;_class_ jinja2.environment.TemplateStream

Шаблонный поток работает почти так же, как обычный генератор Python, но может буферизовать несколько элементов, чтобы уменьшить общее количество итераций. По умолчанию вывод небуферизован, что означает, что для каждой небуферизованной инструкции в шаблоне выдается одна строка Unicode. Если буферизация включена с размером буфера 5, пять элементов объединяются в новую строку Unicode. Это в основном полезно, если вы передаете клиенту большие шаблоны через WSGI, который очищается после каждой итерации.

#### Методы TemplateStream

* &#x20;**disable\_buffering**() - Отключает буферизацию вывода.
* &#x20;**dump**(_fp_, _encoding=None_, _errors='strict'_) - Выгружает полный поток в файл или файловый объект. По умолчанию записываются строки Unicode, если вы хотите кодировать перед записью, укажите кодировку _**encoding**_. Пример использования:

```python
Template('Hello {{ name }}!').stream(name='foo').dump('hello.html')
```

* &#x20;**enable\_buffering**(_size=5_ ) - Включить буферизацию. Предметы буферного размера _**size**_ перед тем, как отдать их.

## Автоэкранирование (Autoescaping)

_Изменено в версии 2.4_.

**Jinja** теперь поддерживает экранирование **autoescape**. Начиная с **Jinja** 2.9, расширение **autoescape** удалено и встроено. Однако автоматическое экранирование по умолчанию еще не включено, хотя, скорее всего, это изменится в будущем. Рекомендуется настроить разумное значение по умолчанию для автоматического экранирования. Это позволяет включать и отключать автоматическое экранирование для каждого шаблона (например, HTML вместо текста).

### функция select\_autoescape()

* **jinja2.select\_autoescape**(_enabled\_extensions=('html'_, _'htm'_, _'xml')_, _disabled\_extensions=()_, _default\_for\_string=True_, _default=False_) - Интеллектуально устанавливает начальное значение автоэкранирования на основе имени файла шаблона. Это рекомендуемый способ настройки автоматического экранирования, если вы не хотите самостоятельно писать настраиваемую функцию. Если вы хотите включить его для всех шаблонов, созданных из строк, или для всех шаблонов с расширениями `.html` и `.xml`:

```python
from jinja2 import Environment, select_autoescape
env = Environment(autoescape=select_autoescape(
    enabled_extensions=('html', 'xml'),
    default_for_string=True,
))
```

Пример конфигурации для постоянного включения, кроме случаев, когда шаблон заканчивается на `.txt`:

```python
from jinja2 import Environment, select_autoescape
env = Environment(autoescape=select_autoescape(
    disabled_extensions=('txt',),
    default_for_string=True,
    default=True,
))
```

_**enabled\_extensions**_ - это итерация всех расширений, для которых должно быть включено автоматическое экранирование. Аналогично _**disabled\_extensions**_ - это список всех шаблонов, для которых он должен быть отключен. Если шаблон загружается из строки, то используется значение по умолчанию из _**default\_for\_string**_. Если ничего не совпадает, тогда начальное значение автоэкранирования устанавливается на значение по умолчанию _**default**_.

По соображениям безопасности эта функция работает без учета регистра. _Новое в версии 2.9_.

Вот рекомендуемая настройка, которая включает автоматическое экранирование для шаблонов, заканчивающихся на `'.html'`, `'.htm'` и `'.xml'`, и отключение его по умолчанию для всех других расширений. Для этого вы можете использовать функцию `select_autoescape ()`:

```python
from jinja2 import Environment, PackageLoader, select_autoescape
env = Environment(autoescape=select_autoescape(['html', 'htm', 'xml']),
                  loader=PackageLoader('mypackage'))
```

Функция `select_autoescape ()` возвращает функцию, которая работает примерно так:

```python
def autoescape(template_name):
    if template_name is None:
        return False
    if template_name.endswith(('.html', '.htm', '.xml'))
```

При реализации функции _**autoescape**_ с предположением убедитесь, что вы также принимаете `None` в качестве допустимого имени шаблона. Это будет передано при создании шаблонов из строк. Вы всегда должны настраивать автоматическое экранирование, поскольку в будущем значения по умолчанию могут измениться.

Внутри шаблонов поведение можно временно изменить с помощью блока _**autoescape**_ (см. [Autoescape Overrides](dokumentaciya-po-konstruktoru-shablonov.md)).

## Примечания к идентификаторам

**Jinja** использует правила именования Python. Допустимые идентификаторы могут быть любой комбинацией символов Юникода, принятой Python.

Фильтры и тесты ищутся в отдельных пространствах имен и имеют слегка измененный синтаксис идентификатора. Фильтры и тесты могут содержать точки для группировки фильтров и тестов по темам. Например, вполне допустимо добавить функцию в фильтр _**dict**_ и вызвать ее `to.unicode`. Регулярное выражение для идентификаторов фильтров и тестов: `` [a-zA-Z ][a-zA-Z0-9 ]*(\.[A-zA-Z_][a-zA-Z0-9_]*)*` ``.

## Типы Undefined

Эти классы могут использоваться как неопределенные типы. Конструктор **Environment** принимает параметр _**undefined**_, который может быть одним из этих классов или настраиваемым подклассом **Undefined**. Каждый раз, когда механизм шаблонов не может найти имя или получить доступ к атрибуту, создается и возвращается один из этих объектов. После этого разрешаются некоторые операции с неопределенными значениями, другие не работают.

Наиболее близким к обычному поведению Python является **StrictUndefined**, который запрещает все операции, кроме тестирования, если это неопределенный объект.

### класс Undefined

#### &#x20;_class_ jinja2.Undefined

Неопределенный тип по умолчанию. Этот неопределенный тип можно распечатать и повторить, но любой другой доступ вызовет **UndefinedError**:

```python
>>> foo = Undefined(name='foo')
>>> str(foo)
''
>>> not foo
True
>>> foo + 42
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
```

#### Атрибуты класса Undefined

* &#x20;**\_undefined\_hint -** Либо `None`, либо строка в Юникоде с сообщением об ошибке для неопределенного объекта.
* &#x20;**\_undefined\_obj -** Либо `None`, либо объект-владелец, который вызвал создание неопределенного объекта (например, из-за того, что атрибут не существует).
* &#x20;**\_undefined\_name -** Имя неопределенной переменной/атрибута или просто `None`, если такой информации нет.
* &#x20;**\_undefined\_exception -** Исключение, которое хочет вызвать неопределенный объект. Обычно это одна из **UndefinedError** или **SecurityError**.

#### Методы класса Undefined

* &#x20;**\_fail\_with\_undefined\_error**(_\*args_, _\*\*kwargs_) - При вызове с любыми аргументами этот метод вызывает _**\_undefined\_exception**_ с сообщением об ошибке, сгенерированным из неопределенных подсказок, хранящихся в неопределенном объекте.

### класс ChainableUndefined

#### &#x20;_class_ jinja2.ChainableUndefined

Неопределенный, который объединяется в цепочку, где оба `__getattr__` и `__getitem__` возвращают себя, а не вызывают **UndefinedError**.

```python
>>> foo = ChainableUndefined(name='foo')
>>> str(foo.bar['baz'])
''
>>> foo.bar['baz'] + 42
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
```

_Новое в версии 2.11.0_.

### класс DebugUndefined

#### &#x20;_class_ jinja2.DebugUndefined

Не определено, которое возвращает отладочную информацию при печати.

```python
>>> foo = DebugUndefined(name='foo')
>>> str(foo)
'{{ foo }}'
>>> not foo
True
>>> foo + 42
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
```

### класс StrictUndefined

#### &#x20;_class_ jinja2.StrictUndefined

Неопределенный, который "ругается" на печать и итерацию, а также на логические тесты и всевозможные сравнения. Другими словами: вы ничего не можете с ним сделать, кроме как проверить, определено ли оно с помощью определенного теста _**defined**_.

```python
>>> foo = StrictUndefined(name='foo')
>>> str(foo)
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
>>> not foo
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
>>> foo + 42
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
```

Существует также фабричная функция, которая может украшать неопределенные объекты для реализации регистрации сбоев:

### &#x20;функция make\_logging\_undefined()

#### &#x20;jinja2.make\_logging\_undefined(_logger=None_, _base=None_)

Учитывая объект регистратора, она возвращает новый неопределенный класс, который будет регистрировать определенные сбои. Она будет регистрировать итерации и печать. Если регистратор не задан, создается регистратор по умолчанию. Пример:

```python
logger = logging.getLogger(__name__)
LoggingUndefined = make_logging_undefined(
    logger=logger,
    base=Undefined
)
```

_Новое в версии 2.8_.

#### Параметры функции make\_logging\_undefined():

* _**logger**_ - регистратор для использования. Если не указан, создается регистратор по умолчанию.
* _**base**_ - базовый класс, в который нужно добавить функцию ведения журнала. По умолчанию это **Undefined**.

Неопределенные объекты создаются путем вызова [_**undefined**_](dokumentaciya-po-konstruktoru-shablonov.md).

{% hint style="info" %}
**Реализация:**

Неопределенные объекты **Undefined** реализуются путем переопределения специальных методов _**\_\_underscore\_\_**_. Например, класс **Undefined** по умолчанию реализует _**\_\_unicode\_\_**_ таким образом, что он возвращает пустую строку, однако _**\_\_int\_\_**_ и другие по-прежнему терпят неудачу с исключением. Чтобы разрешить преобразование в _**int**_ путем возврата `0`, вы можете реализовать свое собственное:

```python
class NullUndefined(Undefined):
    def __int__(self):
        return 0
    def __float__(self):
        return 0.0
```

Чтобы запретить метод, просто переопределите его и вызовите _**\_undefined\_exception**_. Поскольку это очень распространенная идиома в неопределенных объектах, существует вспомогательный метод _**\_fail\_with\_undefined\_error ()**_, который автоматически вызывает ошибку. Вот класс, который работает как обычный **Undefined**, но задыхается при итерации:

```python
class NonIterableUndefined(Undefined):
    __iter__ = Undefined._fail_with_undefined_error
```
{% endhint %}

## Контекст

### класс runtime.Context

#### &#x20;_class_ jinja2.runtime.Context

Контекст шаблона содержит переменные шаблона. В нем хранятся значения, переданные в шаблон, а также имена, которые экспортирует шаблон. Создание экземпляров не поддерживается и не является полезным, поскольку оно создается автоматически на различных этапах оценки шаблона и не должно создаваться вручную.

Контекст неизменен. Изменения в родительском элементе _**parent**_ не должны происходить, а изменения в переменных _**vars**_ разрешены только из сгенерированного кода шаблона. Фильтры шаблонов и глобальные функции, отмеченные как `contextfunction ()` , получают активный контекст, переданный в качестве первого аргумента, и им разрешается доступ к контексту только для чтения.

Контекст шаблона поддерживает операции со словарем только для чтения (_**get**_, _**keys**_, _**values**_, _**items**_, _**iterkeys**_, _**itervalues**_, _**iteritems**_, _**\_\_getitem\_\_**_, _**\_\_contains\_\_**_). Кроме того, существует метод _**resolve ()**_, который не вызывает ошибку **KeyError**, но возвращает объект **Undefined** для отсутствующих переменных.

#### Атрибуты runtime.Context

* _**parent**_ - Словарь только для чтения, глобальные переменные, которые ищет шаблон. Они могут поступать из другого контекста, из **Environment.globals** или **Template.globals**, или указывать на словарь, созданный путем объединения глобальных переменных с переменными, переданными в функцию рендеринга. Его нельзя изменять.
* _**vars**_ - Локальные переменные шаблона. Этот список содержит функции среды и контекста из родительской области _**parent**_, а также локальные модификации и экспортированные переменные из шаблона. Шаблон изменит этот словарь во время оценки шаблона, но фильтры и контекстные функции не могут его изменять.
* _**environment**_ - Среда, в которую загружен шаблон.
* _**exported\_vars**_ - Этот набор содержит все имена, которые экспортирует шаблон. Значения имен указаны в словаре _**vars**_. Чтобы получить копию экспортированных переменных как словарь, можно использовать _**get\_exported ()**_.
* _**name**_ - Имя загрузки шаблона, владеющего этим контекстом.
* _**blocks**_ - Словарь с текущим отображением блоков в шаблоне. Ключи в этом слове - это имена блоков, а значения - список зарегистрированных блоков. Последний элемент в каждом списке - это текущий активный блок (последний в цепочке наследования).
* _**eval\_ctx**_ - Текущий контекст оценки (**Evaluation Context**).

#### Методы runtime.Context

* &#x20;**call**(_callable_, _\*args_, _\*\*kwargs_) - Вызывает вызываемый объект с предоставленными аргументами и ключевыми словами, но вставляет активный контекст или среду в качестве первого аргумента, если вызываемый объект является _**contextfunction ()**_ или _**environmentfunction ()**_.
* &#x20;**get\_all**() - Возвращает полный контекст как словарь, включая экспортированные переменные. По причинам оптимизации может не вернуть реальную копию, поэтому будьте осторожны с ее использованием.
* &#x20;**get\_exported**() - Возвращает новый словарь с экспортированными переменными.
* &#x20;**resolve**(_key_) - Ищет переменную, такую как _**\_\_getitem\_\_**_ или _**get**_, но возвращает объект **Undefined** с именем искомого имени.

{% hint style="info" %}
**Реализация:**

Контекст неизменен по той же причине, по которой локальные переменные фрейма Python неизменны внутри функций. И **Jinja**, и Python не используют локальные переменные контекста/фрейма в качестве хранилища данных для переменных, а только в качестве основного источника данных.

Когда шаблон обращается к переменной, которую шаблон не определяет, **Jinja** ищет переменную в контексте, после чего переменная обрабатывается так, как если бы она была определена в шаблоне.
{% endhint %}

## Загрузчики (Loaders)

Загрузчики отвечают за загрузку шаблонов из такого ресурса, как файловая система. Среда будет хранить скомпилированные модули в памяти, например `sys.modules` Python. Однако, в отличие от `sys.modules`, размер этого кеша по умолчанию ограничен, а шаблоны автоматически перезагружаются. Все загрузчики являются подклассами **BaseLoader**. Если вы хотите создать свой собственный загрузчик, создайте подкласс **BaseLoader** и переопределите _**get\_source**_.

### класс BaseLoader

#### &#x20;_class_ jinja2.BaseLoader

Базовый класс для всех загрузчиков. Создайте подкласс этого и переопределите _**get\_source**_, чтобы реализовать собственный механизм загрузки. Среда предоставляет метод _**get\_template**_, который вызывает метод _**load**_ загрузчика для получения объекта **Template**.

Самый простой пример загрузчика, который ищет шаблоны в файловой системе, может выглядеть так:

```python
from jinja2 import BaseLoader, TemplateNotFound
from os.path import join, exists, getmtime

class MyLoader(BaseLoader):

    def __init__(self, path):
        self.path = path

    def get_source(self, environment, template):
        path = join(self.path, template)
        if not exists(path):
            raise TemplateNotFound(template)
        mtime = getmtime(path)
        with file(path) as f:
            source = f.read().decode('utf-8')
        return source, path, lambda: mtime == getmtime(path)
```

#### Методы BaseLoader

* &#x20;**get\_source**(_environment_, _template_) - Получите источник шаблона, имя файла и перезагрузите помощник для шаблона. Передает имя среды и шаблона и возвращает кортеж в форме `(source, filename, uptodate)` или вызывает ошибку **TemplateNotFound**, если не может найти шаблон. Исходная часть _**source**_ возвращаемого кортежа должна быть источником шаблона в виде строки Unicode или байтовой строки ASCII. Имя файла _**filename**_ должно быть именем файла в файловой системе, если он был загружен оттуда, в противном случае - `None`. Имя файла _**filename**_ используется Python для трассировки, если не используется расширение загрузчика. Последний элемент в кортеже - это функция обновления _**uptodate**_. Если автоматическая перезагрузка включена, она всегда вызывается, чтобы проверить, не изменился ли шаблон. Аргументы не передаются, поэтому функция должна где-то хранить старое состояние (например, в закрытии). Если она вернет `False`, шаблон будет перезагружен.
* &#x20;**load**(_environment_, _name_, _globals=None_) - Загружает шаблон. Этот метод ищет шаблон в кеше или загружает его, вызывая _**get\_source ()**_. Подклассы не должны переопределять этот метод, поскольку загрузчики, работающие с коллекциями других загрузчиков (например, **PrefixLoader** или **ChoiceLoader**), не будут вызывать этот метод, а напрямую _**get\_source**_.

Вот список встроенных загрузчиков, которые предоставляет **Jinja**:

### класс FileSystemLoader

#### &#x20;_class_ **jinja2.FileSystemLoader**(_searchpath_, _encoding='utf-8'_, _followlinks=False_)

Загружает шаблоны из файловой системы. Этот загрузчик может находить шаблоны в папках файловой системы и является предпочтительным способом их загрузки.

Загрузчик принимает путь к шаблонам в виде строки или, если требуется несколько мест, их список, который затем просматривается в заданном порядке:

```python
>>> loader = FileSystemLoader('/path/to/templates')
>>> loader = FileSystemLoader(['/path/to/templates', '/other/path'])
```

По умолчанию кодировка шаблона - «utf-8», которую можно изменить, установив для параметра кодировки _**encoding**_ другое значение.

Чтобы следовать символическим ссылкам, установите для параметра _**followlinks**_ значение `True`:

```python
>>> loader = FileSystemLoader('/path/to/templates', followlinks=True)
```

_Изменено в версии 2.8:_ Добавлен параметр _**followlinks**_.

### класс PackageLoader

#### &#x20;_class_ jinja2.PackageLoader(_package\_name_, _package\_path='templates'_, _encoding='utf-8'_)

Загружает шаблоны из яиц или пакетов Python. Он состоит из имени пакета _**package\_name**_ Python и пути к шаблонам _**package\_path**_ в этом пакете:

```python
loader = PackageLoader('mypackage', 'views')
```

Если путь _**package\_path**_ к пакету не указан, предполагается `'templates'`.

По умолчанию кодировка шаблона - `'utf-8'`, которую можно изменить, установив для параметра кодировки _**encoding**_ другое значение. Из-за природы яиц перезагрузить шаблоны можно только в том случае, если пакет был загружен из файловой системы, а не из zip-файла.

### класс DictLoader

#### &#x20;_class_ jinja2.DictLoader(_mapping_)

Загружает шаблон из словаря Python. Передает набор строк юникода, привязанных к именам шаблонов. Этот загрузчик полезен для юнит-тестирования:

```python
>>> loader = DictLoader({'index.html': 'source here'})
```

Поскольку автоматическая перезагрузка редко используется, по умолчанию она отключена.

### класс FunctionLoader

#### &#x20;_class_ jinja2.FunctionLoader(_load\_func_)

Загрузчик, которому передана функция, выполняющая загрузку. Функция получает имя шаблона и должна возвращать либо строку Unicode с источником шаблона, либо кортеж в форме `(source, filename, uptodatefunc)` или `None`, если шаблон не существует.

```python
>>> def load_template(name):
...     if name == 'index.html':
...         return '...'
...
>>> loader = FunctionLoader(load_template)
```

_**uptodatefunc**_ - это функция, которая вызывается, если включена автоматическая перезагрузка, и должна возвращать `True`, если шаблон все еще актуален. Для получения дополнительных сведений см. **BaseLoader.get\_source ()**, который имеет такое же возвращаемое значение.

### класс PrefixLoader

#### &#x20;_class_ jinja2.PrefixLoader(_mapping_, _delimiter='/'_)

Загрузчик, которому передается список загрузчиков, где каждый загрузчик привязан к префиксу. По умолчанию префикс отделяется от шаблона косой чертой, которую можно изменить, установив в качестве аргумента-разделителя _**delimiter**_ другое значение:

```python
loader = PrefixLoader({
    'app1':     PackageLoader('mypackage.app1'),
    'app2':     PackageLoader('mypackage.app2')
})
```

При загрузке `'app1/index.html'` загружается файл из пакета _**app1**_, при загрузке `'app2/index.html'` - файл из второго _**app2**_.

### класс ChoiceLoader

#### &#x20;_class_ jinja2.ChoiceLoader(_loaders_)

Этот загрузчик работает как **PrefixLoader**, только без префикса. Если шаблон не может быть найден одним загрузчиком, пробуется следующий.

```python
>>> loader = ChoiceLoader([
...     FileSystemLoader('/path/to/user/templates'),
...     FileSystemLoader('/path/to/system/templates')
... ])
```

Это полезно, если вы хотите разрешить пользователям переопределять встроенные шаблоны из другого места.

### класс ModuleLoader

#### &#x20;_class_ jinja2.ModuleLoader(_path_)

Этот загрузчик загружает шаблоны из предварительно скомпилированных шаблонов. Пример использования:

```python
>>> loader = ChoiceLoader([
...     ModuleLoader('/path/to/compiled/templates'),
...     FileSystemLoader('/path/to/templates')
... ])
```

Шаблоны можно предварительно скомпилировать с помощью **Environment.compile\_templates ()**.

## Кэш байт-кода (Bytecode Cache)

**Jinja** 2.1 и выше поддерживает внешнее кэширование байт-кода. Кеши байт-кода позволяют хранить сгенерированный байт-код в файловой системе или в другом месте, чтобы избежать синтаксического анализа шаблонов при первом использовании.

Это особенно полезно, если у вас есть веб-приложение, которое инициализируется по первому запросу, а **Jinja** компилирует сразу несколько шаблонов, что замедляет работу приложения.

Чтобы использовать кеш байт-кода, создайте его экземпляр и передайте в **Environment**.

### класс BytecodeCache

#### &#x20;_class_ jinja2.BytecodeCache

Чтобы реализовать свой собственный кеш байт-кода, вы должны создать подкласс этого класса и переопределить _**load\_bytecode ()**_ и _**dump\_bytecode ()**_. Оба эти метода передаются **bccache.Bucket**.

Очень простой кеш байт-кода, который сохраняет байт-код в файловой системе:

```python
from os import path

class MyCache(BytecodeCache):

    def __init__(self, directory):
        self.directory = directory

    def load_bytecode(self, bucket):
        filename = path.join(self.directory, bucket.key)
        if path.exists(filename):
            with open(filename, 'rb') as f:
                bucket.load_bytecode(f)

    def dump_bytecode(self, bucket):
        filename = path.join(self.directory, bucket.key)
        with open(filename, 'wb') as f:
            bucket.write_bytecode(f)
```

Более продвинутая версия кэша байт-кода на основе файловой системы является частью **Jinja**.

#### Методы класса BytecodeCache

* &#x20;**clear**() - Очищает кеш. Этот метод не используется **Jinja**, но должен быть реализован, чтобы позволить приложениям очищать кеш байт-кода, используемый конкретной средой.
* &#x20;**dump\_bytecode**( _bucket_ ) - Подклассы должны переопределить этот метод, чтобы записать байт-код из _**bucket**_ обратно в кеш. Если он не может этого сделать, он не должен молчать, а вызвать исключение.
* &#x20;**load\_bytecode**( _bucket_ ) - Подклассы должны переопределить этот метод для загрузки байт-кода в _**bucket**_. Если они не могут найти код в кэше для _**bucket**_, он не должен ничего делать.

### класс bccache.Bucket

#### &#x20;_class_ jinja2.bccache.Bucket(_environment_, _key_, _checksum_)

Бакеты используются для хранения байт-кода для одного шаблона. Он создается и инициализируется кешем байт-кода и передается функциям загрузки.

Сегменты _**bucket**_ получают внутреннюю контрольную сумму из назначенного кеша и используют ее для автоматического отклонения устаревшего материала кеша. Отдельные подклассы кеша байт-кода не должны заботиться об аннулировании кеша.

#### Атрибуты класса bccache.Bucket

* **enviroment** - Среда **Environment**, создавшая _**bucket**_.
* **key** - Уникальный ключ кеша для этого сегмента _**bucket**_.
* _**code**_ - Байт-код, если он загружен, в противном случае - `None`.

#### Методы класса bccache.Bucket

* &#x20;**bytecode\_from\_string**( _string_ ) - Загружает байт-код из строки.
* &#x20;**bytecode\_to\_string**() - Возвращает байт-код в виде строки.
* &#x20;**load\_bytecode**( _f_ ) - Загружает байт-код из файла или файлового объекта.
* &#x20;**reset**() - Сбрасывает _**bucket**_ (выгружает байт-код).
* &#x20;**write\_bytecode**( _f_ ) - Выгружает байт-код в файл или в объект, похожий на файл.

Встроенные кеши байт-кода:

### класс FileSystemBytecodeCache

#### &#x20;_class_ jinja2.FileSystemBytecodeCache(_directory=None_, _pattern='\_\_jinja2\_%s.cache'_)

Кэш байт-кода, который хранит байт-код в файловой системе. Он принимает два аргумента: каталог _**directory**_, в котором хранятся элементы кеша, и строку шаблона _**pattern**_, которая используется для создания имени файла.

Если каталог _**directory**_ не указан, выбирается каталог кеша по умолчанию. В Windows используется временный каталог пользователя, в системах UNIX каталог создается для пользователя в системном временном каталоге.

Шаблон _**pattern**_ можно использовать, чтобы несколько отдельных кешей работали в одном каталоге. Шаблон по умолчанию _**pattern**_ - `'__jinja2_%s.cache'`, где `%s` заменяется ключом кеша.

```python
>>> bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')
```

Этот кэш байт-кода поддерживает очистку кеша с помощью метода очистки.

### класс MemcachedBytecodeCache

#### &#x20;_class_ jinja2.MemcachedBytecodeCache(_client_, _prefix='jinja2/bytecode/'_, _timeout=None_, _ignore\_memcache\_errors=True_)

Этот класс реализует кэш байт-кода, который использует кеш в памяти для хранения информации. Он не применяет конкретную библиотеку кэша памяти (**memcache** или **cmemcache**), но принимает любой класс, который предоставляет минимальный требуемый интерфейс.

Библиотеки, совместимые с этим классом:

* [cachelib](https://github.com/pallets/cachelib)
* [python-memcached](https://pypi.org/project/python-memcached/)

(К сожалению, интерфейс кэша **Django** несовместим, потому что он не поддерживает хранение двоичных данных, только unicode. Однако вы можете передать базовый клиент кеша в кеш байт-кода, который доступен как `django.core.cache.cache._client`.)

Минимальный интерфейс для клиента, передаваемый конструктору, следующий:

### класс MinimalClientInterface

#### &#x20;_class_ MinimalClientInterface

* &#x20;**set**( _key_, _value_ \[, _timeout_ ]) - Сохраняет байт-код в кеше. _**value**_ - это строка, а _**timeout**_ - тайм-аут ключа _**key**_. Если _**timeout**_ не указан, используется таймаут по умолчанию или не следует предполагать тайм-аут, если он указан, это целое число с количеством секунд, в течение которых должен существовать элемент кеша.
* &#x20;**get**( _key_ ) - Возвращает значение ключа кеша. Если элемент не существует в кэше, возвращаемое значение должно быть `None`.

Другими аргументами конструктора являются префикс для всех ключей, который добавляется перед фактическим ключом кеша, и тайм-аут для байт-кода в системе кеширования. Мы рекомендуем высокий тайм-аут (или его отсутствие).

Этот кэш байт-кода не поддерживает очистку использованных элементов в кеше. Метод очистки - это функция без операции.

_Новое в версии 2.7:_ Добавлена поддержка игнорирования ошибок кэша памяти с помощью параметра _**ignore\_memcache\_errors**_.

## Асинхронная поддержка

_Новое в версии 2.9_.

**Jinja** поддерживает синтаксис Python `async` и `await`. Для дизайнера шаблонов эта поддержка (если она включена) полностью прозрачна, шаблоны продолжают выглядеть точно так же. Однако разработчики должны знать о реализации, поскольку от нее зависит, какие типы API вы можете использовать.

По умолчанию поддержка асинхронного режима отключена. Включение этого параметра заставит среду компилировать другой код за кулисами для обработки асинхронного и синхронизирующего кода в цикле событий `asyncio`. Это имеет следующие последствия:

* Визуализация шаблона требует, чтобы цикл событий был доступен текущему потоку. **asyncio.get\_event\_loop ()** должен возвращать цикл событий.
* Скомпилированный код использует `await` для функций и атрибутов и использует `async` для циклов. Для поддержки использования асинхронных и синхронных функций в этом контексте вокруг всех вызовов и доступа помещается небольшая оболочка, которая увеличивает накладные расходы по сравнению с чисто асинхронным кодом.
* При необходимости методы и фильтры синхронизации становятся оболочками для соответствующих им асинхронных реализаций. Например, **render** вызывает **async\_render**, а `|map` поддерживает асинхронные итерации.

Ожидаемые объекты могут быть возвращены из функций в шаблонах, и любой вызов функции в шаблоне будет автоматически ожидать результата. Подразумевается ожидание, которое вы обычно добавляете в Python. Например, вы можете предоставить метод, который асинхронно загружает данные из базы данных, и с точки зрения разработчика шаблона он может вызываться как любая другая функция.

## Политики

Начиная с **Jinja** 2.9 политики могут быть настроены в среде, что может немного влиять на поведение фильтров и других шаблонных конструкций. Их можно настроить с помощью атрибута **Enviroment.policies**.

Пример:

```python
env.policies['urlize.rel'] = 'nofollow noopener'
```

* &#x20;_**compiler.ascii\_str**_ - Это логическое значение контролирует Python 2, если **Jinja** должен хранить только литералы ASCII как строку байтов, а не строки Unicode. Раньше это всегда было включено для версий **Jinja** ниже 2.9, а теперь это можно изменить. Традиционно это делалось таким образом, поскольку некоторые API-интерфейсы в Python 2 плохо работали со строками Unicode (например, API `datetime.strftime`). Однако теперь иногда бывает и обратное (например, `str.format`). Если установлено значение `False`, все строки сохраняются внутри как Unicode.
* &#x20;_**truncate.leeway**_ - Настраивает свободу действий по умолчанию для фильтра усечения _**truncate**_. **Leeway**, представлен в 2.9, но для восстановления совместимости со старыми шаблонами его можно настроить на `0`, чтобы вернуть прежнее поведение. По умолчанию - `5`.
* &#x20;_**urlize.rel**_ - Строка, которая определяет элементы для атрибута _**rel**_ созданных ссылок с фильтром _**urlize**_. Эти элементы всегда добавляются. По умолчанию - _**noopener**_.
* &#x20;_**urlize.target**_ - Целевой объект по умолчанию, который выдается для ссылок из фильтра _**urlize**_, если никакая другая цель не определена вызовом явно.
* &#x20;_**json.dumps\_function -**_ Если для него установлено значение, отличное от `None`, тогда фильтр _**tojson**_ будет сбрасывать эту функцию вместо функции по умолчанию. Обратите внимание, что эта функция должна принимать произвольные дополнительные аргументы, которые могут быть переданы в будущем из фильтра. В настоящее время единственный аргумент, который можно передать, - это отступ _**indent**_. Функция дампа по умолчанию - `json.dumps`.
* &#x20;_**json.dumps\_kwargs -**_ Аргументы ключевого слова, передаваемые в функцию дампа. По умолчанию это `{'sort_keys': True}`.
*   &#x20;_**ext.i18n.trimmed -**_ Если для этого параметра установлено значение `True`, блоки `{% trans %}`

    [расширения i18n](rasshireniya-jinja.md) всегда будут объединять разрывы строк и окружающие пробелы, как если бы использовался модификатор _**trimmed**_.

## Утилиты

Эти вспомогательные функции и классы полезны, если вы добавляете пользовательские фильтры или функции в среду **Jinja**.

### декоратор environmentfilter()

#### &#x20;jinja2.environmentfilter(_f_ )

Декоратор для маркировки фильтров, зависящих от среды **Environment**. Текущая среда **Environment** передается фильтру в качестве первого аргумента.

### декоратор contextfilter()

#### &#x20;jinja2.contextfilter(_f_ )

Декоратор для маркировки контекстно-зависимых фильтров. Текущий контекст **Context** будет передан как первый аргумент.

### декоратор evalcontextfilter()

#### &#x20;jinja2.evalcontextfilter(_f_ )

Декоратор для маркировки контекстно-зависимых фильтров. Объект контекста _**eval**_ передается как первый аргумент. Дополнительные сведения о контексте eval см. В разделе контекст оценки **Evaluation Context**.

_Новое в версии 2.4_.

### декоратор environmentfunction()

#### &#x20;jinja2.environmentfunction(_f_ )

Этот декоратор можно использовать, чтобы пометить функцию или метод как вызываемые из среды. Этот декоратор работает точно так же, как декоратор **contextfunction ()**, только первый аргумент - это активная среда **Environment**, а не контекст.

### декоратор contextfunction()

#### &#x20;jinja2.contextfunction(_f_ )

Этот декоратор может использоваться для обозначения вызываемой функции или метода в контексте. Вызываемому контексту передается активный контекст **Context** в качестве первого аргумента при вызове из шаблона. Это полезно, если функция хочет получить доступ к контексту или функциям, предоставленным в объекте контекста. Например, функция, которая возвращает отсортированный список переменных шаблона, экспортируемых текущим шаблоном, может выглядеть так:

```python
@contextfunction
def get_exported_names(context):
    return sorted(context.exported_vars)
```

### декоратор evalcontextfunction()

#### &#x20;jinja2.evalcontextfunction(_f_ )

Этот декоратор можно использовать для пометки функции или метода как вызываемого контекста _**eval**_. Это похоже на **contextfunction ()**, но вместо передачи контекста передается объект контекста оценки. Дополнительные сведения о контексте eval см. в разделе контекст оценки **Evaluation Context**.

_Новое в версии 2.4_.

### функция escape()

#### &#x20;jinja2.escape(_s_ )

Преобразует символы `&`, `<`,`>`, `'` и `"` в строке _**s**_ в безопасные для HTML последовательности. Используйте это, если вам нужно отобразить текст, который может содержать такие символы в HTML. Эта функция не будет экранировать объекты, которые имеют представление HTML. например, уже экранированные данные.

Возвращаемое значение - строка разметки **jinja2.Markup**.

### функция clear\_caches()

#### &#x20;jinja2.clear\_caches()

**Jinja** хранит внутренние кеши для сред и лексеров. Они используются, чтобы **Jinja** не приходилось постоянно воссоздавать окружение и лексеры. Обычно вам не нужно об этом заботиться, но если вы измеряете потребление памяти, вы можете очистить кеши.

### функция is\_undefined()

#### &#x20;jinja2.is\_undefined(_obj_ )

Проверьте, не определен ли переданный объект. Это не что иное, как проверка экземпляра на **Undefined**, но выглядит лучше. Это можно использовать для настраиваемых фильтров или тестов, которые хотят реагировать на неопределенные переменные. Например, настраиваемый фильтр по умолчанию может выглядеть так:

```python
def default(var, default=''):
    if is_undefined(var):
        return default
    return var
```

### класс Markup

#### &#x20;_class_ jinja2.Markup( \[ _string_ ] )

Строка, готовая к безопасной вставке в документ HTML или XML, потому что она была экранирована или помечена как безопасная.

Передача объекта конструктору преобразует его в текст и обертывает, чтобы пометить его как безопасный без экранирования. Чтобы экранировать текст, используйте вместо этого метод класса **escape ()**.

```python
>>> Markup('Hello, <em>World</em>!')
Markup('Hello, <em>World</em>!')
>>> Markup(42)
Markup('42')
>>> Markup.escape('Hello, <em>World</em>!')
Markup('Hello &lt;em&gt;World&lt;/em&gt;!')
```

Это реализует интерфейс `__html__()`, который используют некоторые фреймворки. Передача объекта, реализующего `__html__()`, завершит вывод этого метода, пометив его как безопасный.

```python
>>> class Foo:
...     def __html__(self):
...         return '<a href="/foo">foo</a>'
...
>>> Markup(Foo())
Markup('<a href="/foo">foo</a>')
```

Это подкласс текстового типа (_**str**_ в Python 3, _**unicode**_ в Python 2). Он имеет те же методы, что и этот тип, но все методы избегают своих аргументов и возвращают экземпляр **Markup**.

```python
>>> Markup('<em>%s</em>') % 'foo & bar'
Markup('<em>foo &amp; bar</em>')
>>> Markup('<em>Hello</em> ') + '<foo>'
Markup('<em>Hello</em> &lt;foo&gt;')
```

#### Атрибуты Markup

* &#x20;_classmethod_ **escape**(_s_ ) - Экранирует строку. Вызывает [escape ()](dokumentaciya-po-konstruktoru-shablonov.md) и гарантирует, что для подклассов будет возвращен правильный тип.
* &#x20;**striptags**() - **unescape ()** разметку, удаление тегов и нормализацию пробелов до отдельных пробелов.

```python
>>> Markup('Main &raquo;        <em>About</em>').striptags()
'Main » About'
```

* &#x20;**unescape**() - Преобразует экранированную разметку обратно в текстовую строку. При этом объекты HTML заменяются символами, которые они представляют.

```python
>>> Markup('Main &raquo; <em>About</em>').unescape()
'Main » <em>About</em>'
```

{% hint style="info" %}
**Примечание:**

Класс **Jinja** **Markup** совместим как минимум с **Pylons** и **Genshi**. Ожидается, что в ближайшее время концепцией `__html__` воспользуются другие механизмы шаблонов и фреймворки.
{% endhint %}

## Исключения

### исключение TemplateError

#### &#x20;_exception_ jinja2.TemplateError(_message=None_)

Базовый класс для всех ошибок шаблона.

### исключение UndefinedError

#### &#x20;_exception_ jinja2.UndefinedError(_message=None_)

Возникает, если шаблон пытается работать с **Undefined**.

### исключение TemplateNotFound

#### &#x20;_exception_ jinja2.TemplateNotFound(_name_, _message=None_)

Возникает, если шаблон не существует.

_Изменено в версии 2.11:_ если задано имя **Undefined** и сообщение не было предоставлено, возникает **UndefinedError**.

### исключение TemplatesNotFound

#### &#x20;_exception_ jinja2.TemplatesNotFound(_names=()_, _message=None_)

Подобно **TemplateNotFound**, но возникает, если выбрано несколько шаблонов. Это подкласс исключения **TemplateNotFound**, поэтому простой перехват базового исключения перехватит оба.

_Изменено в версии 2.11:_ если имя в списке имен не определено, вместо пустой строки отображается сообщение о том, что оно не определено.

_Новое в версии 2.2_.

### исключение TemplateSyntaxError

#### &#x20;_exception_ jinja2.TemplateSyntaxError(_message_, _lineno_, _name=None_, _filename=None_)

Поднимается, чтобы сообщить пользователю о проблеме с шаблоном. Параметры:

* message - Сообщение об ошибке как строка байтов utf-8.
* lineno - Номер строки, в которой произошла ошибка.
* name - Имя загрузки для шаблона в виде строки Unicode.
* filename - Имя файла, в которое загружен шаблон в виде байтовой строки в кодировке файловой системы (скорее всего, utf-8 или mbcs в системах Windows).

Причина, по которой имя файла и сообщение об ошибке являются строками байтов, а не строками Unicode, заключается в том, что Python 2.x не использует Unicode для исключений и трассировки, а также компилятор. Это изменится с Python 3.

### исключение TemplateRuntimeError

#### &#x20;_exception_ jinja2.TemplateRuntimeError(_message=None_)

Общая ошибка времени выполнения в шаблоне. В некоторых ситуациях **Jinja** может вызвать это исключение.

### исключение TemplateAssertionError

#### &#x20;_exception_ jinja2.TemplateAssertionError(_message_, _lineno_, _name=None_, _filename=None_)

Подобна синтаксической ошибке шаблона, но охватывает случаи, когда что-то в шаблоне вызывало ошибку во время компиляции, которая не обязательно была вызвана синтаксической ошибкой. Однако это прямой подкласс **TemplateSyntaxError** и имеет те же атрибуты.

## Пользовательские фильтры

Пользовательские фильтры - это просто обычные функции Python, которые принимают левую часть фильтра в качестве первого аргумента, а аргументы, передаваемые фильтру как дополнительные аргументы или аргументы ключевого слова.

Например, в фильтре  `{{ 42|myfilter(23) }}` будет вызвана функция `myfilter (42, 23)`. Вот, например, простой фильтр, который можно применить к объектам `datetime` для их форматирования:

```python
def datetimeformat(value, format='%H:%M / %d-%m-%Y'):
    return value.strftime(format)
```

Вы можете зарегистрировать его в среде шаблонов, обновив фильтры _**filters**_ в среде **Environment**:

```python
environment.filters['datetimeformat'] = datetimeformat
```

Затем внутри шаблона его можно использовать следующим образом:

```python
written on: {{ article.pub_date|datetimeformat }}
publication date: {{ article.pub_date|datetimeformat('%d-%m-%Y') }}
```

Фильтры также могут передавать текущий контекст шаблона или среду. Это полезно, если фильтр хочет вернуть неопределенное значение или проверить текущую настройку _**autoescape**_. Для этого существует три декоратора: `environmentfilter ()`, `contextfilter ()` и `evalcontextfilter ()`.

Вот небольшой пример фильтра, который разбивает текст на разрывы строк HTML и абзацы и помечает возвращаемое значение как безопасную строку HTML, если включено автоэкранирование:

```python
import re
from jinja2 import evalcontextfilter, Markup, escape

_paragraph_re = re.compile(r'(?:\r\n|\r(?!\n)|\n){2,}')

@evalcontextfilter
def nl2br(eval_ctx, value):
    result = u'\n\n'.join(u'<p>%s</p>' % p.replace('\n', Markup('<br>\n'))
                          for p in _paragraph_re.split(escape(value)))
    if eval_ctx.autoescape:
        result = Markup(result)
    return result
```

Фильтры контекста работают так же, как только первый аргумент - это текущий активный контекст **Context**, а не среда.

## Контекст оценки (Evaluation Context)

Контекст оценки (короткий контекст _**eval**_ или _**eval ctx**_) - это новый объект, представленный в **Jinja** 2.4, который позволяет активировать и деактивировать скомпилированные функции во время выполнения.

В настоящее время он используется только для включения и отключения автоматического экранирования, но также может использоваться для расширений.

В предыдущих версиях **Jinja** фильтры и функции были помечены как вызываемые среды, чтобы проверить статус _**autoescape**_ из среды. В новых версиях рекомендуется вместо этого проверять настройку в контексте оценки.

Предыдущие версии:

```python
@environmentfilter
def filter(env, value):
    result = do_something(value)
    if env.autoescape:
        result = Markup(result)
    return result
```

В новых версиях вы можете либо использовать **contextfilter ()** и получить доступ к контексту оценки из фактического контекста, либо использовать **evalcontextfilter ()**, который напрямую передает контекст оценки функции:

```python
@contextfilter
def filter(context, value):
    result = do_something(value)
    if context.eval_ctx.autoescape:
        result = Markup(result)
    return result

@evalcontextfilter
def filter(eval_ctx, value):
    result = do_something(value)
    if eval_ctx.autoescape:
        result = Markup(result)
    return result
```

Контекст оценки не должен изменяться во время выполнения. Модификации должны происходить только с узлами **nodes.EvalContextModifier** и **nodes.ScopedEvalContextModifier** из расширения, а не с самим объектом контекста _**eval**_.

### класс nodes.EvalContext

#### &#x20;_class_ jinja2.nodes.EvalContext(_environment_, _template\_name=None_)

Содержит информацию о времени оценки. К нему можно прикрепить собственные атрибуты в расширениях.

* _**autoescape**_ - `True` или `False` в зависимости от того, активно ли автоматическое экранирование.
* _**volatile**_ - `True`, если компилятор не может оценить некоторые выражения во время компиляции. Во время выполнения это всегда должно быть `False`.

## Пользовательские тесты

Тесты работают как фильтры, только в том смысле, что у теста нет возможности получить доступ к среде или контексту и что их нельзя связать цепочкой. Возвращаемое значение теста должно быть `True` или `False`. Цель теста - дать разработчикам шаблонов возможность выполнять проверки типов и совместимости.

Вот простой тест, который проверяет, является ли переменная простым числом:

```python
import math

def is_prime(n):
    if n == 2:
        return True
    for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
        if n % i == 0:
            return False
    return True
```

Вы можете зарегистрировать его в среде **Environment** шаблона, обновив словарь _**tests**_ в среде:

```python
environment.tests['prime'] = is_prime
```

Затем разработчик шаблонов может использовать тест следующим образом:

```python
{% raw %}
{% if 42 is prime %}
    42 is a prime number
{% else %}
    42 is not a prime number
{% endif %}
{% endraw %}
```

## Глобальное пространство имен

Переменные, хранящиеся в словаре **Environment.globals**, являются особенными, поскольку они доступны и для импортированных шаблонов, даже если они импортированы без контекста. Это место, куда вы можете поместить переменные и функции, которые должны быть доступны постоянно. Кроме того, существуют **Template.globals**, которые представляют собой переменные, доступные для определенного шаблона, которые доступны для всех вызовов **Template.render ()**.

## API низкого уровня

API низкого уровня предоставляет функциональные возможности, которые могут быть полезны для понимания некоторых деталей реализации, целей отладки или передовых методов [расширения](rasshireniya-jinja.md). Если вы точно не знаете, что делаете, мы не рекомендуем их использовать.

### метод Environment.lex()

#### &#x20;Environment.lex(_source_, _name=None_, _filename=None_)

Лексирует заданный исходный код и возвращайте генератор, который выдает токены в виде кортежей в форме `(lineo, token_type, value)`. Это может быть полезно для разработки [расширений](rasshireniya-jinja.md) и отладки шаблонов.

Не выполняет предварительную обработку. Если вы хотите применить предварительную обработку расширений, вам необходимо отфильтровать источник с помощью метода **Environment.preprocess ()**.

### метод Environment.parse()

#### &#x20;Environment.parse(_source_, _name=None_, _filename=None_)

Анализирует исходный код и возвращает абстрактное синтаксическое дерево. Это дерево узлов используется компилятором для преобразования шаблона в исполняемый исходный код или байт-код. Это полезно для отладки или для извлечения информации из шаблонов.

Если вы разрабатываете [расширения Jinja](rasshireniya-jinja.md), это дает вам хороший обзор сгенерированного дерева узлов.

### метод Environment.preprocess()

#### &#x20;Environment.preprocess(_source_, _name=None_, _filename=None_)

Предварительно обрабатывает исходный код со всеми расширениями. Автоматически вызывается для всех методов синтаксического анализа и компиляции, но не для **Environment.lex ()**, потому что там обычно требуется токенизация только фактического источника.

### метод Template.new\_context()

#### &#x20;Template.new\_context(_vars=None_, _shared=False_, _locals=None_)

Создает новый контекст **Context** для этого шаблона. Предоставленные переменные _**vars**_ будут переданы в шаблон. По умолчанию глобальные объекты добавляются в контекст. Если для параметра _**shared**_ установлено значение `True`, данные передаются в контекст без добавления глобальных объектов.

_**locals**_ может быть словарем локальных переменных для внутреннего использования.

### метод Template.root\_render\_func()

#### &#x20;Template.root\_render\_func( _context_ )

Это функция рендеринга низкого уровня. Ей передается контекст **Context**, который должен быть создан функцией **Template.new\_context ()** того же или совместимого шаблона. Эта функция рендеринга генерируется компилятором из кода шаблона и возвращает генератор, который выдает строки Юникода.

Если в коде шаблона возникает исключение, механизм шаблонов не перезаписывает исключение, а передает исходное. На самом деле эта функция должна вызываться только из вызова **Template.render ()** / **Template.generate ()** / **Template.stream ()**.

### словарь Template.blocks

#### &#x20;Template.blocks

Описание функций рендеринга блоков. Каждая из этих функций работает точно так же, как **Template.root\_render\_func ()** с теми же ограничениями.

### атрибут Template.is\_up\_to\_date

#### &#x20;Template.is\_up\_to\_date

Этот атрибут имеет значение `False`, если доступна более новая версия шаблона, в противном случае - `True`.

{% hint style="info" %}
**Примечание:**

Низкоуровневый API хрупок. Будущие версии **Jinja** постараются не изменять его обратно несовместимым способом, но изменения в ядре **Jinja** могут проявиться. Например, если **Jinja** представит новый узел AST в более поздних версиях, который может быть возвращен функцией **Environment.parse ()**.
{% endhint %}

## Мета API

_Новое в версии 2.2_.

Мета-API возвращает некоторую информацию об абстрактных синтаксических деревьях, которые могут помочь приложениям реализовать более сложные концепции шаблонов. Все функции мета-API работают с абстрактным синтаксическим деревом, возвращаемым методом **Environment.parse ()**.

### функция meta.find\_undeclared\_variables()

#### &#x20;jinja2.meta.find\_undeclared\_variables( _ast_ )

Возвращает набор всех переменных в AST, которые будут просматриваться из контекста во время выполнения. Поскольку во время компиляции неизвестно, какие переменные будут использоваться в зависимости от пути выполнения во время выполнения, возвращаются все переменные.

```python
>>> from jinja2 import Environment, meta
>>> env = Environment()
>>> ast = env.parse('{% raw %}
{% set foo = 42 %}
{% endraw %}{{ bar + foo }}')
>>> meta.find_undeclared_variables(ast) == set(['bar'])
True
```

{% hint style="info" %}
**Реализация:**

Внутренне генератор кода используется для поиска необъявленных переменных. Это полезно знать, потому что генератор кода может вызвать **TemplateAssertionError** во время компиляции, и на самом деле эта функция в настоящее время также может вызывать это исключение.
{% endhint %}

### функция meta.find\_referenced\_templates()

#### &#x20;jinja2.meta.find\_referenced\_templates( _ast_ )

Находит все ссылочные шаблоны из AST. Это вернет итератор по всем жестко запрограммированным расширениям, включениям и импортам шаблонов. Если используется динамическое наследование или включение, возвращается значение `None`.

```python
>>> from jinja2 import Environment, meta
>>> env = Environment()
>>> ast = env.parse('{% raw %}
{% extends "layout.html" %}{% include helper %}
{% endraw %}')
>>> list(meta.find_referenced_templates(ast))
['layout.html', None]
```

Эта функция полезна для отслеживания зависимостей. Например, если вы хотите перестроить части веб-сайта после изменения шаблона макета.
