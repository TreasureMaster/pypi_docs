# Руководство virtualenv

## Введение

В **virtualenv** есть одна основная команда:

```bash
virtualenv venv
```

Это создаст виртуальную среду python той же версии, где установлена **virtualenv**, по пути `venv`. Инструмент командной строки имеет довольно много флагов, которые изменяют поведение инструмента, для получения полного списка обязательно проверьте [флаги CLI](interfeis-cli-virtualenv.md#flagi-cli).

Инструмент работает в два этапа:

* На **этапе 1** обнаруживается интерпретатор python, из которого создается виртуальная среда (по умолчанию это тот же python, на котором работает **virtualenv**, однако мы можем изменить это с помощью параметра **p**).
* На **этапе 2** создается виртуальная среда в указанном месте назначения (**dest**), это можно разбить на четыре дополнительных подэтапа:
* создать python, соответствующий целевому интерпретатору python из фазы 1,
* установить (**bootstrap**) пакеты потомков (один или несколько из **pip**, **setuptools**, **wheel**) в созданную виртуальную среду,
* установить скрипты активации в двоичный каталог виртуальной среды (это позволит конечному пользователю **активировать** виртуальную среду из различных оболочек).
* создавать файлы, которые отмечают, что виртуальная среда игнорируется системами контроля версий (в настоящее время мы поддерживаем только Git, поскольку Mercurial, Bazaar или SVN не поддерживают игнорирование файлов в подкаталогах). Этот шаг можно пропустить с помощью опции **no-vcs-ignore**.

Python в вашем новом **virtualenv** эффективно изолирован от python, который использовался для его создания.

## Открытие Python

Первое, что нам нужно для создания виртуальной среды, - это интерпретатор Python. Это опишет инструменту, какой тип виртуальной среды вы хотите создать, думайте об этом как о версии, архитектуре, реализации.

**virtualenv**, являющийся приложением на Python, всегда имеет по крайней мере один доступный, один **virtualenv** сам его использует, и поэтому это обнаруженный элемент по умолчанию. Это означает, что если вы установите **virtualenv** под `python 3.8`, **virtualenv** по умолчанию создаст виртуальные среды, которые также имеют версию `3.8`.

Созданные виртуальные среды Python обычно не являются автономными. Полная упаковка python обычно состоит из тысяч файлов, поэтому повторно устанавливать весь python в новую папку неэффективно. Вместо этого виртуальные среды представляют собой простые оболочки, которые содержат мало внутри себя и большую часть заимствуют у системного python (это то, что вы установили, когда вы установили сам python). Это означает, что если вы обновите системный Python, ваши виртуальные среды **могут** сломаться, так что будьте осторожны. Положительная сторона этого обращения к системному питону заключается в том, что создание виртуальных сред может быть быстрым.

Здесь мы опишем встроенный механизм (обратите внимание, что он может быть расширен с помощью плагинов). Флаг CLI **-p** или **--python** позволяет вам указать спецификатор python для того, какой тип виртуальной среды вы хотите, формат может быть следующим:

* относительный / абсолютный путь к интерпретатору Python,
* спецификатор, определяющий реализацию, версию, архитектуру Python в следующем формате:

```bash
{python implementation name}{version}{architecture}
```

У нас есть следующие ограничения:

* реализация python состоит из буквенных символов (**python** означает любую реализацию, а если отсутствует, по умолчанию используется **python**),
* версия - это номер версии, разделенный точкой,
* архитектура либо **-64**, либо **-32** (отсутствие означает любые **any**).

Например:

* `python3.8.1` означает любую реализацию python, имеющую версию `3.8.1`,
* `3` означает любую реализацию Python, имеющую основную версию `3`,
* `cpython3` означает реализацию `CPython` версии `3`,
* `pypy2` означает интерпретатор python с реализацией `PyPy` и основной версией `2`.

Учитывая спецификатор, **virtualenv** будет применять следующую стратегию для обнаружения / поиска исполняемого файла системы:

* Если мы работаем в Windows, загляните в реестр Windows и проверьте, есть ли какие-либо зарегистрированные реализации Python, соответствующие спецификации. Это соответствует ожиданиям, изложенным в [PEP-514](https://www.python.org/dev/peps/pep-0514/).
* Попытайтесь найти соответствующий исполняемый файл python в папках, перечисленных в переменной среды **PATH**. В этом случае мы попытаемся найти исполняемый файл с именем, примерно похожим на спецификацию (точную логику см. в коде реализации).

{% hint style="warning" %}
Как подробно описано выше, виртуальные среды обычно просто заимствуют вещи из системного Python, на самом деле они не содержат всех данных из системного Python. Версия исполняемого файла python жестко запрограммирована внутри самого python.exe. Поэтому, если вы обновляете системный Python, ваша виртуальная среда все равно будет сообщать версию до обновления, даже если теперь, кроме исполняемого файла, весь дополнительный контент (стандартная библиотека, двоичные библиотеки и т. д.) относится к новой версии.

Без каких-либо серьезных несовместимостей (что бывает редко) виртуальная среда будет продолжать работать, но, за исключением содержимого, встроенного в исполняемый файл python, она будет вести себя как обновленная версия. Если такая виртуальная среда python указана в качестве целевого интерпретатора python, мы создадим виртуальные среды, соответствующие новой версии системного Python, а не версии, сообщенной виртуальной средой.
{% endhint %}

## Создатели

Это то, что на самом деле настраивает виртуальную среду, обычно в качестве ссылки на системный python. **virtualenv** на данный момент имеет два типа виртуальных сред:

* **venv** - это делегирует процесс создания модулю **venv**, как описано в [PEP 405](https://www.python.org/dev/peps/pep-0405/). Это доступно только в интерпретаторах Python, имеющих версию `3.4` или более позднюю, а также имеет обратную сторону, заключающуюся в том, что **virtualenv** должен создать процесс для вызова этого модуля (если **virtualenv** не установлен в системный python), что может быть дорогостоящей операцией (особенно в Windows).
* **builtin** - это означает, что **virtualenv** может сам выполнить операцию создания (точно зная, какие файлы создавать и на какие системные файлы нужно ссылаться). Создатель с именем **builtin** - это псевдоним первого создателя этого типа (мы предоставляем создателей для различных целевых сред, которые все различаются фактическими операциями создания, например CPython 2 в Windows, PyPy2 в Windows, CPython3 в Posix, PyPy3 в Posix и так далее; полный список см. **creator**).

## Seeders

Они установят для вас некоторые пакеты источников (один или несколько: [pip](https://pypi.org/project/pip/), [setuptools](https://pypi.org/project/setuptools/), [wheel](https://pypi.org/project/wheel/)), которые позволяют вам установить дополнительные пакеты python в созданную виртуальную среду (путем вызова **pip**). Доступны два основных механизма подачи источников:

* **pip** - этот метод использует связанный пакет с **virtualenv** для установки начальных пакетов (обратите внимание, что для этого необходимо создать новый дочерний процесс, что может быть дорогостоящим, особенно в Windows).
* **app-data** - этот метод использует каталог данных пользовательского приложения для создания образов установки. Эти изображения необходимо создать только один раз, а последующие виртуальные среды могут просто связать/скопировать эти изображения в свой путь к чистой библиотеке Python (папка **site-packages**). Это позволяет быстро создавать все виртуальные среды, кроме первого (механизм **pip** обычно занимает 98% времени создания **virtualenv**, поэтому, создав этот установочный образ, который мы можем просто связать с каталогом установки виртуальных сред, мы можем добиться ускорения установки от начальных 1 минут 10 секунд до 8 секунд в случае копирования или `0,8` секунды в случае, если доступны символические ссылки - это в Windows, Linux / macOS с символическими ссылками, это может быть всего `100 мс` от `3+` секунд). Чтобы переопределить расположение кэша начального числа в файловой системе, можно использовать переменную среды **VIRTUALENV\_OVERRIDE\_APP\_DATA**.

### Wheels
