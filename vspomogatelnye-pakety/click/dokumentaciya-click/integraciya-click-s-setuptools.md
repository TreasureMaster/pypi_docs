# Интеграция Click с setuptools

При написании утилит командной строки рекомендуется писать их как модули, которые распространяются с помощью **setuptools**, вместо использования Unix **shebangs**.

Почему вы хотите это сделать? Есть множество причин:

1. Одна из проблем традиционного подхода заключается в том, что первый модуль, загружаемый интерпретатором Python, имеет неправильное имя. Это может показаться незначительной проблемой, но имеет довольно серьезные последствия. Первый модуль не вызывается по его фактическому имени, но интерпретатор переименовывает его в `__main__`. Хотя это совершенно правильное имя, это означает, что если другой фрагмент кода захочет импортировать из этого модуля, он запустит импорт во второй раз под своим настоящим именем, и вдруг ваш код будет импортирован дважды.
2. Не на всех платформах есть вещи, которые легко выполнить. В Linux и OS X вы можете добавить комментарий в начало файла (`#!/usr/bin/env python`), и ваш скрипт будет работать как исполняемый файл (при условии, что у него установлен исполняемый бит). Однако это не работает в Windows. В Windows вы можете связать интерпретаторы с расширениями файлов (например, если все, что заканчивается на `.py`, выполняется через интерпретатор Python), вы столкнетесь с проблемами, если захотите использовать скрипт в **virtualenv**. На самом деле запуск сценария в виртуальном окружении также является проблемой для OS X и Linux. При традиционном подходе вам необходимо активировать весь **virtualenv**, чтобы использовать правильный интерпретатор Python. Не очень удобный.
3. Главный трюк работает только в том случае, если скрипт является модулем Python. Если ваше приложение становится слишком большим, и вы хотите начать использовать пакет, вы столкнетесь с проблемами.

## Вступление

Чтобы связать скрипт с **setuptools**, вам нужен только скрипт в пакете Python и файл `setup.py`.

Представьте себе эту структуру каталогов:

```bash
yourscript.py
setup.py
```

Содержимое `yourscript.py`:

```python
import click

@click.command()
def cli():
    """Example script."""
    click.echo('Hello World!')
```

Содержание `setup.py`:

```python
from setuptools import setup

setup(
    name='yourscript',
    version='0.1',
    py_modules=['yourscript'],
    install_requires=[
        'Click',
    ],
    entry_points='''
        [console_scripts]
        yourscript=yourscript:cli
    ''',
)
```

Магия заключается в параметре **entry\_points**. Каждая строка ниже **console\_scripts** определяет один консольный скрипт. Первая часть перед знаком равенства (`=`) - это имя сценария, который необходимо сгенерировать, вторая часть - это путь импорта, за которым следует двоеточие (`:`) с командой **Click**.

Вот и все.

## Тестирование скрипта

Чтобы протестировать скрипт, вы можете создать новый **virtualenv**, а затем установить свой пакет:

```bash
$ virtualenv venv
$ . venv/bin/activate
$ pip install --editable .
```

После этого ваша команда должна быть доступна:

```bash
$ yourscript
Hello World!
```

## Скрипты в пакете

Если ваш скрипт растет, и вы хотите переключиться на ваш скрипт, содержащийся в пакете Python, необходимые изменения минимальны. Предположим, ваша структура каталогов изменилась на это:

```bash
yourpackage/
    __init__.py
    main.py
    utils.py
    scripts/
        __init__.py
        yourscript.py
```

В этом случае вместо использования **py\_modules** в файле `setup.py` вы можете использовать **packages** и поддержку автоматического поиска пакетов с помощью **setuptools**. В дополнение к этому также рекомендуется включать другие данные о пакете.

Это будет измененное содержимое `setup.py`:

```python
from setuptools import setup, find_packages

setup(
    name='yourpackage',
    version='0.1',
    packages=find_packages(),
    include_package_data=True,
    install_requires=[
        'Click',
    ],
    entry_points='''
        [console_scripts]
        yourscript=yourpackage.scripts.yourscript:cli
    ''',
)
```
