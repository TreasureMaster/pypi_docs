# Почему Click?

Существует так много библиотек для написания утилит командной строки; почему существует **Click**?

На этот вопрос легко ответить: потому что нет ни одной утилиты командной строки для Python, которая бы отметила следующие поля:

* лениво компонуется без ограничений
* поддерживает реализацию соглашений командной строки Unix / POSIX
* поддерживает загрузку значений из переменных среды из коробки
* поддержка запроса пользовательских значений
* полностью вкладываемый и составной
* работает одинаково в Python 2 и 3
* поддерживает обработку файлов из коробки
* поставляется с полезными общими помощниками (получение размеров терминала, цветов ANSI, получение прямого ввода с клавиатуры, очистка экрана, поиск путей конфигурации, запуск приложений и редакторов и т. д.)

Есть много альтернатив **Click**; очевидными являются **optparse** и **argparse** из стандартной библиотеки. Посмотрите, не резонирует ли вам что-то еще.

На самом деле **Click** реализует собственный синтаксический анализ аргументов и не использует **optparse** или **argparse**, следуя поведению синтаксического анализа **optparse**. Причина, по которой он не основан на **argparse**, заключается в том, что **argparse** не позволяет должным образом вкладывать команды по дизайну и имеет некоторые недостатки, когда дело доходит до обработки аргументов, совместимых с POSIX.

**Click** призван быть интересным и настраиваемым, но не слишком гибким. Например, настраиваемость страниц справки ограничена. Это ограничение является преднамеренным, потому что **Click** обещает, что несколько экземпляров **Click** будут продолжать работать, как задумано, когда они связаны вместе.

Слишком большая настраиваемость нарушит это обещание.

**Click** был написан для поддержки экосистемы микрофреймворка [Flask](https://palletsprojects.com/p/flask/), потому что ни один инструмент не мог предоставить ей необходимую функциональность.

Чтобы понять, что такое **Click**, я настоятельно рекомендую изучить главу «[Комплексные приложения](kompleksnye-prilozheniya.md)».

## Почему не Argparse?

**Click** внутренне основан на **optparse**, а не на **argparse**. Это деталь реализации, о которой не нужно беспокоиться. **Click** не основан на **argparse**, потому что у него есть некоторые поведения, которые затрудняют обработку произвольных интерфейсов командной строки:

* **argparse** имеет встроенное поведение, позволяющее угадывать, является ли что-то аргументом или опцией. Это становится проблемой при работе с неполными командными строками; поведение становится непредсказуемым без полного знания командной строки. Это идет вразрез с амбициями **Click** по отправке информации субпарсерам.
* **argparse** не поддерживает отключение перемежающихся аргументов. Без этой функции невозможно безопасно реализовать вложенный синтаксический анализ **Click**.

## Почему не Docopt и т.д.?

**Docopt** и многие подобные ему инструменты хороши в том, как они работают, но очень немногие из этих инструментов имеют дело с вложением команд и компоновкой так, как **Click**. Насколько известно разработчику, **Click** - первая библиотека Python, цель которой - создать уровень компонуемости приложений, выходящий за рамки того, что поддерживает сама система.

**Docopt**, например, выполняет синтаксический анализ страниц справки, а затем выполняет синтаксический анализ в соответствии с этими правилами. Побочным эффектом этого является то, что **docopt** довольно жестко обрабатывает интерфейс командной строки. Преимущество **docopt** в том, что он дает вам полный контроль над страницей справки; обратной стороной является то, что из-за этого он не может переформатировать ваш вывод для текущей ширины терминала, и это затрудняет перевод. Кроме того, **docopt** ограничен базовым синтаксическим анализом. Он не обрабатывает отправку аргументов и вызов или типы обратного вызова. Это означает, что необходимо написать много кода в дополнение к основной странице справки для обработки результатов синтаксического анализа.

Однако, прежде всего, это затрудняет компоновку. Хотя **docopt** поддерживает отправку подкоманд, он, например, не поддерживает напрямую никаких видов автоматического перечисления подкоманд в зависимости от того, что доступно, или не заставляет подкоманды работать согласованным образом.

Это нормально, но отличается от того, как работает **Click**. **Click** нацелен на поддержку полностью составных пользовательских интерфейсов командной строки, выполнив следующие действия:

* **Click** не только выполняет синтаксический анализ, но и отправляет соответствующий код.
* **Click** имеет четкую концепцию контекста вызова, который позволяет подкомандам отвечать на данные из родительской команды.
* **Click** имеет надежную информацию, доступную для всех параметров и команд, поэтому он может создавать унифицированные страницы справки для полного интерфейса командной строки и помогать пользователю в преобразовании входных данных по мере необходимости.
* **Click** имеет четкое представление о том, какие типы бывают, и может выдавать пользователю постоянные сообщения об ошибках, если что-то пойдет не так. Подкоманда, написанная другим разработчиком, не исчезнет внезапно с другим сообщением об ошибке, потому что она обрабатывается вручную.
* **Click** имеет достаточно метаинформации, доступной для всей программы, чтобы со временем развиваться и улучшать взаимодействие с пользователем, не заставляя разработчиков корректировать свои программы. Например, если **Click** решит изменить формат страниц справки, все программы **Click** автоматически выиграют от этого.

Цель **Click** - создавать составные системы. Принимая во внимание, что цель **docopt** - создает самые красивые интерфейсы командной строки, созданные вручную. Эти две цели тонко противоречат друг другу. **Click** активно препятствует реализации людьми определенных шаблонов для достижения унифицированных интерфейсов командной строки. Например, у вас как разработчика очень мало возможностей для форматирования справочных страниц.

## Почему жестко запрограммированное поведение?

Другой вопрос: почему **Click** отказывается от **optparse** и жестко кодирует определенные поведения вместо того, чтобы оставаться настраиваемыми. Для этого есть несколько причин. Самая большая из них заключается в том, что слишком много возможностей настройки затрудняет достижение согласованного опыта работы с командной строкой.

Лучшим примером этого является функция **callback** обратного вызова **optparse** для приема произвольного количества аргументов. Из-за синтаксической неоднозначности в командной строке невозможно реализовать полностью вариативные аргументы. Всегда нужно идти на компромиссы, и в случае **argparse** эти компромиссы были достаточно критичными, так что такую систему, как **Click**, нельзя даже реализовать поверх нее.

В данном конкретном случае **Click** пытается придерживаться нескольких общепринятых парадигм для создания интерфейсов командной строки, которые можно хорошо задокументировать и протестировать.

## Почему нет автокоррекции?

Возник вопрос, почему **Click** не исправляет параметры автоматически, учитывая, что даже **optparse** и **argparse** поддерживают автоматическое расширение длинных аргументов. Причина в том, что это ответственность за обратную совместимость. Если люди начнут полагаться на автоматически изменяемые параметры, а в будущем кто-то добавит новый параметр, сценарий может перестать работать. Такого рода проблемы трудно найти, поэтому **Click** не пытается придавать этому значение.

Однако такое поведение может быть реализовано на более высоком уровне для поддержки таких вещей, как явные псевдонимы. Для получения дополнительной информации см. [Псевдонимы команд](rasshirennye-shablony-click.md#psevdonimy-komand).
