# Дополнительные темы

## Рендереры (Renderers)

Элементы из модуля **flask\_nav.elements** не имеют методов преобразования в HTML-код; эта функциональность размещена в классах **Renderer**. Они реализуют шаблон [Visitor](https://en.wikipedia.org/wiki/Visitor\_pattern) и позволяют указать множество способов преобразования вашей навигационной структуры в HTML.

Всякий раз, когда вызывается **flask\_nav.elements.NavigationItem.render ()**, он просто ищет желаемое средство визуализации и вызывает на себе метод **visit** средства визуализации. Результат возвращается как безопасная для разметки строка.

### Реализация пользовательских рендереров

В качестве примера мы собираемся создать новое средство визуализации, которое не использует ничего, кроме тегов `<div>` \[1]. **Flask-Nav** использует библиотеку [dominate](https://github.com/Knio/dominate/) для создания вывода HTML, который мы также используем здесь:

```python
from dominate import tags
from flask_nav.renderers import Renderer

class JustDivRenderer(Renderer):
    def visit_Navbar(self, node):
        sub = []
        for item in node.items:
            sub.append(self.visit(item))

        return tags.div('Navigation:', *sub)

    def visit_View(self, node):
        return tags.div('{} ({})'.format(node.title, node.get_url()))

    def visit_Subgroup(self, node):
        # почти так же, как visit_Navbar, но написано немного короче
        return tags.div(node.title,
                        *[self.visit(item) for item in node.items])
```

Теперь, когда у нас есть рендерер, нам нужно зарегистрировать его в приложении **app**. Это можно сделать внутри вашей функции **create\_app** (или где-то еще), вызвав регистр

```python
from flask_nav import register_renderer

def create_app():
    # [...]

    register_renderer(app, 'just_div', JustDivRenderer)
    return app
```

Теперь мы можем использовать его внутри шаблона:

```python
{{nav.top.render(renderer='just_div')}}
```

Если вы определяете свои пользовательские средства визуализации рядом с местом, где находится экземпляр расширения, вместо **register\_renderer** можно использовать декоратор **renderer ()**:

```python
@nav.renderer()
class JustDivRenderer(Renderer):
    pass  # ...

# при регистрации, 'just_div_renderer' будет зарегистрирован
```

## Элементы (Elements)

Любая навигационная структура состоит из элементов. Благодаря шаблону посетителя они могут быть любого класса, но стоит сделать так, чтобы все они происходили от **NavigationItem**.

Обычно панель навигации **Navbar** является объектом верхнего уровня панели навигации, но это не является обязательным требованием. Более того, если средство визуализации поддерживает это, любая часть структуры навигации может быть отрисована сама по себе, будь то отдельная ссылка или полное подменю.

### Пользовательские элементы

Иногда вам может потребоваться реализовать свои собственные классы **Element**. Это легко сделать путем создания подкласса либо **NavigationItem**, либо более конкретного класса (`get_auth_user` здесь является заполнителем для любого способа, которым ваша любимая структура аутентификации возвращает текущего пользователя):

```python
class UserGreeting(Text):
    def __init__(self):
        pass

    @property
    def text(self):
        return 'Hello, {}'.format('bob')
```

Обратите внимание, что при создании подкласса **NavigationItem** средства визуализации, скорее всего, не будут иметь метода визуализации по умолчанию. Создавая подклассы **Text** в этом примере, можно использовать существующие методы в средствах визуализации для текстового класса, поскольку посетители будут подниматься вверх по полной цепочке наследования, когда посетитель для текущего класса не может быть найден.

## Динамическая конструкция

В разделе «**Пользовательские элементы**» уже наблюдается небольшое динамическое поведение: приветствие меняется в зависимости от того, кто вошел в систему. Это не меняет структуру панели, поскольку внутри структуры всегда есть объект **UserGreeting**.

Чтобы создать динамический экземпляр панели навигации, просто передайте объект **callable ()** как функцию в **register\_element ()**:

```python
def top_nav():
    return Navbar(...)

nav.register_element('top_nav', top_nav)
```

Это обычный шаблон, поэтому доступен декоратор **navigation ()**:

```python
@nav.navigation
def top_nav():
    # ...
```

Функция **top\_nav ()** будет вызываться каждый раз, когда необходимо отобразить панель навигации. На этом этапе пользователь должен уже войти в систему, что позволяет, например, предоставить ему пункты меню, доступные только зарегистрированным пользователям.

Этот механизм также можно использовать для ленивого создания экземпляров навигационных панелей, если они дороги в настройке, но используются редко. Также возможно заранее создать нединамические части и просто скомпоновать их с динамическими экземплярами.

\[1] Это, вероятно, не очень хорошая идея, но действенный пример.
