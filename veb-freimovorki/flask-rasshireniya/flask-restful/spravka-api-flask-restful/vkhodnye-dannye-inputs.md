# Входные данные Inputs

## boolean

#### inputs.boolean(_value_)

Разбирает строку `"true"` или `"false"` как логическое значение (без учета регистра). Также принимает `«1»` и `«0»` как `True/False` (соответственно). Если входные данные получены из тела запроса JSON, тип уже является естественным логическим значением Python и будет передан без дальнейшего анализа.

## date

#### inputs.date(_value_)

Разбирает допустимую дату в формате YYYY-mm-dd

## datetime\_from\_iso8601

#### inputs.datetime\_from\_iso8601(_datetime\_str_)

Превращает дату в формате ISO8601 в объект даты и времени.

Пример:

```python
inputs.datetime_from_iso8601("2012-01-01T23:30:00+02:00")
```

#### Параметры:

* **datetime\_str** (_str_) - Строка, соответствующая ISO8601, для преобразования

**Возвращает**: datetime

## datetime\_from\_rfc822

#### inputs.datetime\_from\_rfc822(_datetime\_str_)

Превращает дату в формате RFC822 в объект datetime.

Пример:

```python
inputs.datetime_from_rfc822("Wed, 02 Oct 2002 08:00:00 EST")
```

#### Параметры:

* **datetime\_str** (_str_) - Строка, соответствующая RFC822, для преобразования

**Возвращает**: datetime

## int\_range

#### _class_ inputs.int\_range(_low_, _high_, _argument='argument'_)

Ограничить ввод целым числом в диапазоне (включительно)

## iso8601interval

#### inputs.iso8601interval(_value_, _argument='argument'_)

Разбирает интервалы даты и времени в формате ISO 8601 на кортежи дат и времени.

Принимает как одну дату (время), так и полный интервал, используя нотацию начала/конца или начала/длительности со следующим поведением:

* Интервалы определяются как инклюзивное начало, эксклюзивный конец
* Отдельные даты и время переводятся в интервал, охватывающий самое большое разрешение, не указанное во входном значении, вплоть до дня.
* Наименьшее принятое разрешение составляет 1 секунду.
* В качестве значений принимаются все часовые пояса; возвращаемые значения даты и времени локализованы в формате UTC. Наивные входные данные и ввод даты будут приниматься в формате UTC.

Примеры:

```python
"2013-01-01" -> datetime(2013, 1, 1), datetime(2013, 1, 2)
"2013-01-01T12" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 13)
"2013-01-01/2013-02-28" -> datetime(2013, 1, 1), datetime(2013, 2, 28)
"2013-01-01/P3D" -> datetime(2013, 1, 1), datetime(2013, 1, 4)
"2013-01-01T12:00/PT30M" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 12, 30)
"2013-01-01T06:00/2013-01-01T12:00" -> datetime(2013, 1, 1, 6), datetime(2013, 1, 1, 12)
```

#### Параметры:

* **value** (_str_) - Дата и время ISO8601 в виде строки

**Возвращает**: две даты и времени в формате UTC, начало и конец указанного интервала.

**Тип возвращаемого значения**: `tuple(datetime, datetime)`

**Поднимает**: **ValueError**, если интервал недействителен.

## natural

#### inputs.natural(_value_, _argument='argument'_)

Ограничивает тип ввода натуральными числами (0, 1, 2, 3…)

## positive

#### inputs.positive(_value_, _argument='argument'_)

Ограничивает тип ввода положительными целыми числами (1, 2, 3…)

## regex

#### _class_ inputs.regex(_pattern_, _flags=0_)

Проверка строки на основе регулярного выражения.

Пример:

```python
parser = reqparse.RequestParser()
parser.add_argument('example', type=inputs.regex('^[0-9]+$'))
```

Ввод аргумента примера будет отклонен, если он содержит что-либо, кроме чисел.

#### Параметры:

* **pattern** (_str_) - Регулярное выражение, которое должно соответствовать входным данным
* **flags** (_int_) - Флаги для изменения поведения выражения

## url

#### inputs.url(_value_)

Проверяет URL-адрес.

#### Параметры:

* **value** (_str_) - URL-адрес для проверки

**Возвращает**: URL-адрес, если он действителен.

**Поднимает**: ValueError
