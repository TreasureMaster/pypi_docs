# Несколько баз данных с привязками

Начиная с 0.12 Flask-SQLAlchemy может легко подключаться к нескольким базам данных. Для этого он предварительно настраивает SQLAlchemy для поддержки нескольких «привязок».

Что такое привязки? В языке SQLAlchemy привязка — это то, что может выполнять операторы SQL и обычно является соединением (_connection_) или движком (_engine_). В Flask-SQLAlchemy привязки всегда являются движками, которые автоматически создаются для вас за кулисами. Затем каждый из этих механизмов связывается с коротким ключом (ключом привязки). Затем этот ключ используется во время объявления модели для связывания модели с конкретным движком.

Если для модели не указан ключ привязки, вместо него используется соединение по умолчанию (как настроено `SQLALCHEMY_DATABASE_URI`).

### Пример конфигурации

Следующая конфигурация объявляет три подключения к базе данных. Специальный по умолчанию, а также два других именованных пользователя **users** (для пользователей) и **appmeta** (который подключается к базе данных **sqlite** для доступа только для чтения к некоторым данным, которые приложение предоставляет внутри):

```python
SQLALCHEMY_DATABASE_URI = 'postgres://localhost/main'
SQLALCHEMY_BINDS = {
    'users':        'mysqldb://localhost/users',
    'appmeta':      'sqlite:////path/to/appmeta.db'
}
```

### Создание и удаление таблиц

Методы <mark style="color:red;">create\_all()</mark> и <mark style="color:red;">drop\_all()</mark> по умолчанию работают со всеми объявленными привязками, включая привязку по умолчанию. Это поведение можно настроить, указав параметр привязки. Требуется либо одно имя привязки, `'__all__'` для ссылки на все привязки, либо список привязок. Связывание по умолчанию (`SQLALCHEMY_DATABASE_URI`) называется `None`:

```python
>>> db.create_all()
>>> db.create_all(bind=['users'])
>>> db.create_all(bind='appmeta')
>>> db.drop_all(bind=None)
```

### Ссылаясь на привязки

Если вы объявляете модель, вы можете указать привязку для использования с атрибутом \_\_**bind\_key\_\_**:

```python
class User(db.Model):
    __bind_key__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True)
```

Внутренне ключ привязки хранится в словаре **info** таблицы как `«bind_key»`. Это важно знать, потому что, когда вы хотите напрямую создать табличный объект, вам придется поместить его туда:

```python
user_favorites = db.Table('user_favorites',
    db.Column('user_id', db.Integer, db.ForeignKey('user.id')),
    db.Column('message_id', db.Integer, db.ForeignKey('message.id')),
    info={'bind_key': 'users'}
)
```

Если вы указали \_\_**bind\_key\_\_** в своих моделях, вы можете использовать их именно так, как вы привыкли. Модель сама подключается к указанному соединению с базой данных.
