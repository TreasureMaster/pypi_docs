# API Flask-SQLAlchemy

## Конфигурация

### SQLAlchemy

#### _class_ flask\_sqlalchemy.SQLAlchemy(_app=None_, _use\_native\_unicode=True_, _session\_options=None_, _metadata=None_, _query\_class=\<class 'flask\_sqlalchemy.BaseQuery'>_, _model\_class=\<class 'flask\_sqlalchemy.model.Model'>_, _engine\_options=None_)

Этот класс используется для управления интеграцией SQLAlchemy с одним или несколькими приложениями Flask. В зависимости от того, как вы инициализируете объект, его можно использовать сразу или при необходимости подключить к приложению Flask.

Есть два режима использования, которые работают очень похоже. Один из них привязывает экземпляр к очень конкретному приложению Flask:

```python
app = Flask(__name__)
db = SQLAlchemy(app)
```

Второй вариант — создать объект один раз, а затем настроить приложение для его поддержки:

```python
db = SQLAlchemy()

def create_app():
    app = Flask(__name__)
    db.init_app(app)
    return app
```

Разница между ними заключается в том, что в первом случае такие методы, как <mark style="color:red;">create\_all()</mark> и <mark style="color:red;">drop\_all()</mark>, будут работать постоянно, а во втором случае должен существовать [flask.Flask.app\_context()](https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.app\_context).

По умолчанию Flask-SQLAlchemy применяет некоторые настройки, специфичные для серверной части, чтобы улучшить работу с ними.

Начиная с **SQLAlchemy 0.6**, SQLAlchemy будет проверять библиотеку на предмет собственной поддержки Unicode. Если он обнаружит юникод, он позволит библиотеке обработать это, в противном случае сделает это сам. Иногда это обнаружение может дать сбой, и в этом случае вы можете установить для **use\_native\_unicode** (или ключа конфигурации `SQLALCHEMY_NATIVE_UNICODE`) значение `False`. Обратите внимание, что ключ конфигурации переопределяет значение, которое вы передаете конструктору. Прямая поддержка **use\_native\_unicode** и `SQLALCHEMY_NATIVE_UNICODE` устарела с версии 2.4 и будет удалена в версии 3.0. Вместо этого можно использовать **engine\_options** и `SQLALCHEMY_ENGINE_OPTIONS`.

Этот класс также обеспечивает доступ ко всем функциям и классам SQLAlchemy из модулей **sqlalchemy** и **sqlalchemy.orm**. Таким образом, вы можете объявить модели следующим образом:

```python
class User(db.Model):
    username = db.Column(db.String(80), unique=True)
    pw_hash = db.Column(db.String(80))
```

Вы по-прежнему можете использовать **sqlalchemy** и **sqlalchemy.orm** напрямую, но обратите внимание, что настройки Flask-SQLAlchemy доступны только через экземпляр этого класса [SQLAlchemy](api-flask-sqlalchemy.md#sqlalchemy). Классами запросов по умолчанию являются <mark style="color:red;">BaseQuery</mark> для `db.Query`, `db.Model.query_class` и `query_class` по умолчанию для `db.relationship` и `db.backref`. Если вы используете эти интерфейсы напрямую через **sqlalchemy** и **sqlalchemy.orm**, классом запроса по умолчанию будет класс **sqlalchemy**.

{% hint style="info" %}
**Тщательно проверяйте типы**

Не выполняйте проверки типа или экземпляра **instance** для **db.Table**, который эмулирует поведение **Table**, но не является классом. **db.Table** предоставляет интерфейс таблицы **Table**, но это функция, которая позволяет опускать метаданные.
{% endhint %}

Параметр session\_options, если он предоставлен, представляет собой набор параметров, которые необходимо передать конструктору сеанса. См. Сессия для стандартных опций.

Параметр engine\_options, если он указан, представляет собой набор параметров, которые необходимо передать для создания двигателя. См. create\_engine() для стандартных опций. Значения, указанные здесь, будут объединены и переопределяют все, что установлено в переменной конфигурации «SQLALCHEMY\_ENGINE\_OPTIONS» или иным образом установлено этой библиотекой.

Новое в версии 0.10: Добавлен параметр session\_options.

Новое в версии 0.16: scopefunc теперь принимается в session\_options. Это позволяет указать пользовательскую функцию, которая будет определять область действия сеанса SQLAlchemy.

Новое в версии 2.1: Добавлен параметр метаданных. Это позволяет устанавливать пользовательские соглашения об именах среди других нетривиальных вещей.

Параметр query\_class был добавлен, чтобы разрешить настройку класса запроса вместо значения по умолчанию BaseQuery.

Был добавлен параметр model\_class, который позволяет использовать пользовательский класс модели вместо Model.

Изменено в версии 2.1: используйте один и тот же класс запроса в сеансе, Model.query и Query.

Новое в версии 2.4: Добавлен параметр engine\_options.

Изменено в версии 2.4: Параметр use\_native\_unicode устарел.

Изменено в версии 2.4.3: COMMIT\_ON\_TEARDOWN устарел и будет удален в версии 3.1. Вместо этого вызовите db.session.commit() напрямую.

## Модели

## Сессии

## Утилиты
