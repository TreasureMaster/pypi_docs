# Шаблоны Flask

**Flask** использует **Jinja2** в качестве механизма шаблонов. Очевидно, что вы можете использовать другой механизм шаблонов, но вам все равно нужно установить **Jinja2** для запуска самого **Flask**. Это требование необходимо для включения многофункциональных расширений. Расширение может зависеть от присутствия **Jinja2**.

В этом разделе дается только очень быстрое введение в то, как **Jinja2** интегрируется во **Flask**. Если вам нужна информация о самом синтаксисе шаблонизатора, перейдите к [официальной документации по шаблонам Jinja2](../../../shablonizatory/jinja/dokumentaciya-po-konstruktoru-shablonov.md) для получения дополнительной информации.

## Установка Jinja

Если не настроено, **Jinja2** конфигурируется Flask'ом следующим образом:

* автоматическое экранирование включено для всех шаблонов, оканчивающихся на `.html`, `.htm`, `.xml`, а также `.xhtml` при использовании `render_template ()`.
* автоматическое экранирование включено для всех строк при использовании `render_template_string ()`.
* в шаблоне есть возможность включить / выключить автоматическое экранирование с помощью тега `{% autoescape %}`.
* **Flask** вставляет пару глобальных функций и помощников в контекст **Jinja2** в дополнение к значениям, которые присутствуют по умолчанию.

## Стандартный контекст

Следующие глобальные переменные доступны по умолчанию в шаблонах **Jinja2**:

### config

Текущий объект конфигурации (**flask.config**).

_Новое в версии 0.6_.

_Изменено в версии 0.10_: теперь это всегда доступно, даже в импортированных шаблонах.

### request

Текущий объект запроса (**flask.request**). Эта переменная недоступна, если шаблон был визуализирован без активного контекста запроса.

### session

Текущий объект сеанса (**flask.session**). Эта переменная недоступна, если шаблон был визуализирован без активного контекста запроса.

### g

Объект с привязкой к запросу для глобальных переменных (**flask.g**). Эта переменная недоступна, если шаблон был визуализирован без активного контекста запроса.

### url\_for ()

Функция **flask.url\_for ()**.

### get\_flashed\_messages ()

Функция **flask.get\_flashed\_messages ()**.

{% hint style="info" %}
**Поведение в контексте Jinja:**

Эти переменные добавляются в контекст переменных, они не являются глобальными переменными. Разница в том, что по умолчанию они не отображаются в контексте импортированных шаблонов. Частично это вызвано соображениями производительности, частично для ясности.

Что это значит для вас? Если у вас есть макрос, который вы хотите импортировать, он должен получить доступ к объекту запроса, у вас есть две возможности:

1. вы явно передаете запрос макросу как параметр или атрибут интересующего вас объекта запроса.
2. вы импортируете макрос «с контекстом».

Импорт с контекстом выглядит так:

```python
{% raw %}
{% from '_helpers.html' import my_macro with context %}
{% endraw %}
```
{% endhint %}

## Стандартные фильтры

**Flask** предоставляет следующие фильтры **Jinja2** в дополнение к фильтрам, предоставляемым самим **Jinja2**:

### tojson ()

Эта функция преобразует данный объект в представление **JSON**. Это, например, очень полезно, если вы пытаетесь генерировать **JavaScript** "на лету".

```markup
<script type=text/javascript>
    doSomethingWith({{ user.username|tojson }});
</script>
```

Также безопасно использовать вывод `|tojson` в атрибуте HTML в **одинарных** кавычках:

```markup
<button onclick='doSomethingWith({{ user.username|tojson }})'>
    Click me
</button>
```

Обратите внимание, что в версиях **Flask** до `0.10` при использовании вывода `|tojson` внутри _**script**_ обязательно отключите экранирование с помощью `|safe`. Во `Flask 0.10` и выше это происходит автоматически.

## Управление автоматическим экранированием

Автоэкранирование - это концепция автоматического экранирования специальных символов для вас. Специальными символами в смысле HTML (или XML, и, следовательно, XHTML) являются `&`, `>`, `<`, `"`, а также `'`. Поскольку эти символы несут в документах определенные значения сами по себе, вы должны заменить их так называемыми "сущностями", если вы хотите использовать их для текста. Невыполнение этого требования не только вызовет разочарование пользователя из-за невозможности использовать эти символы в тексте, но также может привести к проблемам безопасности (см. Межсайтовый скриптинг (XSS))

Однако иногда вам может потребоваться отключить автоматическое экранирование в шаблонах. Это может произойти, если вы хотите явно внедрить HTML в страницы, например, если они поступают из системы, которая генерирует безопасный HTML, такой как конвертер markdown в HTML.

Для этого есть три способа:

* В коде Python оберните строку HTML в объект **Markup** перед ее передачей в шаблон. Обычно это рекомендуемый способ.
* Внутри шаблона используйте фильтр `|safe`, чтобы явно пометить строку как безопасный HTML (`{{ myvariable|safe }}`)
* Временно полностью отключите систему автоматического экранирования.

Чтобы отключить систему автоматического экранирования в шаблонах, вы можете использовать блок `{% autoescape %}`

```python
{% raw %}
{% autoescape false %}
    <p>autoescaping is disabled here
    <p>{{ will_not_be_escaped }}
{% endautoescape %}
{% endraw %}
```

Когда вы это делаете, будьте очень осторожны с переменными, которые вы используете в этом блоке.

## Регистрация фильтров

Если вы хотите зарегистрировать свои собственные фильтры в **Jinja2**, у вас есть два способа сделать это. Вы можете поместить их вручную в **jinja\_env** приложения или использовать декоратор **template\_filter ()**.

Два следующих примера работают одинаково и оба обращают объект в обратную сторону:

```python
@app.template_filter('reverse')
def reverse_filter(s):
    return s[::-1]

def reverse_filter(s):
    return s[::-1]
app.jinja_env.filters['reverse'] = reverse_filter
```

В случае декоратора аргумент является необязательным, если вы хотите использовать имя функции в качестве имени фильтра. После регистрации вы можете использовать фильтр в своих шаблонах так же, как встроенные фильтры **Jinja2**, например, если у вас есть список Python в контексте с именем _**mylist**_:

```python
{% raw %}
{% for x in mylist | reverse %}
{% endfor %}
{% endraw %}
```

## Процессоры контекста

Для автоматического добавления новых переменных в контекст шаблона во **Flask** существуют контекстные процессоры. Процессоры контекста запускаются до того, как шаблон будет отрисован, и могут вводить новые значения в контекст шаблона. Обработчик контекста - это функция, возвращающая словарь. Затем ключи и значения этого словаря объединяются с контекстом шаблона для всех шаблонов в приложении:

```python
@app.context_processor
def inject_user():
    return dict(user=g.user)
```

Вышеупомянутый процессор контекста делает переменную с именем **user** доступной в шаблоне со значением **g.user**. Этот пример не очень интересен, потому что **g** в любом случае доступен в шаблонах, но он дает представление о том, как это работает.

Переменные не ограничиваются значениями; процессор контекста также может делать функции доступными для шаблонов (поскольку Python позволяет передавать функции):

```python
@app.context_processor
def utility_processor():
    def format_price(amount, currency=u'€'):
        return u'{0:.2f}{1}'.format(amount, currency)
    return dict(format_price=format_price)
```

Вышеупомянутый обработчик контекста делает функцию **format\_price** доступной для всех шаблонов:

```python
{{ format_price(0.33) }}
```

Вы также можете создать **format\_price** как шаблонный фильтр (см. [регистрация фильтров](shablony-flask.md#registraciya-filtrov)), но это демонстрирует, как передавать функции в обработчик контекста.
