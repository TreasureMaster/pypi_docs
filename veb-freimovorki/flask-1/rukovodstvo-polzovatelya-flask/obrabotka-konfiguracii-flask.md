# Обработка конфигурации Flask

Приложениям нужна какая-то конфигурация. Существуют различные настройки, которые вы можете захотеть изменить в зависимости от среды приложения, например, переключение режима отладки, установка секретного ключа и другие подобные вещи, зависящие от среды.

Способ разработки **Flask** обычно требует, чтобы конфигурация была доступна при запуске приложения. Вы можете жестко закодировать конфигурацию в коде, что для многих небольших приложений на самом деле не так уж и плохо, но есть способы лучше.

Независимо от того, как вы загружаете свою конфигурацию, доступен объект конфигурации, который содержит загруженные значения конфигурации: атрибут [config](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#config) объекта [Flask](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#klass-flask-flask). Это место, куда сам **Flask** помещает определенные значения конфигурации, а также куда расширения могут помещать свои значения конфигурации. Но здесь вы также можете иметь свою собственную конфигурацию.

## Основы конфигурации

[config](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#config) фактически является подклассом словаря и может быть изменен так же, как любой словарь:

```python
app = Flask(__name__)
app.config['TESTING'] = True
```

Некоторые значения конфигурации также пересылаются объекту [Flask](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#klass-flask-flask), чтобы вы могли читать и записывать их оттуда:

```python
app.testing = True
```

Чтобы обновить сразу несколько ключей, вы можете использовать метод [dict.update ()](https://docs.python.org/3/library/stdtypes.html#dict.update):

```python
app.config.update(
    TESTING=True,
    SECRET_KEY=b'_5#y2L"F4Q8z\n\xec]/'
)
```

## Возможности среды и отладки

Значения конфигурации [ENV](obrabotka-konfiguracii-flask.md#env) и [DEBUG](obrabotka-konfiguracii-flask.md#debug) являются особенными, поскольку они могут вести себя непоследовательно, если их изменить после того, как приложение начало настройку. Чтобы надежно настроить среду и режим отладки, **Flask** использует переменные среды.

Среда окружения используется, чтобы указать **Flask**, расширениям и другим программам, таким как **Sentry**, в каком контексте работает **Flask**. Она управляется переменной среды **FLASK\_ENV** и по умолчанию установлена на **production**.

Установка **FLASK\_ENV** в **development** включит режим отладки. `flask run` по умолчанию будет использовать интерактивный отладчик и перезагрузчик в режиме отладки. Чтобы управлять этим отдельно от среды, используйте флаг **FLASK\_DEBUG**.

_Изменено в версии 1.0_: Добавлен **FLASK\_ENV** для управления средой отдельно от режима отладки. Среда разработки включает режим отладки.

Чтобы переключить **Flask** в среду разработки и включить режим отладки, установите **FLASK\_ENV**:

```bash
$ export FLASK_ENV=development
$ flask run
```

(В Windows используйте **set** вместо **export**.)

Рекомендуется использовать переменные среды, как описано выше. Хотя в вашей конфигурации или коде можно установить **ENV** и **DEBUG**, это настоятельно не рекомендуется. Они не могут быть прочитаны командой **flask** на раннем этапе, и некоторые системы или расширения могут уже настроиться на основе предыдущего значения.

## Встроенные значения конфигурации

Следующие значения конфигурации используются внутри **Flask**:

### ENV

Определяет, в какой среде работает приложение. **Flask** и расширения могут включать поведение в зависимости от среды, например включение режима отладки. Атрибут [env](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#env) сопоставляется с этим ключом конфигурации. Это устанавливается переменной среды **FLASK\_ENV** и может вести себя не так, как ожидалось, если установлено в коде.

{% hint style="warning" %}
Не включайте **development** при развертывании в производственной среде.
{% endhint %}

По умолчанию: `'production'`

_Новое в версии 1.0_.

### DEBUG

Включен ли режим отладки. При использовании `flask run` для запуска сервера разработки интерактивный отладчик будет отображаться для необработанных исключений, и сервер будет перезагружен при изменении кода. Атрибут [debug](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#svoistvo-debug) сопоставляется с этим ключом конфигурации. Это включено, когда **ENV** является `'development'`, и переопределяется переменной среды **FLASK\_DEBUG**. Он может вести себя не так, как ожидалось, если установлен в коде.

{% hint style="warning" %}
Не включайте режим **debug** при развертывании в производственной среде.
{% endhint %}

По умолчанию: `True`, если **ENV** - `'development'`, или `False` в противном случае.

### TESTING

Включает режим тестирования. Исключения распространяются, а не обрабатываются обработчиками ошибок приложения. Расширения также могут изменять свое поведение, чтобы облегчить тестирование. Вы должны включить это в своих собственных тестах.

По умолчанию: `False`

### PROPAGATE\_EXCEPTIONS

Исключения возникают повторно, а не обрабатываются обработчиками ошибок приложения. Если не установлен, это неявно верно, если включены **TESTING** или **DEBUG**.

По умолчанию: `None`

### &#x20;PRESERVE\_CONTEXT\_ON\_EXCEPTION

Не выдает контекст запроса при возникновении исключения. Если не установлен, это верно, если **DEBUG** истинно. Это позволяет отладчикам анализировать данные запроса на предмет ошибок и, как правило, не требует установки напрямую.

По умолчанию: `None`

### &#x20;TRAP\_HTTP\_EXCEPTIONS

Если нет обработчика для исключения типа **HTTPException**, повторно вызывает его для обработки интерактивным отладчиком вместо того, чтобы возвращать его как простой ответ об ошибке.

По умолчанию: `None`

### &#x20;SECRET\_KEY

Секретный ключ, который будет использоваться для безопасной подписи файла **cookie** сеанса и может использоваться для любых других потребностей, связанных с безопасностью, расширениями или вашим приложением. Это должна быть длинная случайная строка байтов, хотя допускается и юникод. Например, скопируйте вывод этого в свою конфигурацию:

```bash
$ python -c 'import os; print(os.urandom(16))'
b'_5#y2L"F4Q8z\n\xec]/'
```

{% hint style="warning" %}
Не раскрывайте секретный ключ при публикации вопросов или фиксации кода.
{% endhint %}

По умолчанию: `None`

### SESSION\_COOKIE\_NAME

Имя файла **cookie** сеанса. Можно изменить, если у вас уже есть файл **cookie** с таким именем.

По умолчанию: `'session'`

### SESSION\_COOKIE\_DOMAIN

Правило сопоставления домена, для которого будет действителен файл **cookie** сеанса. Если не установлен, **cookie** будет действителен для всех поддоменов [SERVER\_NAME](obrabotka-konfiguracii-flask.md#server\_name). Если `False`, домен **cookie** не будет установлен.

По умолчанию: `None`

### SESSION\_COOKIE\_PATH

Путь, для которого будет действителен файл **cookie** сеанса. Если не установлен, **cookie** будет действителен под **APPLICATION\_ROOT** или `/`, если он не установлен.

По умолчанию: `None`

### SESSION\_COOKIE\_HTTPONLY

Браузеры не разрешают **JavaScript** доступ к файлам **cookie**, помеченным как «только HTTP» в целях безопасности.

По умолчанию: `True`

### SESSION\_COOKIE\_SECURE

Браузеры будут отправлять файлы **cookie** с запросами через **HTTPS**, только если файл **cookie** помечен как `«secure»`. Чтобы это имело смысл, приложение должно обслуживаться по **HTTPS**.

По умолчанию: `False`

### SESSION\_COOKIE\_SAMESITE

Ограничивает отправку файлов **cookie** с запросами с внешних сайтов. Может быть установлен на `«Lax»` (рекомендуется) или `«Strict»`. См. [параметры Set-Cookie](../dopolnitelnye-primechaniya-flask/soobrazheniya-bezopasnosti-flask.md#parametry-set-cookie).

По умолчанию: `None`

_Новое в версии 1.0_.

### PERMANENT\_SESSION\_LIFETIME

Если для `session.permanent` задано значение `True`, срок действия **cookie** будет установлен на это количество секунд в будущем. Может быть [datetime.timedelta](https://docs.python.org/3/library/datetime.html#datetime.timedelta) или **int**.

Реализация файлов **cookie** по умолчанию в **Flask** проверяет, что криптографическая подпись не старше этого значения.

По умолчанию: `timedelta (days = 31)` (`2678400` секунд)

### SESSION\_REFRESH\_EACH\_REQUEST

Контролирует, будет ли **cookie** отправляться с каждым ответом, если `session.permanent` имеет значение `True`. Отправка файла **cookie** каждый раз (по умолчанию) может более надежно предотвратить истечение срока сеанса, но использует большую пропускную способность. Непостоянные сеансы не затрагиваются.

По умолчанию: `True`

### USE\_X\_SENDFILE

При обслуживании файлов установите заголовок **X-Sendfile** вместо передачи данных с помощью **Flask**. Некоторые веб-серверы, такие как **Apache**, распознают это и более эффективно обрабатывают данные. Это имеет смысл только при использовании такого сервера.

По умолчанию: `False`

### SEND\_FILE\_MAX\_AGE\_DEFAULT

При обслуживании файлов установите максимальный возраст элемента управления кешем на это количество секунд. Может быть [datetime.timedelta](https://docs.python.org/3/library/datetime.html#datetime.timedelta) или **int**. Переопределите это значение для каждого файла, используя [get\_send\_file\_max\_age ()](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#get\_send\_file\_max\_age) в приложении или чертеже.

По умолчанию: `timedelta (hours = 12)` (`43200` секунд)

### SERVER\_NAME

Сообщите приложению, к какому хосту и порту оно привязано. Требуется для поддержки сопоставления маршрутов поддоменов.

Если установлено, будет использоваться для домена **cookie** сеанса, если [SESSION\_COOKIE\_DOMAIN](obrabotka-konfiguracii-flask.md#session\_cookie\_domain) не установлен. Современные веб-браузеры не позволяют устанавливать файлы **cookie** для доменов без точки. Чтобы использовать домен локально, добавьте любые имена, которые должны направлять приложение в файл **hosts**.

```bash
127.0.0.1 localhost.dev
```

Если установлено, **url\_for** может генерировать внешние URL-адреса только с контекстом приложения, а не с контекстом запроса.

По умолчанию: `None`

### APPLICATION\_ROOT

Сообщает приложению, по какому пути оно смонтировано приложением / веб-сервером. Это используется для генерации URL-адресов вне контекста запроса (внутри запроса диспетчер вместо этого отвечает за установку **SCRIPT\_NAME**; см. «[Диспетчеризация приложений](../patterny-flask/#dispetcherizaciya-prilozhenii)» для примеров конфигурации диспетчеризации).

Будет использоваться для пути **cookie** сеанса, если **SESSION\_COOKIE\_PATH** не установлен.

По умолчанию: `'/'`

### PREFERRED\_URL\_SCHEME

Используйте эту схему для создания внешних URL-адресов, когда они не находятся в контексте запроса.

По умолчанию: `'http'`

### MAX\_CONTENT\_LENGTH

Не считывает больше этого количества байтов из данных входящего запроса. Если не установлен и в запросе не указано **CONTENT\_LENGTH**, данные не будут считаны в целях безопасности.

По умолчанию: `None`

### JSON\_TO\_ASCII

Сериализует объекты в кодировке ASCII **JSON**. Если это отключено, **JSON** будет возвращен как строка **Unicode** или закодирован как **UTF-8** с помощью **jsonify**. Это влияет на безопасность при рендеринге **JSON** в **JavaScript** в шаблонах и обычно должно оставаться включенным.

По умолчанию: `True`

### JSON\_SORT\_KEYS

Сортирует ключи объектов **JSON** по алфавиту. Это полезно для кэширования, потому что обеспечивает одинаковую сериализацию данных независимо от того, какой хэш-код Python используется. Хотя это не рекомендуется, вы можете отключить это для возможного повышения производительности за счет кеширования.

По умолчанию: `True`

### JSONIFY\_PRETTYPRINT\_REGULAR

Ответы **jsonify** будут выводиться с символами новой строки, пробелами и отступами для облегчения чтения людьми. Всегда включен в режиме отладки.

По умолчанию: `False`

### JSONIFY\_MIMETYPE

Тип **mimetype** ответов **jsonify**.

По умолчанию: `'application/json'`

### TEMPLATES\_AUTO\_RELOAD

Обновляет шаблоны при их изменении. Если не установлен, он будет включен в режиме отладки.

По умолчанию: `None`

### EXPLAIN\_TEMPLATE\_LOADING

Записывает отладочную информацию, отслеживая, как был загружен файл шаблона. Это может быть полезно, чтобы выяснить, почему шаблон не был загружен или кажется, что загружен не тот файл.

По умолчанию: `False`

### MAX\_COOKIE\_SIZE

Предупреждает, если заголовки файлов **cookie** превышают указанное количество байтов. По умолчанию - `4093`. Большие файлы **cookie** могут игнорироваться браузерами. Установите `0`, чтобы отключить предупреждение.

### Журнал изменений

_Изменено в версии 1.0_: **LOGGER\_NAME** и **LOGGER\_HANDLER\_POLICY** были удалены. См. [ведение журнала](logging-flask.md) для получения информации о конфигурации.

Добавлен [**ENV**](obrabotka-konfiguracii-flask.md#env) для отражения переменной среды **FLASK\_ENV**.

Добавлен [SESSION\_COOKIE\_SAMESITE](obrabotka-konfiguracii-flask.md#session\_cookie\_samesite) для управления параметром **SameSite** файла **cookie** сеанса.

Добавлен [MAX\_COOKIE\_SIZE](obrabotka-konfiguracii-flask.md#max\_cookie\_size) для управления предупреждением от **Werkzeug**.

_Новое в версии 0.11_: **SESSION\_REFRESH\_EACH\_REQUEST**, **TEMPLATES\_AUTO\_RELOAD**, **LOGGER\_HANDLER\_POLICY**, **EXPLAIN\_TEMPLATE\_LOADING**

_Новое в версии 0.10_: **JSON\_AS\_ASCII**, **JSON\_SORT\_KEYS**, **JSONIFY\_PRETTYPRINT\_REGULAR**

_Новое в версии 0.9_: **PREFERRED\_URL\_SCHEME**

_Новое в версии 0.8_: **TRAP\_BAD\_REQUEST\_ERRORS**, **TRAP\_HTTP\_EXCEPTIONS**, **APPLICATION\_ROOT**, **SESSION\_COOKIE\_DOMAIN**, **SESSION\_COOKIE\_PATH**, **SESSION\_COOKIE\_HTTPONLY**, **SESSION\_COOKIE\_SECURE**

_Новое в версии 0.7:_ **PROPAGATE\_EXCEPTIONS**, **PRESERVE\_CONTEXT\_ON\_EXCEPTION**

_Новое в версии 0.6:_ **MAX\_CONTENT\_LENGTH**

_Новое в версии 0.5:_ **SERVER\_NAME**

_Новое в версии 0.4:_ **LOGGER\_NAME**

## Конфигурирование из файла

Конфигурация становится более полезной, если вы можете сохранить ее в отдельном файле, идеально расположенном вне фактического пакета приложения. Это делает возможным упаковывать и распространять ваше приложение с помощью различных инструментов обработки пакетов ([развертывание с помощью Setuptools](../patterny-flask/#razvertyvanie-s-pomoshyu-setuptools)) и, наконец, изменять файл конфигурации впоследствии.

Итак, общий образец таков:

```python
app = Flask(__name__)
app.config.from_object('yourapplication.default_settings')
app.config.from_envvar('YOURAPPLICATION_SETTINGS')
```

Сначала загружается конфигурация из модуля `yourapplication.default_settings`, а затем значения заменяются содержимым файла, на который указывает переменная среды **YOURAPPLICATION\_SETTINGS**. Эту переменную среды можно установить в Linux или OS X с помощью команды **export** в оболочке перед запуском сервера:

```bash
$ export YOURAPPLICATION_SETTINGS=/path/to/settings.cfg
$ python run-app.py
 * Running on http://127.0.0.1:5000/
 * Restarting with reloader...
```

В системах Windows используйте вместо этого встроенный **set**:

```bash
> set YOURAPPLICATION_SETTINGS=\path\to\settings.cfg
```

Сами файлы конфигурации являются собственно файлами Python. Позже в объекте конфигурации фактически сохраняются только значения в верхнем регистре. Поэтому обязательно используйте прописные буквы для ключей конфигурации.

Вот пример файла конфигурации:

```python
# Пример конфигурации
DEBUG = False
SECRET_KEY = b'_5#y2L"F4Q8z\n\xec]/'
```

Убедитесь, что вы загрузили конфигурацию как можно раньше, чтобы расширения имели возможность доступа к конфигурации при запуске. Есть и другие методы для объекта конфигурации для загрузки из отдельных файлов. Для полной справки прочтите документацию по объекту [Config](../api-dokumentaciya-flask/konfigurirovanie-flask.md#klass-flask-config).

## Конфигурирование из переменных среды

В дополнение к указанию на файлы конфигурации с помощью переменных среды вам может быть полезно (или необходимо) управлять значениями конфигурации непосредственно из среды.

Переменные среды могут быть установлены в Linux или OS X с помощью команды **export** в оболочке перед запуском сервера:

```bash
$ export SECRET_KEY='5f352379324c22463451387a0aec5d2f'
$ export MAIL_ENABLED=false
$ python run-app.py
 * Running on http://127.0.0.1:5000/
```

В системах Windows используйте вместо этого встроенный **set**:

```bash
> set SECRET_KEY='5f352379324c22463451387a0aec5d2f'
```

Хотя этот подход прост в использовании, важно помнить, что переменные среды являются строками - они не десериализуются автоматически в типы Python.

Вот пример файла конфигурации, в котором используются переменные среды:

```python
import os

_mail_enabled = os.environ.get("MAIL_ENABLED", default="true")
MAIL_ENABLED = _mail_enabled.lower() in {"1", "t", "true"}

SECRET_KEY = os.environ.get("SECRET_KEY")

if not SECRET_KEY:
    raise ValueError("No SECRET_KEY set for Flask application")
```

Обратите внимание, что любое значение, кроме пустой строки, будет интерпретироваться как логическое значение `True` в Python, что требует осторожности, если среда явно устанавливает значения, предназначенные для `False`.

Убедитесь, что вы загрузили конфигурацию как можно раньше, чтобы расширения имели возможность доступа к конфигурации при запуске. Есть и другие методы для объекта конфигурации для загрузки из отдельных файлов. Для получения полной справки прочтите документацию класса [Config](../api-dokumentaciya-flask/konfigurirovanie-flask.md#klass-flask-config).

## Рекомендации по настройке

Обратной стороной упомянутого ранее подхода является то, что он немного усложняет тестирование. В целом не существует единого 100% решения этой проблемы, но есть несколько вещей, которые вы можете иметь в виду, чтобы улучшить этот опыт:

1. Создайте свое приложение в функции и зарегистрируйте в нем **blueprints**. Таким образом, вы можете создать несколько экземпляров своего приложения с разными подключенными конфигурациями, что значительно упростит модульное тестирование. Вы можете использовать это для передачи конфигурации по мере необходимости.
2. Не пишите код, который требует настройки во время импорта. Если вы ограничиваете себя доступом к конфигурации только по запросу, вы можете позже перенастроить объект по мере необходимости.

## Разработка / Производство

Большинству приложений требуется более одной конфигурации. Должны быть как минимум отдельные конфигурации для рабочего сервера и сервера, используемого во время разработки. Самый простой способ справиться с этим - использовать конфигурацию по умолчанию, которая всегда загружается и является частью управления версиями, и отдельную конфигурацию, которая переопределяет значения по мере необходимости, как упомянуто в примере выше:

```python
app = Flask(__name__)
app.config.from_object('yourapplication.default_settings')
app.config.from_envvar('YOURAPPLICATION_SETTINGS')
```

Затем вам просто нужно добавить отдельный файл `config.py` и экспортировать `YOURAPPLICATION_SETTINGS = /path/to/config.py`, и все готово. Однако есть и альтернативные способы. Например, вы можете использовать импорт или создание подклассов.

Что очень популярно в мире **Django**, так это сделать импорт явным в файле конфигурации, добавив `from yourapplication.default_settings import *` в начало файла, а затем переопределив изменения вручную. Вы также можете проверить переменную среды, такую как **YOURAPPLICATION\_MODE**, и установить ее для производства, разработки и т.д. и импортировать различные жестко закодированные файлы на основе этого.

Интересным шаблоном также является использование классов и наследования для настройки:

```python
class Config(object):
    DEBUG = False
    TESTING = False
    DATABASE_URI = 'sqlite:///:memory:'

class ProductionConfig(Config):
    DATABASE_URI = 'mysql://user@localhost/foo'

class DevelopmentConfig(Config):
    DEBUG = True

class TestingConfig(Config):
    TESTING = True
```

Чтобы включить такую конфигурацию, вам просто нужно вызвать [from\_object ()](../api-dokumentaciya-flask/konfigurirovanie-flask.md#from\_object):

```python
app.config.from_object('configmodule.ProductionConfig')
```

Обратите внимание, что [from\_object ()](../api-dokumentaciya-flask/konfigurirovanie-flask.md#from\_object) не создает экземпляр объекта класса. Если вам нужно создать экземпляр класса, например, для доступа к свойству, вы должны сделать это перед вызовом **from\_object ()**:

```python
from configmodule import ProductionConfig
app.config.from_object(ProductionConfig())

# В качестве альтернативы импортируйте через строку:
from werkzeug.utils import import_string
cfg = import_string('configmodule.ProductionConfig')()
app.config.from_object(cfg)
```

Создание экземпляра объекта конфигурации позволяет использовать `@property` в классах конфигурации:

```python
class Config(object):
    """Базовая конфигурация, использует промежуточный сервер базы данных."""
    DEBUG = False
    TESTING = False
    DB_SERVER = '192.168.1.56'

    @property
    def DATABASE_URI(self):         # Примечание: все заглавные буквы
        return 'mysql://user@{}/foo'.format(self.DB_SERVER)

class ProductionConfig(Config):
    """Использует сервер производственной базы данных."""
    DB_SERVER = '192.168.19.32'

class DevelopmentConfig(Config):
    DB_SERVER = 'localhost'
    DEBUG = True

class TestingConfig(Config):
    DB_SERVER = 'localhost'
    DEBUG = True
    DATABASE_URI = 'sqlite:///:memory:'
```

Есть много разных способов, и вам решать, как вы хотите управлять своими файлами конфигурации. Однако вот список хороших рекомендаций:

* Сохраните конфигурацию по умолчанию в системе контроля версий. Либо заполните конфигурацию этой конфигурацией по умолчанию, либо импортируйте ее в свои собственные файлы конфигурации перед заменой значений.
* Используйте переменную среды для переключения между конфигурациями. Это можно сделать извне интерпретатора Python, что значительно упрощает разработку и развертывание, поскольку вы можете быстро и легко переключаться между разными конфигурациями, не касаясь кода вообще. Если вы часто работаете над разными проектами, вы даже можете создать свой собственный скрипт для поиска, который активирует virtualenv и экспортирует конфигурацию разработки за вас.
* Используйте такой инструмент, как [fabric](https://www.fabfile.org/), в производственной среде, чтобы передавать код и конфигурации отдельно на производственные серверы. Для получения некоторых подробностей о том, как это сделать, перейдите к шаблону [развертывание с Fabric](../patterny-flask/#razvertyvanie-s-pomoshyu-fabric).

## Папки экземпляров

_Новое в версии 0.8_.

`Flask 0.8` представляет папки экземпляров. **Flask** долгое время позволял напрямую обращаться к путям относительно папки приложения (через `Flask.root_path`). Это также было тем, сколько разработчиков загрузили конфигурации, хранящиеся рядом с приложением. К сожалению, это работает только в том случае, если приложения не являются пакетами. В этом случае корневой путь относится к содержимому пакета.

В `Flask 0.8` был введен новый атрибут: `Flask.instance_path`. Это относится к новой концепции, называемой «папка экземпляра». Папка экземпляра разработана таким образом, чтобы не находиться под контролем версий и зависеть от развертывания. Это идеальное место для хранения вещей, которые изменяются во время выполнения или в файлах конфигурации.

Вы можете либо явно указать путь к папке экземпляра при создании приложения **Flask**, либо позволить **Flask** автоматически определять папку экземпляра. Для явной настройки используйте параметр **instance\_path**:

```python
app = Flask(__name__, instance_path='/path/to/instance/folder')
```

Помните, что этот путь **должен** быть абсолютным.

Если параметр **instance\_path** не указан, используются следующие местоположения по умолчанию:

* Неустановленный модуль:

```bash
/myapp.py
/instance
```

* Неустановленный пакет:

```bash
/myapp
    /__init__.py
/instance
```

Установленный модуль или пакет:

```bash
$PREFIX/lib/python2.X/site-packages/myapp
$PREFIX/var/myapp-instance
```

**$PREFIX** - это префикс вашей установки Python. Это может быть `/usr` или путь к вашему **virtualenv**. Вы можете распечатать значение `sys.prefix`, чтобы увидеть, какой префикс установлен.

Поскольку объект конфигурации обеспечивает загрузку файлов конфигурации с относительными именами файлов, мы сделали возможным изменить загрузку с помощью имен файлов, чтобы они относились к пути экземпляра, если это необходимо. Поведение относительных путей в файлах конфигурации можно переключать между «относительно корня приложения» (по умолчанию) и «относительно папки экземпляра» с помощью переключателя **instance\_relative\_config** в конструкторе приложения:

```python
app = Flask(__name__, instance_relative_config=True)
```

Вот полный пример того, как настроить **Flask** для предварительной загрузки конфигурации из модуля, а затем переопределения конфигурации из файла в папке экземпляра, если он существует:

```python
app = Flask(__name__, instance_relative_config=True)
app.config.from_object('yourapplication.default_settings')
app.config.from_pyfile('application.cfg', silent=True)
```

Путь к папке экземпляра можно найти через `Flask.instance_path`. **Flask** также предоставляет ярлык для открытия файла из папки экземпляра с помощью `Flask.open_instance_resource ()`.

Пример использования обоих:

```python
filename = os.path.join(app.instance_path, 'application.cfg')
with open(filename) as f:
    config = f.read()

# или через open_instance_resource:
with app.open_instance_resource('application.cfg') as f:
    config = f.read()
```
