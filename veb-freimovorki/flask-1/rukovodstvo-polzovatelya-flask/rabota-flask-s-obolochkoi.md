# Работа Flask с оболочкой

_Новое в версии 0.3_.

Одна из причин, по которой все любят Python, - интерактивная оболочка. Это в основном позволяет вам выполнять команды Python в реальном времени и сразу же получать результаты. Сам **Flask** не поставляется с интерактивной оболочкой, потому что он не требует какой-либо предварительной настройки, просто импортируйте свое приложение и начните играть.

Однако есть несколько удобных помощников, которые сделают игру в оболочке более приятной. Основная проблема сеансов интерактивной консоли заключается в том, что вы не запускаете запрос, как браузер, а это означает, что [g](../api-dokumentaciya-flask/globalnyi-obekt-prilozheniya-flask.md#flask-g), [request](../api-dokumentaciya-flask/dannye-vkhodyashego-zaprosa-request.md#flask-request) и другие недоступны. Но код, который вы хотите протестировать, может зависеть от них, так что же вы можете сделать?

Вот здесь и пригодятся некоторые вспомогательные функции. Однако имейте в виду, что эти функции предназначены не только для интерактивного использования оболочки, но и для модульного тестирования и других ситуаций, требующих ложного контекста запроса.

Обычно рекомендуется сначала прочитать главу "[Контекст запроса](kontekst-zaprosa-flask.md)" документации.

## Интерфейс командной строки

Начиная с `Flask 0.11` рекомендуемый способ работы с оболочкой - это команда `flask shell`, которая выполняет большую часть этого автоматически за вас. Например, оболочка автоматически инициализируется загруженным контекстом приложения.

Для получения дополнительной информации см. [Интерфейс командной строки](interfeis-komandnoi-stroki-flask.md).

## Создание контекста запроса

Самый простой способ создать правильный контекст запроса из оболочки - использовать метод [test\_request\_context](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#test\_request\_context), который создает нам [RequestContext](../api-dokumentaciya-flask/poleznye-funkcii-flask.md#klass-flask-ctx-requestcontext):

```python
>>> ctx = app.test_request_context()
```

Обычно вы должны использовать оператор **with**, чтобы сделать этот объект запроса активным, но в оболочке проще использовать методы [push ()](../api-dokumentaciya-flask/poleznye-funkcii-flask.md#push) и [pop ()](../api-dokumentaciya-flask/poleznye-funkcii-flask.md#pop) вручную:

```python
>>> ctx.push()
```

С этого момента вы можете работать с объектом запроса, пока не вызовете **pop**:

```python
>>> ctx.pop()
```

## Работа до / после запроса

Просто создав контекст запроса, вы все равно не выполнили код, который обычно запускается перед запросом. Это может привести к тому, что ваша база данных будет недоступна, если вы подключаетесь к базе данных в обратном вызове до запроса или текущий пользователь не сохраняется в объекте [g](../api-dokumentaciya-flask/globalnyi-obekt-prilozheniya-flask.md#flask-g) и т. д.

Однако это легко можно сделать самостоятельно. Просто вызовите [preprocess\_request ()](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#preprocessor\_request):

```python
>>> ctx = app.test_request_context()
>>> ctx.push()
>>> app.preprocess_request()
```

Имейте в виду, что функция [preprocess\_request ()](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#preprocessor\_request) может вернуть объект ответа, в этом случае просто игнорируйте его.

Чтобы отключить запрос, вам нужно немного обмануть, прежде чем функции после запроса (запускаемые [process\_response ()](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#process\_response)) будут работать с объектом ответа:

```python
>>> app.process_response(app.response_class())
<Response 0 bytes [200 OK]>
>>> ctx.pop()
```

Функции, зарегистрированные как [teardown\_request ()](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#teardown\_request), автоматически вызываются при открытии контекста. Так что это идеальное место для автоматического отключения ресурсов, которые были необходимы контексту запроса (например, подключения к базе данных).

## Дальнейшее улучшение впечатлений от Shell

Если вам нравится идея экспериментировать в оболочке, создайте себе модуль с тем, что вы хотите импортировать в интерактивный сеанс. Там вы также можете определить еще несколько вспомогательных методов для обычных вещей, таких как инициализация базы данных, удаление таблиц и т. д.

Просто поместите их в модуль (например, **shelltools**) и импортируйте оттуда:

```python
>>> from shelltools import *
```
