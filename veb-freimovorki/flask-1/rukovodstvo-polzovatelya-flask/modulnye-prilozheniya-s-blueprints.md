# Модульные приложения с Blueprints

_Новое в версии 0.7_.

**Flask** использует концепцию схем _**blueprints**_ для создания компонентов приложения и поддержки общих шаблонов внутри приложения или между приложениями. **Blueprints** могут значительно упростить работу больших приложений и предоставить расширения **Flask** для регистрации операций над приложениями. Объект [Blueprint](../api-dokumentaciya-flask/obekty-blueprint.md#klass-flask-blueprint) работает аналогично объекту приложения [Flask](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#klass-flask-flask), но на самом деле это не приложение. Скорее, это план того, как создать или расширить приложение.

## Почему Blueprints?

**Blueprints** в **Flask** предназначены для следующих случаев:

* Разложите приложение на наборы _**blueprints**_. Это идеально подходит для более крупных приложений; проект может создать экземпляр объекта приложения, инициализировать несколько расширений и зарегистрировать коллекцию _**blueprints**_.
* Зарегистрируйте _**blueprint**_ в приложении с префиксом URL и / или поддоменом. Параметры в префиксе / поддомене URL становятся общими аргументами представления (со значениями по умолчанию) для всех функций представления в схеме.
* Зарегистрируйте _**blueprint**_ несколько раз в приложении с разными правилами URL.
* Предоставляйте фильтры шаблонов, статические файлы, шаблоны и другие служебные программы через _**blueprints**_. В _**blueprint**_ не обязательно реализовывать приложения или функции просмотра.
* Зарегистрируйте _**blueprint**_ в приложении для любого из этих случаев при инициализации расширения **Flask**.

_**Blueprint**_ во **Flask** не является подключаемым приложением, потому что на самом деле это не приложение - это набор операций, которые можно зарегистрировать в приложении даже несколько раз. Почему бы не иметь несколько объектов приложения? Вы можете это сделать (см. Раздел «[Диспетчеризация приложений](../patterny-flask/#dispetcherizaciya-prilozhenii)»), но ваши приложения будут иметь отдельные конфигурации и будут управляться на уровне **WSGI**.

Вместо этого _**Blueprints**_ обеспечивают разделение на уровне **Flask**, совместно используют конфигурацию приложения и могут при необходимости изменять объект приложения после регистрации. Обратной стороной является то, что вы не можете отменить регистрацию _**blueprint**_ после создания приложения без необходимости уничтожить весь объект приложения.

## Концепция Blueprints

Основная концепция _**blueprints**_ заключается в том, что они записывают операции, которые необходимо выполнить при регистрации в приложении. **Flask** связывает функции просмотра с _**blueprints**_ при отправке запросов и генерации URL-адресов от одной конечной точки к другой.

## Мой первый Blueprint

Вот как выглядит очень простой _**blueprint**_. В этом случае мы хотим реализовать схему, которая выполняет простой рендеринг статических шаблонов:

```python
from flask import Blueprint, render_template, abort
from jinja2 import TemplateNotFound

simple_page = Blueprint('simple_page', __name__,
                        template_folder='templates')

@simple_page.route('/', defaults={'page': 'index'})
@simple_page.route('/<page>')
def show(page):
    try:
        return render_template('pages/%s.html' % page)
    except TemplateNotFound:
        abort(404)
```

Когда вы привязываете функцию с помощью декоратора `@simple_page.route`, в схеме будет записано намерение зарегистрировать функцию **show** в приложении, когда оно будет зарегистрировано позже. Кроме того, перед конечной точкой функции будет стоять префикс с именем _**blueprint**_, который был передан конструктору [Blueprint](../api-dokumentaciya-flask/obekty-blueprint.md#klass-flask-blueprint) (в данном случае также **simple\_page**). Название _**blueprint**_ не изменяет URL, а изменяет только конечную точку.

## Регистрация Blueprints

Так как же зарегистрировать этот _**blueprint**_? Так:

```python
from flask import Flask
from yourapplication.simple_page import simple_page

app = Flask(__name__)
app.register_blueprint(simple_page)
```

Если вы проверите правила, зарегистрированные в приложении, вы найдете следующее:

```python
>>> app.url_map
Map([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,
 <Rule '/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,
 <Rule '/' (HEAD, OPTIONS, GET) -> simple_page.show>])
```

Первый, очевидно, из самого приложения для статических файлов. Два других предназначены для функции **show** чертежа **simple\_page**. Как видите, они также имеют префикс с названием чертежа _**blueprint**_ и разделены точкой (`.`).

Однако _**blueprints**_ также могут быть установлены в разных местах:

```python
app.register_blueprint(simple_page, url_prefix='/pages')
```

И конечно же, это сгенерированные правила:

```python
>>> app.url_map
Map([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,
 <Rule '/pages/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,
 <Rule '/pages/' (HEAD, OPTIONS, GET) -> simple_page.show>])
```

Кроме того, вы можете регистрировать _**blueprints**_ несколько раз, хотя не все _**blueprints**_ могут правильно на это реагировать. Фактически, это зависит от того, как реализован _**blueprint**_, если он может быть установлен более одного раза.

## Ресурсы Blueprint

_**Blueprints**_ также могут предоставить ресурсы. Иногда вы можете захотеть представить _**blueprint**_ только тех ресурсов, которые он предоставляет.

### Каталог ресурсов Blueprint

Как и в случае с обычными приложениями, считается, что _**blueprints**_ находятся в папке. Хотя несколько _**blueprints**_ могут происходить из одной и той же папки, это не обязательно и обычно не рекомендуется.

Папка определяется вторым аргументом [Blueprint](../api-dokumentaciya-flask/obekty-blueprint.md#klass-flask-blueprint), который обычно `__name__`. Этот аргумент указывает, какой логический модуль или пакет Python соответствует схеме _**blueprint**_. Если он указывает на реальный пакет Python, этот пакет (который является папкой в файловой системе) является папкой ресурсов. Если это модуль, то пакет, в котором он содержится, будет папкой ресурсов. Вы можете получить доступ к свойству [Blueprint.root\_path](../api-dokumentaciya-flask/obekty-blueprint.md#root\_path), чтобы увидеть, что это за папка ресурсов:

```python
>>> simple_page.root_path
'/Users/username/TestProject/yourapplication'
```

Чтобы быстро открывать исходники из этой папки, вы можете использовать функцию [open\_resource ()](../api-dokumentaciya-flask/obekty-blueprint.md#open\_resource):

```python
with simple_page.open_resource('static/style.css') as f:
    code = f.read()
```

### Статические файлы

В _**blueprint**_ можно открыть папку со статическими файлами, указав путь к папке в файловой системе с аргументом **static\_folder**. Это либо абсолютный путь, либо относительно местоположения _**blueprint**_:

```python
admin = Blueprint('admin', __name__, static_folder='static')
```

По умолчанию самая правая часть пути - это то место, где она отображается в Интернете. Это можно изменить с помощью аргумента **static\_url\_path**. Поскольку папка здесь называется **static**, она будет доступна по префиксу `url_prefix` _**blueprint**_ + `/static`. Если в _**blueprint**_ есть префикс `/admin`, статический URL будет `/admin/static`.

Конечная точка называется `blueprint_name.static`. Вы можете сгенерировать URL-адреса для него с помощью [url\_for ()](../api-dokumentaciya-flask/poleznye-funkcii-i-klassy-flask.md#flask-url\_for), как и для статической папки приложения:

```python
url_for('admin.static', filename='style.css')
```

Однако, если в _**blueprint**_ нет **url\_prefix**, невозможно получить доступ к статической папке _**blueprint**_. Это связано с тем, что в этом случае URL-адрес будет `/static`, а маршрут приложения `/static` имеет приоритет. В отличие от папок шаблонов, статические папки _**blueprints**_ не ищутся, если файл не существует в статической папке приложения.

### Шаблоны

Если вы хотите, чтобы _**blueprint**_ отображал шаблоны, вы можете сделать это, указав параметр **template\_folder** конструктору [Blueprint](../api-dokumentaciya-flask/obekty-blueprint.md#klass-flask-blueprint):

```python
admin = Blueprint('admin', __name__, template_folder='templates')
```

Для статических файлов путь может быть абсолютным или относительным к папке ресурсов _**blueprint**_.

Папка шаблонов добавляется в путь поиска шаблонов, но с более низким приоритетом, чем папка шаблонов фактического приложения. Таким образом, вы можете легко переопределить шаблоны, предоставляемые схемой _**blueprint**_ в реальном приложении. Это также означает, что если вы не хотите, чтобы шаблон _**blueprint**_ был случайно переопределен, убедитесь, что никакой другой шаблон _**blueprint**_ или фактический шаблон приложения не имеет такого же относительного пути. Когда несколько _**blueprints**_ предоставляют один и тот же относительный путь к шаблону, первая зарегистрированная _**blueprint**_ имеет приоритет над другими.

Итак, если у вас есть _**blueprint**_ в папке `yourapplication/admin`, и вы хотите отобразить шаблон `'admin/index.html'`, и вы предоставили шаблоны в качестве **template\_folder**, вам нужно будет создать такой файл: `yourapplication/admin/templates/admin/index.html`. Причина создания дополнительной папки `admin` состоит в том, чтобы избежать переопределения нашего шаблона шаблоном с именем `index.html` в папке фактического шаблона приложения.

Чтобы еще раз повторить это: если у вас есть _**blueprint**_ с именем `admin` и вы хотите отобразить шаблон с именем `index.html`, который является специфическим для этого _**blueprint**_, лучше всего расположить ваши шаблоны следующим образом:

```bash
yourpackage/
    blueprints/
        admin/
            templates/
                admin/
                    index.html
            __init__.py
```

А затем, когда вы хотите отобразить шаблон, используйте `admin/index.html` в качестве имени для поиска шаблона. Если у вас возникли проблемы с загрузкой правильных шаблонов, включите конфигурационную переменную **EXPLAIN\_TEMPLATE\_LOADING**, которая укажет **Flask** распечатать шаги, которые он выполняет, чтобы найти шаблоны при каждом вызове **render\_template**.

## Создание URL-адресов

Если вы хотите перейти с одной страницы на другую, вы можете использовать функцию [url\_for ()](../api-dokumentaciya-flask/poleznye-funkcii-i-klassy-flask.md#flask-url\_for) так же, как вы обычно делаете, просто добавляя к конечной точке URL-адреса имя _**blueprint**_ и точку (`.`):

```python
url_for('admin.index')
```

Кроме того, если вы находитесь в функции просмотра _**blueprint**_ или визуализированного шаблона и хотите связать с другой конечной точкой того же самого _**blueprint**_, вы можете использовать относительные перенаправления, добавив к конечной точке только точку:

```python
url_for('.index')
```

Это будет ссылаться на `admin.index`, например, в случае, если текущий запрос был отправлен на любую другую конечную точку схемы _**blueprint**_ администратора **admin**.

## Обработчики ошибок

_**Blueprints**_ поддерживают декоратор **errorhandler** так же, как объект приложения [Flask](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#klass-flask-flask), поэтому легко создавать специальные страницы ошибок для **Blueprint**.

Вот пример исключения «`404 Page Not Found`»:

```python
@simple_page.errorhandler(404)
def page_not_found(e):
    return render_template('pages/404.html')
```

Большинство обработчиков ошибок будут просто работать должным образом; однако есть предостережение относительно обработчиков исключений `404` и `405`. Эти обработчики ошибок вызываются только из соответствующего оператора **raise** или вызова **abort** в другой функции представления _**blueprint**_; они не вызываются, например, из-за недействительного доступа к URL. Это связано с тем, что схема не «владеет» определенным пространством URL-адресов, поэтому экземпляр приложения не имеет возможности узнать, какой обработчик ошибок схемы _**blueprint**_ следует запустить, если указан недопустимый URL-адрес. Если вы хотите выполнить различные стратегии обработки этих ошибок на основе префиксов URL, они могут быть определены на уровне приложения с помощью объекта прокси запроса **request**:

```python
@app.errorhandler(404)
@app.errorhandler(405)
def _handle_api_error(ex):
    if request.path.startswith('/api/'):
        return jsonify_error(ex)
    else:
        return ex
```

Дополнительные сведения об обработке ошибок см. в разделе [Пользовательские страницы ошибок](../patterny-flask/#polzovatelskie-stranicy-oshibok).
