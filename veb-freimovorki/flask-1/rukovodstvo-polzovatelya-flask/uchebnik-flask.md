# Учебник Flask

## Учебник Flask

В этом руководстве вы узнаете, как создать простое приложение для блога под названием **Flaskr**. Пользователи смогут регистрироваться, входить в систему, создавать сообщения, а также редактировать или удалять свои собственные сообщения. Вы сможете упаковать и установить приложение на другие компьютеры.

![](../../../.gitbook/assets/flaskr\_index.png)

Предполагается, что вы уже знакомы с **Python**. [Официальный учебник](https://docs.python.org/3/tutorial/) в документации **Python** - отличный способ сначала изучить или просмотреть.

Хотя оно создано для того, чтобы стать хорошей отправной точкой, оно не охватывает всех функций **Flask**. Ознакомьтесь с кратким руководством, чтобы узнать о возможностях **Flask**, а затем погрузитесь в документацию, чтобы узнать больше. В руководстве используется только то, что предоставляется **Flask** и **Python**. В другом проекте вы можете решить использовать расширения или другие библиотеки, чтобы упростить некоторые задачи.

![](../../../.gitbook/assets/flaskr\_login.png)

**Flask** гибкий. Вам не нужно использовать какой-либо конкретный проект или макет кода. Однако при первом запуске полезно использовать более структурированный подход. Это означает, что в руководстве потребуется немного шаблонов, но это сделано, чтобы избежать многих распространенных ошибок, с которыми сталкиваются новые разработчики, и создает проект, который легко расширять. Когда вы освоитесь с **Flask**, вы сможете выйти из этой структуры и в полной мере воспользоваться гибкостью **Flask**.

![](../../../.gitbook/assets/flaskr\_edit.png)

Учебный проект доступен в качестве [примера в репозитории Flask](https://github.com/pallets/flask/tree/1.1.2/examples/tutorial), если вы хотите сравнить свой проект с конечным продуктом, следуя руководству.

Переходим к макету проекта.

## Макет проекта

Создайте каталог проекта и войдите в него:

```bash
$ mkdir flask-tutorial
$ cd flask-tutorial
```

Затем следуйте [инструкциям по установке](ustanovka.md), чтобы настроить виртуальную среду **Python** и установить **Flask** для своего проекта.

В руководстве предполагается, что вы с этого момента работаете из каталога **flask-tutorial**. Имена файлов в верхней части каждого блока кода относятся к этому каталогу.

Приложение **Flask** может быть таким же простым, как отдельный файл  `hello.py`.

```python
from flask import Flask

app = Flask(__name__)


@app.route('/')
def hello():
    return 'Hello, World!'
```

Однако по мере роста проекта становится непосильной задачей хранить весь код в одном файле. В проектах **Python** используются пакеты _**packages**_ для организации кода в несколько модулей, которые можно импортировать при необходимости, и в учебнике это тоже делается.

Каталог проекта будет содержать:

* `flaskr/`, пакет **Python**, содержащий код и файлы вашего приложения.
* `tests/`, каталог, содержащий тестовые модули.
* `venv/`, виртуальная среда **Python**, в которой установлены **Flask** и другие зависимости.
* Файлы установки, сообщающие **Python**, как установить ваш проект.
* Конфигурация контроля версий, например **git**. Вы должны иметь привычку использовать какой-либо тип контроля версий для всех ваших проектов, независимо от их размера.
* Любые другие файлы проекта, которые вы можете добавить в будущем.

В итоге макет вашего проекта будет выглядеть так:

```bash
/home/user/Projects/flask-tutorial
├── flaskr/
│   ├── __init__.py
│   ├── db.py
│   ├── schema.sql
│   ├── auth.py
│   ├── blog.py
│   ├── templates/
│   │   ├── base.html
│   │   ├── auth/
│   │   │   ├── login.html
│   │   │   └── register.html
│   │   └── blog/
│   │       ├── create.html
│   │       ├── index.html
│   │       └── update.html
│   └── static/
│       └── style.css
├── tests/
│   ├── conftest.py
│   ├── data.sql
│   ├── test_factory.py
│   ├── test_db.py
│   ├── test_auth.py
│   └── test_blog.py
├── venv/
├── setup.py
└── MANIFEST.in
```

Если вы используете контроль версий, следующие файлы, которые создаются во время работы вашего проекта, следует игнорировать. В зависимости от используемого вами редактора могут быть и другие файлы. В общем, игнорируйте файлы, которые вы не писали. Например, с **git** `.gitignore`:

```bash
venv/

*.pyc
__pycache__/

instance/

.pytest_cache/
.coverage
htmlcov/

dist/
build/
*.egg-info/
```

Переходим к настройке приложения.

## Настройка приложения

Приложение **Flask** - это экземпляр класса **Flask**. Все, что касается приложения, например конфигурация и URL-адреса, будет зарегистрировано в этом классе.

Самый простой способ создать приложение **Flask** - это создать глобальный экземпляр **Flask** непосредственно в верхней части кода, например, как «Hello, World!» пример делал на предыдущей странице. Хотя в некоторых случаях это просто и полезно, по мере роста проекта это может вызвать некоторые сложные проблемы.

Вместо того, чтобы создавать экземпляр **Flask** глобально, вы создадите его внутри функции. Эта функция известна как фабрика приложений. Любая конфигурация, регистрация и другие настройки, необходимые приложению, будут выполняться внутри функции, после чего приложение будет возвращено.

### Фабрика приложений

Пора начинать кодить! Создайте каталог **flaskr** и добавьте файл `__init__.py`. `__init__.py` выполняет двойную функцию: он будет содержать фабрику приложений и сообщает Python, что каталог **flaskr** следует рассматривать как пакет.

```bash
$ mkdir flaskr
```

&#x20;`flaskr/__init__.py`

```python
import os

from flask import Flask


def create_app(test_config=None):
    # создать и настроить приложение
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(
        SECRET_KEY='dev',
        DATABASE=os.path.join(app.instance_path, 'flaskr.sqlite'),
    )

    if test_config is None:
        # загрузить конфигурацию экземпляра, если он существует, когда не тестируем
        app.config.from_pyfile('config.py', silent=True)
    else:
        # загрузить тестовую конфигурацию, если она передана
        app.config.from_mapping(test_config)

    # убедитесь, что папка экземпляра существует
    try:
        os.makedirs(app.instance_path)
    except OSError:
        pass

    # простая страница, которая здоровается
    @app.route('/hello')
    def hello():
        return 'Hello, World!'

    return app
```

**create\_app** - это функция фабрики приложения. Позже вы добавите к нему дополнительные сведения, но он уже многое делает.

* `app = Flask (__name__, instance_relative_config = True)` создает экземпляр **Flask**.
  * `__name__` - это имя текущего модуля Python. Приложению необходимо знать, где оно находится, чтобы задать пути, и `__name__` - удобный способ сообщить ему об этом.
  * `instance_relative_config = True` сообщает приложению, что файлы конфигурации относятся к папке экземпляра. Папка экземпляра находится вне пакета **flaskr** и может содержать локальные данные, которые не должны передаваться в систему контроля версий, например секреты конфигурации и файл базы данных.
* **app.config.from\_mapping ()** устанавливает некоторую конфигурацию по умолчанию, которую приложение будет использовать:
  * **SECRET\_KEY** используется **Flask** и расширениями для обеспечения безопасности данных. Для него установлено значение `'dev'`, чтобы обеспечить удобное значение во время разработки, но при развертывании его следует заменить случайным значением.
  * `DATABASE` - это путь, по которому будет сохранен файл базы данных **SQLite**. Он находится в **app.instance\_path**, который является путем, выбранным **Flask** для папки экземпляра. Вы узнаете больше о базе данных в следующем разделе.
* **app.config.from\_pyfile ()** заменяет конфигурацию по умолчанию значениями, взятыми из файла `config.py` в папке экземпляра, если он существует. Например, при развертывании это можно использовать для установки реального **SECRET\_KEY**.
  * `test_config` также можно передать фабрике, и он будет использоваться вместо конфигурации экземпляра. Это сделано для того, чтобы тесты, которые вы напишете позже в руководстве, можно настроить независимо от любых значений разработки, которые вы настроили.
* ****[**os.makedirs ()**](https://docs.python.org/3/library/os.html#os.makedirs) гарантирует, что **app.instance\_path** существует. **Flask** не создает папку экземпляра автоматически, но ее нужно создать, потому что ваш проект создаст там файл базы данных **SQLite**.
* **@app.route ()** создает простой маршрут, чтобы вы могли увидеть, как приложение работает, прежде чем переходить к остальной части руководства. Он создает соединение между URL `/hello` и функцией, которая возвращает ответ, строку `'Hello, World!'` в этом случае.

### Запуск приложения

Теперь вы можете запустить приложение с помощью команды **flask**. В терминале сообщите **Flask**, где найти ваше приложение, а затем запустите его в режиме разработки. Помните, что вы по-прежнему должны находиться в каталоге верхнего уровня **flask-tutorial**, а не в пакете **flaskr**.

В режиме разработки интерактивный отладчик отображается всякий раз, когда страница вызывает исключение, и перезапускается сервер всякий раз, когда вы вносите изменения в код. Вы можете оставить его включенным и просто перезагрузить страницу браузера, следуя инструкциям.

Для Linux и Mac:

```bash
$ export FLASK_APP=flaskr
$ export FLASK_ENV=development
$ flask run
```

Для командной строки Windows используйте **set** вместо **export**:

```bash
> set FLASK_APP=flaskr
> set FLASK_ENV=development
> flask run
```

Для Windows PowerShell используйте **$env** вместо **export**:

```bash
> $env:FLASK_APP = "flaskr"
> $env:FLASK_ENV = "development"
> flask run
```

Вы увидите примерно такой результат:

```bash
* Serving Flask app "flaskr"
* Environment: development
* Debug mode: on
* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
* Restarting with stat
* Debugger is active!
* Debugger PIN: 855-212-761
```

Посетите [http://127.0.0.1:5000/hello](http://127.0.0.1:5000/hello) в браузере, и вы увидите сообщение «Hello, World!» сообщение. Поздравляем, теперь у вас запущено веб-приложение **Flask**!

Продолжить определение и доступ к базе данных.

## Определение и доступ к базе данных

Приложение будет использовать базу данных [**SQLite**](https://sqlite.org/about.html) для хранения пользователей и сообщений. **Python** поставляется со встроенной поддержкой **SQLite** в модуле [**sqlite3**](https://docs.python.org/3/library/sqlite3.html#module-sqlite3).

**SQLite** удобен тем, что не требует настройки отдельного сервера базы данных и встроен в Python. Однако, если одновременные запросы будут пытаться записать в базу данных одновременно, они будут замедляться, поскольку каждая запись будет происходить последовательно. Маленькие приложения этого не заметят. Когда вы станете большим, вы можете захотеть переключиться на другую базу данных.

В руководстве не содержится подробного описания **SQL**. Если вы не знакомы с ним, [документация SQLite](https://sqlite.org/lang.html) описывает язык.

### Подключение к базе данных

Первое, что нужно сделать при работе с базой данных **SQLite** (и большинством других библиотек баз данных **Python**), - это создать к ней соединение. Любые запросы и операции выполняются через соединение, которое закрывается после завершения работы.

В веб-приложениях это соединение обычно привязано к запросу. Он создается в какой-то момент при обработке запроса и закрывается перед отправкой ответа.

&#x20;**`flaskr/db.py`**

```python
import sqlite3

import click
from flask import current_app, g
from flask.cli import with_appcontext


def get_db():
    if 'db' not in g:
        g.db = sqlite3.connect(
            current_app.config['DATABASE'],
            detect_types=sqlite3.PARSE_DECLTYPES
        )
        g.db.row_factory = sqlite3.Row

    return g.db


def close_db(e=None):
    db = g.pop('db', None)

    if db is not None:
        db.close()
```

**g** - особый объект, уникальный для каждого запроса. Он используется для хранения данных, к которым могут обращаться несколько функций во время запроса. Соединение сохраняется и используется повторно вместо создания нового соединения, если **get\_db** вызывается второй раз в том же запросе.

**current\_app** - еще один специальный объект, который указывает на приложение **Flask**, обрабатывающее запрос. Поскольку вы использовали фабрику приложений, при написании остальной части кода объект приложения отсутствует. **get\_db** будет вызываться, когда приложение будет создано и обрабатывает запрос, поэтому можно использовать **current\_app**.

****[**sqlite3.connect ()**](https://docs.python.org/3/library/sqlite3.html#sqlite3.connect) устанавливает соединение с файлом, на который указывает ключ конфигурации **DATABASE**. Этот файл еще не обязательно должен существовать, и не будет, пока вы не инициализируете базу данных позже.

****[**sqlite3.Row**](https://docs.python.org/3/library/sqlite3.html#sqlite3.Row) сообщает соединению, что нужно возвращать строки, которые ведут себя как **dicts**. Это позволяет получить доступ к столбцам по имени.

**close\_db** проверяет, было ли создано соединение, проверяя, установлен ли **g.db**. Если соединение существует, оно закрывается. Далее вы расскажете своему приложению о функции **close\_db** в фабрике приложений, чтобы она вызывалась после каждого запроса.

### Создание таблиц

В **SQLite** данные хранятся в таблицах _**tables**_ и столбцах _**columns**_. Их необходимо создать, прежде чем вы сможете сохранять и извлекать данные. **Flaskr** будет хранить пользователей в таблице пользователей **user**, а сообщения - в таблице сообщений **post**. Создайте файл с командами **SQL**, необходимыми для создания пустых таблиц:

&#x20;**`flaskr/schema.sql`**

```sql
DROP TABLE IF EXISTS user;
DROP TABLE IF EXISTS post;

CREATE TABLE user (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE NOT NULL,
  password TEXT NOT NULL
);

CREATE TABLE post (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  author_id INTEGER NOT NULL,
  created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  FOREIGN KEY (author_id) REFERENCES user (id)
);
```

Добавьте функции Python, которые будут запускать эти команды **SQL**, в файл **db.py**:

&#x20;**`flaskr/db.py`**

```python
def init_db():
    db = get_db()

    with current_app.open_resource('schema.sql') as f:
        db.executescript(f.read().decode('utf8'))


@click.command('init-db')
@with_appcontext
def init_db_command():
    """Очистите существующие данные и создайте новые таблицы."""
    init_db()
    click.echo('Initialized the database.')
```

**open\_resource ()** открывает файл, относящийся к пакету **flaskr**, что полезно, поскольку вы не обязательно будете знать, где это место, при развертывании приложения позже. **get\_db** возвращает соединение с базой данных, которое используется для выполнения команд, прочитанных из файла.

****[**click.command ()**](https://click.palletsprojects.com/en/7.x/api/#click.command) определяет команду командной строки с именем **init-db**, которая вызывает функцию **init\_db** и показывает пользователю сообщение об успешном выполнении. Вы можете прочитать Интерфейс командной строки, чтобы узнать больше о написании команд.

### Регистрация в приложении

Функции **close\_db** и **init\_db\_command** необходимо зарегистрировать в экземпляре приложения; в противном случае они не будут использоваться приложением. Однако, поскольку вы используете фабричную функцию, этот экземпляр недоступен при написании функций. Вместо этого напишите функцию, которая принимает приложение и выполняет регистрацию.

&#x20;**`flaskr/db.py`**

```python
def init_app(app):
    app.teardown_appcontext(close_db)
    app.cli.add_command(init_db_command)
```

**app.teardown\_appcontext ()** сообщает **Flask** вызвать эту функцию при очистке после возврата ответа.

****[**app.cli.add\_command ()**](https://click.palletsprojects.com/en/7.x/api/#click.Group.add\_command) добавляет новую команду, которую можно вызвать с помощью команды **flask**.

Импортируйте и вызовите эту функцию из фабрики. Поместите новый код в конец фабричной функции перед возвратом приложения.

&#x20;**`flaskr/__init__.py`**

```python
def create_app():
    app = ...
    # существующий код опущен

    from . import db
    db.init_app(app)

    return app
```

### Инициализация файла базы данных

Теперь, когда **init-db** зарегистрирован в приложении, его можно вызвать с помощью команды **flask**, аналогичной команде **run** с предыдущей страницы.

{% hint style="info" %}
**Замечание:**

Если вы все еще запускаете сервер с предыдущей страницы, вы можете либо остановить сервер, либо запустить эту команду в новом терминале. Если вы используете новый терминал, не забудьте перейти в каталог проекта и активировать **env**, как описано в разделе «[Активация среды](ustanovka.md#aktiviruite-sredu)». Вам также необходимо установить **FLASK\_APP** и **FLASK\_ENV**, как показано на [предыдущей странице](uchebnik-flask.md#zapusk-prilozheniya).
{% endhint %}

Выполните команду **init-db**:

```bash
$ flask init-db
Initialized the database.
```

Теперь в папке экземпляра вашего проекта будет файл **flaskr.sqlite**.

Перейдите к схемам и представлениям.

## Схемы (Blueprints) и виды (Views)

Функция просмотра - это код, который вы пишете для ответа на запросы вашего приложения. **Flask** использует шаблоны для сопоставления URL входящего запроса с представлением, которое должно его обработать. Представление возвращает данные, которые **Flask** превращает в исходящий ответ. **Flask** также может пойти в другом направлении и сгенерировать URL-адрес представления на основе его имени и аргументов.

### Создать схему Blueprint

**Blueprint** - это способ организовать группу связанных представлений и другого кода. Вместо того, чтобы регистрировать представления и другой код непосредственно в приложении, они регистрируются с помощью схемы. Затем проект регистрируется в приложении, когда он доступен в фабричной функции.

**Flaskr** будет иметь две схемы, одну для функций аутентификации и одну для функций сообщений в блоге. Код для каждой схемы будет выделен в отдельный модуль. Поскольку блогу необходимо знать об аутентификации, вы сначала напишете аутентификационную.

&#x20;**`flaskr/auth.py`**

```python
import functools

from flask import (
    Blueprint, flash, g, redirect, render_template, request, session, url_for
)
from werkzeug.security import check_password_hash, generate_password_hash

from flaskr.db import get_db

bp = Blueprint('auth', __name__, url_prefix='/auth')
```

Этот код создает схему **Blueprint** с именем **auth**. Как и объект приложения, схема должна знать, где он определен, поэтому `__name__` передается в качестве второго аргумента. **url\_prefix** будет добавлен ко всем URL-адресам, связанным со схемой.

Импортируйте и зарегистрируйте схему из фабрики с помощью **app.register\_blueprint ()**. Поместите новый код в конец фабричной функции перед возвратом приложения.

&#x20;**`flaskr/__init__.py`**

```python
def create_app():
    app = ...
    # существующий код опущен

    from . import auth
    app.register_blueprint(auth.bp)

    return app
```

Схема аутентификации будет иметь представления для регистрации новых пользователей, а также для входа и выхода.

### Первый вид: регистрация

Когда пользователь посещает URL-адрес `/auth/register`, представление **register** возвращает HTML-код с формой для заполнения. Когда он отправит данные, то форма проверит ввод пользователя и либо снова покажет форму с сообщением об ошибке, либо создаст нового пользователя и перейдет на страницу входа.

А пока вы просто напишете код просмотра. На следующей странице вы напишете шаблоны для создания HTML-формы.

&#x20;**`flaskr/auth.py`**

```python
@bp.route('/register', methods=('GET', 'POST'))
def register():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        db = get_db()
        error = None

        if not username:
            error = 'Username is required.'
        elif not password:
            error = 'Password is required.'
        elif db.execute(
            'SELECT id FROM user WHERE username = ?', (username,)
        ).fetchone() is not None:
            error = 'User {} is already registered.'.format(username)

        if error is None:
            db.execute(
                'INSERT INTO user (username, password) VALUES (?, ?)',
                (username, generate_password_hash(password))
            )
            db.commit()
            return redirect(url_for('auth.login'))

        flash(error)

    return render_template('auth/register.html')
```

Вот что делает функция просмотра **register**:

1. **@bp.route** связывает URL `/register` с функцией просмотра **register**. Когда **Flask** получает запрос к `/auth/register`, он вызывает представление **register** и использует возвращаемое значение в качестве ответа.
2. Если пользователь отправил форму, **request.method** будет `'POST'`. В этом случае начните проверку ввода.
3. **request.form** - это особый тип [словаря](https://docs.python.org/3/library/stdtypes.html#dict), отображающий ключи и значения представленной формы. Пользователь вводит свое имя пользователя _**username**_ и пароль _**password**_.
4. Убедитесь, что имя пользователя _**username**_ и пароль _**password**_ не пустые.
5. Убедитесь, что это имя пользователя _**username**_ еще не зарегистрировано, запросив базу данных и проверив, был ли возвращен результат. **db.execute** принимает SQL-запрос с помощью заполнителей `?` для любого пользовательского ввода и кортеж значений для замены заполнителей. Библиотека базы данных позаботится об экранировании значений, чтобы вы не были уязвимы для атаки SQL-инъекции (_SQL injection attack)_. **fetchone ()** возвращает одну строку из запроса. Если запрос не дал результатов, он возвращает `None`. Позже используется функция **fetchall ()**, которая возвращает список всех результатов.
6. Если проверка прошла успешно, вставьте новые данные пользователя в базу данных. В целях безопасности никогда не следует хранить пароли напрямую в базе данных. Вместо этого, **generate\_password\_hash ()** используется для безопасного хеширования пароля, и этот хеш сохраняется. Поскольку этот запрос изменяет данные, необходимо впоследствии вызвать **db.commit ()**, чтобы сохранить изменения.
7. После сохранения пользователя они перенаправляются на страницу входа. **url\_for ()** генерирует URL-адрес для представления входа на основе его имени. Это предпочтительнее, чем запись URL-адреса напрямую, поскольку это позволяет вам изменить URL-адрес позже, не изменяя весь код, который ссылается на него. **redirect ()** генерирует ответ перенаправления на сгенерированный URL.
8. Если проверка не удалась, пользователю показывается ошибка. **flash ()** хранит сообщения, которые можно получить при рендеринге шаблона.
9. Когда пользователь сначала переходит к `auth/register` или произошла ошибка проверки, должна отображаться HTML-страница с формой регистрации. **render\_template ()** отобразит шаблон, содержащий HTML, который вы напишете на следующем шаге руководства.

### Авторизация

Это представление следует той же схеме, что и представление **register** выше.

&#x20;**`flaskr/auth.py`**

```python
@bp.route('/login', methods=('GET', 'POST'))
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        db = get_db()
        error = None
        user = db.execute(
            'SELECT * FROM user WHERE username = ?', (username,)
        ).fetchone()

        if user is None:
            error = 'Incorrect username.'
        elif not check_password_hash(user['password'], password):
            error = 'Incorrect password.'

        if error is None:
            session.clear()
            session['user_id'] = user['id']
            return redirect(url_for('index'))

        flash(error)

    return render_template('auth/login.html')
```

Есть несколько отличий от вида **register**:

1. Сначала запрашивается пользователь, который сохраняется в переменной для дальнейшего использования.
2. **check\_password\_hash ()** хеширует отправленный пароль таким же образом, как и сохраненный хэш, и безопасно сравнивает их. Если они совпадают, пароль действителен.
3. **session** - это словарь, который хранит данные между запросами. Когда проверка завершается успешно, идентификатор пользователя _**id**_ сохраняется в новом сеансе. Данные хранятся в файле **cookie**, который отправляется браузеру, а затем браузер отправляет их обратно с последующими запросами. **Flask** надежно подписывает данные, чтобы их нельзя было подделать.

Теперь, когда идентификатор пользователя _**id**_ хранится в сеансе, он будет доступен для последующих запросов. В начале каждого запроса, если пользователь вошел в систему, его информация должна быть загружена и сделана доступной для других представлений.

&#x20;**`flaskr/auth.py`**

```python
@bp.before_app_request
def load_logged_in_user():
    user_id = session.get('user_id')

    if user_id is None:
        g.user = None
    else:
        g.user = get_db().execute(
            'SELECT * FROM user WHERE id = ?', (user_id,)
        ).fetchone()
```

**bp.before\_app\_request ()** регистрирует функцию, которая запускается перед функцией просмотра, независимо от того, какой URL-адрес запрашивается. **load\_logged\_in\_user** проверяет, хранится ли идентификатор пользователя в сеансе **session**, и получает данные этого пользователя из базы данных, сохраняя их в **g.user**, что длится на время запроса. Если идентификатор пользователя отсутствует или он не существует, **g.user** будет `None`.

### Выход

Чтобы выйти из системы, вам необходимо удалить идентификатор пользователя из сеанса **session**. Тогда **load\_logged\_in\_user** не будет загружать пользователя при последующих запросах.

&#x20;**`flaskr/auth.py`**

```python
@bp.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('index'))
```

### Требование аутентификации в других представлениях

Создание, редактирование и удаление сообщений в блоге потребует от пользователя входа в систему. Чтобы проверить это для каждого представления, к которому он применяется, можно использовать декоратор.

&#x20;**`flaskr/auth.py`**

```python
def login_required(view):
    @functools.wraps(view)
    def wrapped_view(**kwargs):
        if g.user is None:
            return redirect(url_for('auth.login'))

        return view(**kwargs)

    return wrapped_view
```

Этот декоратор возвращает новую функцию представления, которая обертывает исходное представление, к которому он применен. Новая функция проверяет, загружен ли пользователь, и в противном случае перенаправляет на страницу входа. Если пользователь загружен, вызывается исходное представление, которое продолжается в обычном режиме. Вы будете использовать этот декоратор при написании просмотров блога.

### Конечные точки и URL-адреса

Функция **url\_for ()** генерирует URL-адрес представления на основе имени и аргументов. Имя, связанное с представлением, также называется конечной точкой _**endpoint**_ и по умолчанию совпадает с именем функции представления.

Например, представление **hello ()**, которое было добавлено в фабрику приложений ранее в руководстве, имеет имя `'hello'` и может быть связано как `url_for ('hello')`. Если она принимает аргумент, который вы увидите позже, он будет связан с использованием `url_for ('hello', who='World')`.

При использовании схемы имя этой схемы добавляется к имени функции, поэтому конечной точкой для функции входа в систему **login**, которую вы написали выше, является `'auth.login'`, потому что вы добавили ее в схему `'auth'`.

Перейти к шаблонам.

## Шаблоны (Templates)

Вы написали представления аутентификации для своего приложения, но если вы запускаете сервер и пытаетесь перейти по любому из URL-адресов, вы увидите ошибку **TemplateNotFound**. Это потому, что представления вызывают **render\_template ()**, но вы еще не написали шаблоны. Файлы шаблонов будут храниться в каталоге **templates** внутри пакета **flaskr**.

Шаблоны - это файлы, содержащие статические данные, а также заполнители для динамических данных. Шаблон визуализируется с определенными данными для создания окончательного документа. **Flask** использует библиотеку шаблонов [**Jinja**](../../../shablonizatory/jinja/) для визуализации шаблонов.

В своем приложении вы будете использовать шаблоны для рендеринга HTML, который будет отображаться в браузере пользователя. В **Flask** **Jinja** настроен на автоматическое экранирование любых данных, отображаемых в шаблонах HTML. Это означает, что обрабатывать вводимые пользователем данные безопасно; любые введенные ими символы, которые могут повлиять на HTML, такие как `<` и `>`, будут заменены безопасными значениями, которые выглядят в браузере одинаково, но не вызывают нежелательных эффектов.

Jinja выглядит и ведет себя в основном как Python. Специальные разделители используются, чтобы отличить синтаксис **Jinja** от статических данных в шаблоне. Все, что находится между `{{` и `}}`, является выражением, которое будет выводиться в окончательный документ. `{%` и `%}` обозначают оператор потока управления, например `if` и `for`. В отличие от Python, блоки обозначаются начальным и конечным тегами, а не отступом, поскольку статический текст внутри блока может изменить отступ.

### Базовый макет

Каждая страница в приложении будет иметь одинаковый базовый макет вокруг другого тела. Вместо того, чтобы писать всю структуру HTML в каждом шаблоне, каждый шаблон будет расширять базовый шаблон и переопределять определенные разделы.

&#x20;**`flaskr/templates/base.html`**

```python
<!doctype html>
<title>{% raw %}
{% block title %}{% endblock %} - Flaskr</title>
<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
<nav>
  <h1>Flaskr</h1>
  <ul>
    {% if g.user %}
      <li><span>{{ g.user['username'] }}</span>
      <li><a href="{{ url_for('auth.logout') }}">Log Out</a>
    {% else %}
      <li><a href="{{ url_for('auth.register') }}">Register</a>
      <li><a href="{{ url_for('auth.login') }}">Log In</a>
    {% endif %}
  </ul>
</nav>
<section class="content">
  <header>
    {% block header %}{% endblock %}
  </header>
  {% for message in get_flashed_messages() %}
    <div class="flash">{{ message }}</div>
  {% endfor %}
  {% block content %}{% endblock %}
{% endraw %}
</section>
```

**g** автоматически доступен в шаблонах. В зависимости от того, установлен ли **g.user** (из **load\_logged\_in\_user**), отображаются либо имя пользователя и ссылка для выхода, либо отображаются ссылки для регистрации и входа в систему. **url\_for ()** также доступен автоматически и используется для генерации URL-адресов для представлений вместо их записи вручную.

После заголовка страницы и перед содержимым шаблон перебирает каждое сообщение, возвращаемое **get\_flashed\_messages ()**. Вы использовали **flash ()** в представлениях для отображения сообщений об ошибках, и это код, который будет их отображать.

Здесь определены три блока, которые будут переопределены в других шаблонах:

1. `{% block title %}` - изменит заголовок, отображаемый на вкладке браузера, и заголовок окна.
2. `{% block header %}`  - аналогичен _**title**_, но изменит заголовок, отображаемый на странице.
3. `{% block content %}` - Это то место, где находится содержимое каждой страницы, например форма входа или сообщение в блоге.

Базовый шаблон находится прямо в каталоге **templates**. Чтобы остальные были организованы, шаблоны для схем blueprint будут помещены в каталог с тем же именем, что и у схем.

### Регистрация

&#x20;**`flaskr/templates/auth/register.html`**

```python
{% raw %}
{% extends 'base.html' %}

{% block header %}
  <h1>{% block title %}Register{% endblock %}</h1>
{% endblock %}

{% block content %}
  <form method="post">
    <label for="username">Username</label>
    <input name="username" id="username" required>
    <label for="password">Password</label>
    <input type="password" name="password" id="password" required>
    <input type="submit" value="Register">
  </form>
{% endblock %}
{% endraw %}
```

`{% extends 'base.html' %}` сообщает **Jinja**, что этот шаблон должен заменить блоки из базового шаблона. Весь отображаемый контент должен отображаться внутри тегов `{% block %}`, которые заменяют блоки из базового шаблона.

Здесь можно использовать полезный шаблон, чтобы поместить `{% block title %}` внутри `{% block header %}`. Это установит заголовок в блоке `header`, а затем выведет его значение в тег `<title>`, так что и окно, и страница будут использовать один и тот же заголовок, не записывая его дважды.

Здесь теги ввода **input** используют атрибут **required**. Это говорит браузеру не отправлять форму до тех пор, пока эти поля не будут заполнены. Если пользователь использует старый браузер, который не поддерживает этот атрибут, или если он использует что-то помимо браузера для выполнения запросов, вы все равно можете проверить данные в представлении **Flask**. Важно всегда полностью проверять данные на сервере, даже если клиент также выполняет некоторую проверку.

### Авторизация (Log In)

Он идентичен шаблону регистрации, за исключением заголовка и кнопки отправки.

&#x20;**`flaskr/templates/auth/login.html`**

```python
{% raw %}
{% extends 'base.html' %}

{% block header %}
  <h1>{% block title %}Log In{% endblock %}</h1>
{% endblock %}

{% block content %}
  <form method="post">
    <label for="username">Username</label>
    <input name="username" id="username" required>
    <label for="password">Password</label>
    <input type="password" name="password" id="password" required>
    <input type="submit" value="Log In">
  </form>
{% endblock %}
{% endraw %}
```

### Регистрация пользователя

Теперь, когда шаблоны аутентификации написаны, вы можете зарегистрировать пользователя. Убедитесь, что сервер все еще работает (запустите **flask**, если это не так), затем перейдите по адресу [http://127.0.0.1:5000/auth/register](http://127.0.0.1:5000/auth/register).

Попробуйте нажать кнопку «Register», не заполняя форму, и увидите, что браузер показывает сообщение об ошибке. Попробуйте удалить атрибуты **required** из шаблона `register.html` и снова нажмите «Register». Вместо того, чтобы браузер отображал ошибку, страница будет перезагружена, и в представлении будет показана ошибка **flash ()**.

Введите имя пользователя и пароль, и вы будете перенаправлены на страницу входа. Попробуйте ввести неправильное имя пользователя или правильное имя пользователя и неправильный пароль. Если вы войдете в систему, вы получите сообщение об ошибке, потому что еще нет представления **index** для перенаправления.

Перейти к статическим файлам.

## Статические файлы

Представления и шаблоны аутентификации работают, но сейчас они выглядят очень просто. Можно добавить немного [CSS](https://developer.mozilla.org/ru/docs/Web/CSS), чтобы добавить стиль в созданный HTML-макет. Стиль не изменится, поэтому это статический файл, а не шаблон.

**Flask** автоматически добавляет статическое представление **static**, которое берет путь относительно каталога `flaskr/static` и обслуживает его. В шаблоне `base.html` уже есть ссылка на файл `style.css`:

```python
{{ url_for('static', filename='style.css') }}
```

Помимо **CSS**, другие типы статических файлов могут быть файлами с функциями **JavaScript** или изображением логотипа. Все они помещаются в каталог `flaskr/static` и ссылаются на `url_for ('static', filename = '...')`.

Это руководство не посвящено написанию **CSS**, поэтому вы можете просто скопировать следующее в файл `flaskr/static/style.css`:

&#x20;**`flaskr/static/style.css`**

```css
html { font-family: sans-serif; background: #eee; padding: 1rem; }
body { max-width: 960px; margin: 0 auto; background: white; }
h1 { font-family: serif; color: #377ba8; margin: 1rem 0; }
a { color: #377ba8; }
hr { border: none; border-top: 1px solid lightgray; }
nav { background: lightgray; display: flex; align-items: center; padding: 0 0.5rem; }
nav h1 { flex: auto; margin: 0; }
nav h1 a { text-decoration: none; padding: 0.25rem 0.5rem; }
nav ul  { display: flex; list-style: none; margin: 0; padding: 0; }
nav ul li a, nav ul li span, header .action { display: block; padding: 0.5rem; }
.content { padding: 0 1rem 1rem; }
.content > header { border-bottom: 1px solid lightgray; display: flex; align-items: flex-end; }
.content > header h1 { flex: auto; margin: 1rem 0 0.25rem 0; }
.flash { margin: 1em 0; padding: 1em; background: #cae6f6; border: 1px solid #377ba8; }
.post > header { display: flex; align-items: flex-end; font-size: 0.85em; }
.post > header > div:first-of-type { flex: auto; }
.post > header h1 { font-size: 1.5em; margin-bottom: 0; }
.post .about { color: slategray; font-style: italic; }
.post .body { white-space: pre-line; }
.content:last-child { margin-bottom: 0; }
.content form { margin: 1em 0; display: flex; flex-direction: column; }
.content label { font-weight: bold; margin-bottom: 0.5em; }
.content input, .content textarea { margin-bottom: 1em; }
.content textarea { min-height: 12em; resize: vertical; }
input.danger { color: #cc2f2e; }
input[type=submit] { align-self: start; min-width: 10em; }
```

Вы можете найти менее компактную версию `style.css` в [примере кода](https://github.com/pallets/flask/blob/1.1.2/examples/tutorial/flaskr/static/style.css).

Перейдите на [http://127.0.0.1:5000/auth/login](http://127.0.0.1:5000/auth/login), и страница должна выглядеть как на снимке экрана ниже.

![](../../../.gitbook/assets/flaskr\_login.png)

Вы можете узнать больше о **CSS** в [документации Mozilla](https://developer.mozilla.org/ru/docs/Web/CSS). Если вы изменяете статический файл, обновите страницу браузера. Если изменение не отображается, попробуйте очистить кеш браузера.

Перейти к проекту блога.

## Схема блога

Вы будете использовать те же методы, которые вы изучили при написании схемы аутентификации, чтобы написать схему блога. В блоге должны быть перечислены все сообщения, разрешено вошедшим в систему пользователям создавать сообщения, а автору сообщения - редактировать или удалять его.

По мере реализации каждого представления продолжайте работу сервера разработки. Сохраняя изменения, попробуйте перейти по URL-адресу в браузере и протестировать их.

### Схема (Blueprint)

Определите схему и зарегистрируйте его в фабрике приложений.

&#x20;**`flaskr/blog.py`**

```python
from flask import (
    Blueprint, flash, g, redirect, render_template, request, url_for
)
from werkzeug.exceptions import abort

from flaskr.auth import login_required
from flaskr.db import get_db

bp = Blueprint('blog', __name__)
```

Импортируйте и зарегистрируйте схему из фабрики с помощью **app.register\_blueprint ()**. Поместите новый код в конец фабричной функции перед возвратом приложения.

&#x20;**`flaskr/__init__.py`**

```python
def create_app():
    app = ...
    # существующий код опущен

    from . import blog
    app.register_blueprint(blog.bp)
    app.add_url_rule('/', endpoint='index')

    return app
```

В отличие от схемы проверки подлинности, схема блога не имеет **url\_prefix**. Таким образом, представление индекса будет в `/`, представление создания **create** - в `/create` и так далее. Блог - это основная функция **Flaskr**, поэтому имеет смысл, что индекс блога будет основным **index**.

Однако конечной точкой для представления **index**, определенного ниже, будет `blog.index`. Некоторые из представлений аутентификации ссылаются на конечную точку простого **index**. **app.add\_url\_rule ()** связывает имя конечной точки `'index'` с `/` url, так что `url_for ('index')` или `url_for ('blog.index')` оба будут работать, генерируя один и тот же `/` URL в любом случае.

В другом приложении вы можете присвоить проекту блога **url\_prefix** и определить отдельное представление **index** в фабрике приложений, подобное представлению **hello**. Тогда конечные точки **index** и **blog.index** и URL-адреса будут другими.

### Страница Index

**index** покажет все сообщения, сначала самые свежие. **JOIN** используется для того, чтобы в результате была доступна информация об авторе **user** из пользовательской таблицы.

&#x20;**`flaskr/blog.py`**

```python
@bp.route('/')
def index():
    db = get_db()
    posts = db.execute(
        'SELECT p.id, title, body, created, author_id, username'
        ' FROM post p JOIN user u ON p.author_id = u.id'
        ' ORDER BY created DESC'
    ).fetchall()
    return render_template('blog/index.html', posts=posts)
```

&#x20;**`flaskr/templates/blog/index.html`**

```python
{% raw %}
{% extends 'base.html' %}

{% block header %}
  <h1>{% block title %}Posts{% endblock %}</h1>
  {% if g.user %}
    <a class="action" href="{{ url_for('blog.create') }}">New</a>
  {% endif %}
{% endblock %}

{% block content %}
  {% for post in posts %}
    <article class="post">
      <header>
        <div>
          <h1>{{ post['title'] }}</h1>
          <div class="about">by {{ post['username'] }} on {{ post['created'].strftime('%Y-%m-%d') }}</div>
        </div>
        {% if g.user['id'] == post['author_id'] %}
          <a class="action" href="{{ url_for('blog.update', id=post['id']) }}">Edit</a>
        {% endif %}
      </header>
      <p class="body">{{ post['body'] }}</p>
    </article>
    {% if not loop.last %}
      <hr>
    {% endif %}
  {% endfor %}
{% endblock %}
{% endraw %}
```

Когда пользователь входит в систему, блок заголовка **header** добавляет ссылку на представление создания **create**. Если пользователь является автором сообщения, он увидит ссылку «Edit» для просмотра обновлений **update** для этого сообщения. `loop.last` - это специальная переменная, доступная внутри [**Jinja** для циклов](../../../shablonizatory/jinja/dokumentaciya-po-konstruktoru-shablonov.md#for). Она используется для отображения строки после каждого сообщения, кроме последнего, для визуального разделения их.

### Страница Create

Представление создания **create** работает так же, как представление регистрации авторизации **register**. Либо отображается форма, либо опубликованные данные проверяются, и сообщение добавляется в базу данных, либо отображается ошибка.

Декоратор **login\_required**, который вы написали ранее, используется в представлениях блога. Пользователь должен войти в систему, чтобы посетить эти представления, в противном случае они будут перенаправлены на страницу входа.

&#x20;**`flaskr/blog.py`**

```python
@bp.route('/create', methods=('GET', 'POST'))
@login_required
def create():
    if request.method == 'POST':
        title = request.form['title']
        body = request.form['body']
        error = None

        if not title:
            error = 'Title is required.'

        if error is not None:
            flash(error)
        else:
            db = get_db()
            db.execute(
                'INSERT INTO post (title, body, author_id)'
                ' VALUES (?, ?, ?)',
                (title, body, g.user['id'])
            )
            db.commit()
            return redirect(url_for('blog.index'))

    return render_template('blog/create.html')
```

&#x20;**`flaskr/templates/blog/create.html`**

```python
{% raw %}
{% extends 'base.html' %}

{% block header %}
  <h1>{% block title %}New Post{% endblock %}</h1>
{% endblock %}

{% block content %}
  <form method="post">
    <label for="title">Title</label>
    <input name="title" id="title" value="{{ request.form['title'] }}" required>
    <label for="body">Body</label>
    <textarea name="body" id="body">{{ request.form['body'] }}</textarea>
    <input type="submit" value="Save">
  </form>
{% endblock %}
{% endraw %}
```

### Страница Update

Представления обновления **update** и удаления **delete** должны будут получить сообщение **post** по идентификатору **id** и проверить, совпадает ли автор с вошедшим в систему пользователем. Чтобы избежать дублирования кода, вы можете написать функцию для получения сообщения **post** и вызова его из каждого представления.

&#x20;**`flaskr/blog.py`**

```python
def get_post(id, check_author=True):
    post = get_db().execute(
        'SELECT p.id, title, body, created, author_id, username'
        ' FROM post p JOIN user u ON p.author_id = u.id'
        ' WHERE p.id = ?',
        (id,)
    ).fetchone()

    if post is None:
        abort(404, "Post id {0} doesn't exist.".format(id))

    if check_author and post['author_id'] != g.user['id']:
        abort(403)

    return post
```

**abort ()** вызовет специальное исключение, которое возвращает код состояния HTTP. Для отображения ошибки требуется дополнительное сообщение, в противном случае используется сообщение по умолчанию. **404** означает «Not Found», а **403** означает «Forbidden». (**401** означает «Unauthorized», но вы перенаправляете на страницу входа вместо того, чтобы возвращать этот статус.)

Аргумент **check\_author** определен для того, чтобы функцию можно было использовать для получения сообщения **post** без проверки автора. Это было бы полезно, если бы вы написали представление для отображения отдельного сообщения на странице, где пользователь не имеет значения, потому что он не изменяет сообщение.

&#x20;**`flaskr/blog.py`**

```python
@bp.route('/<int:id>/update', methods=('GET', 'POST'))
@login_required
def update(id):
    post = get_post(id)

    if request.method == 'POST':
        title = request.form['title']
        body = request.form['body']
        error = None

        if not title:
            error = 'Title is required.'

        if error is not None:
            flash(error)
        else:
            db = get_db()
            db.execute(
                'UPDATE post SET title = ?, body = ?'
                ' WHERE id = ?',
                (title, body, id)
            )
            db.commit()
            return redirect(url_for('blog.index'))

    return render_template('blog/update.html', post=post)
```

В отличие от представлений, которые вы написали до сих пор, функция обновления **update** принимает аргумент _**id**_. Это соответствует `<int:id>` в маршруте. Настоящий URL-адрес будет выглядеть как `/1/update`. **Flask** захватит `1`, убедится, что это целое число, и передаст его в качестве аргумента _**id**_. Если вы не укажете **int:** и вместо этого укажете `<id>`, это будет строка. Чтобы сгенерировать URL-адрес страницы обновления, **url\_for ()** необходимо передать идентификатор _**id**_, чтобы он знал, что вводить: `url_for ('blog.update', id = post ['id'])`. Это также находится в файле `index.html` выше.

Представления создания **create** и обновления **update** выглядят очень похоже. Основное отличие состоит в том, что представление обновления **update** использует объект сообщения **post** и запрос **UPDATE** вместо **INSERT**. С помощью некоторого умного рефакторинга вы можете использовать одно представление и шаблон для обоих действий, но для учебника будет проще хранить их отдельно.

&#x20;**`flaskr/templates/blog/update.html`**

```python
{% raw %}
{% extends 'base.html' %}

{% block header %}
  <h1>{% block title %}Edit "{{ post['title'] }}"{% endblock %}</h1>
{% endblock %}

{% block content %}
  <form method="post">
    <label for="title">Title</label>
    <input name="title" id="title"
      value="{{ request.form['title'] or post['title'] }}" required>
    <label for="body">Body</label>
    <textarea name="body" id="body">{{ request.form['body'] or post['body'] }}</textarea>
    <input type="submit" value="Save">
  </form>
  <hr>
  <form action="{{ url_for('blog.delete', id=post['id']) }}" method="post">
    <input class="danger" type="submit" value="Delete" onclick="return confirm('Are you sure?');">
  </form>
{% endblock %}
{% endraw %}
```

Этот шаблон имеет две формы. Первый отправляет отредактированные данные на текущую страницу (`/<id>/update`). Другая форма содержит только кнопку и определяет атрибут действия **action**, который вместо этого отправляет сообщение в представление удаления. Кнопка использует некоторый **JavaScript** для отображения диалогового окна подтверждения перед отправкой.

Шаблон `{{ request.form ['title'] or post ['title'] }}` используется для выбора данных, отображаемых в форме. Если форма не была отправлена, отображаются исходные данные публикации, но если были опубликованы недопустимые данные формы, вы хотите отобразить их, чтобы пользователь мог исправить ошибку, поэтому вместо этого используется **request.form**. **request** - еще одна переменная, которая автоматически доступна в шаблонах.

### Страница Delete

Представление удаления **delete** не имеет собственного шаблона, кнопка удаления является частью `update.html` и отправляет сообщение по URL-адресу `/<id>/delete`. Поскольку шаблона нет, он будет обрабатывать только метод **POST**, а затем перенаправлять в представление **index**.

&#x20;**`flaskr/blog.py`**

```python
@bp.route('/<int:id>/delete', methods=('POST',))
@login_required
def delete(id):
    get_post(id)
    db = get_db()
    db.execute('DELETE FROM post WHERE id = ?', (id,))
    db.commit()
    return redirect(url_for('blog.index'))
```

Поздравляем, вы закончили писать приложение! Найдите время, чтобы опробовать все в браузере. Однако до завершения проекта еще многое предстоит сделать.

Продолжить, чтобы сделать проект инсталируемым.

## Сделайте проект устанавливаемым

Возможность установки проекта означает, что вы можете создать файл распространения _**distribution**_ и установить его в другой среде, точно так же, как вы установили **Flask** в среду своего проекта. Это делает развертывание вашего проекта таким же, как установку любой другой библиотеки, поэтому вы используете все стандартные инструменты Python для управления всем.

Установка также дает другие преимущества, которые могут быть не очевидны из учебника или для нового пользователя Python, в том числе:

* В настоящее время **Python** и **Flask** понимают, как использовать пакет **flaskr**, только потому, что вы запускаете его из каталога своего проекта. Установка означает, что вы можете импортировать его независимо от того, откуда вы запускаете.
* Вы можете управлять зависимостями своего проекта так же, как это делают другие пакеты, поэтому `pip install yourproject.whl` устанавливает их.
* Инструменты тестирования могут изолировать вашу тестовую среду от среды разработки.

{% hint style="info" %}
**Примечание:**

Это вводится в конце руководства, но в ваших будущих проектах вы всегда должны начинать с этого.
{% endhint %}

### Описание проект

Файл `setup.py` описывает ваш проект и принадлежащие ему файлы.

&#x20;**`setup.py`**

```python
from setuptools import find_packages, setup

setup(
    name='flaskr',
    version='1.0.0',
    packages=find_packages(),
    include_package_data=True,
    zip_safe=False,
    install_requires=[
        'flask',
    ],
)
```

**packages** сообщает Python, какие каталоги пакетов (и файлы Python, которые они содержат) включать. **find\_packages ()** находит эти каталоги автоматически, поэтому вам не нужно их вводить. Чтобы включить другие файлы, такие как каталоги **static** и **templates**, устанавливается **include\_package\_data**. Python нужен другой файл с именем `MANIFEST.in`, чтобы сообщить, что это за другие данные.

&#x20;**`MANIFEST.in`**

```python
include flaskr/schema.sql
graft flaskr/static
graft flaskr/templates
global-exclude *.pyc
```

Это говорит Python скопировать все в каталогах **static** и **templates**, а также в файле `schema.sql`, но исключить все файлы байт-кода.

См. [официальное руководство по упаковке](https://packaging.python.org/tutorials/packaging-projects/) для другого объяснения используемых файлов и опций.

### Установка проекта

Используйте **pip** для установки вашего проекта в виртуальной среде.

```bash
$ pip install -e .
```

Это указывает **pip** найти файл `setup.py` в текущем каталоге и установить его в режиме редактирования _**editable**_ или разработки _**development**_. Редактируемый режим означает, что по мере внесения изменений в локальный код вам нужно будет переустановить только в том случае, если вы измените метаданные о проекте, такие как его зависимости.

Вы можете заметить, что проект теперь установлен с `pip list`.

```bash
$ pip list

Package        Version   Location
-------------- --------- ----------------------------------
click          6.7
Flask          1.0
flaskr         1.0.0     /home/user/Projects/flask-tutorial
itsdangerous   0.24
Jinja2         2.10
MarkupSafe     1.0
pip            9.0.3
setuptools     39.0.1
Werkzeug       0.14.1
wheel          0.30.0
```

Ничего не меняется от того, как вы ведете свой проект до сих пор. **FLASK\_APP** по-прежнему настроен на **flaskr**, а `flask run` по-прежнему запускает приложение, но вы можете вызывать его из любого места, а не только из каталога `flask-tutorial`.

Перейти к тестовому покрытию.

## Тестовое покрытие

Написание модульных тестов для вашего приложения позволяет вам проверить, что написанный вами код работает так, как вы ожидаете. **Flask** предоставляет тестовый клиент, который имитирует запросы к приложению и возвращает данные ответа.

Вам следует протестировать как можно больше кода. Код в функциях выполняется только при вызове функции, а код в ветвях, таких как блоки **if**, выполняется только при выполнении условия. Вы хотите убедиться, что каждая функция протестирована с данными, охватывающими каждую ветвь.

Чем ближе вы подойдете к 100% охвату, тем более уверенным будет то, что внесение изменений неожиданно не изменит другое поведение. Однако 100% покрытие не гарантирует, что в вашем приложении нет ошибок. В частности, он не проверяет, как пользователь взаимодействует с приложением в браузере. Несмотря на это, тестовое покрытие - важный инструмент для использования во время разработки.

{% hint style="info" %}
**Примечание:**

Это вводится в конце руководства, но в ваших будущих проектах вам следует тестировать их по мере разработки.
{% endhint %}

Вы будете использовать [**pytest**](https://docs.pytest.org/en/stable/) и [**coverage**](https://coverage.readthedocs.io/en/coverage-5.4/) для тестирования и измерения вашего кода. Установите их оба:

```bash
$ pip install pytest coverage
```

### Настройка и фикстуры

Код теста находится в каталоге тестов. Этот каталог находится рядом с пакетом **flaskr**, а не внутри него. Файл `tests/conftest.py` содержит функции настройки, называемые приборами _**fixtures**_, которые будет использовать каждый тест. Тесты находятся в модулях Python, которые начинаются с `test_`, и каждая тестовая функция в этих модулях также начинается с `test_`.

Каждый тест создает новый временный файл базы данных и заполняет некоторые данные, которые будут использоваться в тестах. Напишите файл **SQL**, чтобы вставить эти данные.

&#x20;**`tests/data.sql`**

```sql
INSERT INTO user (username, password)
VALUES
  ('test', 'pbkdf2:sha256:50000$TCI4GzcX$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f'),
  ('other', 'pbkdf2:sha256:50000$kJPKsz6N$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79');

INSERT INTO post (title, body, author_id, created)
VALUES
  ('test title', 'test' || x'0a' || 'body', 1, '2018-01-01 00:00:00');
```

Приспособление приложения **app** вызовет фабрику и передаст **test\_config** для настройки приложения и базы данных для тестирования вместо использования вашей локальной конфигурации разработки.

&#x20;**`tests/conftest.py`**

```sql
import os
import tempfile

import pytest
from flaskr import create_app
from flaskr.db import get_db, init_db

with open(os.path.join(os.path.dirname(__file__), 'data.sql'), 'rb') as f:
    _data_sql = f.read().decode('utf8')


@pytest.fixture
def app():
    db_fd, db_path = tempfile.mkstemp()

    app = create_app({
        'TESTING': True,
        'DATABASE': db_path,
    })

    with app.app_context():
        init_db()
        get_db().executescript(_data_sql)

    yield app

    os.close(db_fd)
    os.unlink(db_path)


@pytest.fixture
def client(app):
    return app.test_client()


@pytest.fixture
def runner(app):
    return app.test_cli_runner()
```

****[**tempfile.mkstemp ()**](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp) создает и открывает временный файл, возвращая файловый объект и путь к нему. Путь к **DATABASE** переопределяется, поэтому он указывает на этот временный путь, а не на папку экземпляра. После задания пути создаются таблицы базы данных и вставляются тестовые данные. По окончании теста временный файл закрывается и удаляется.

**TESTING** сообщает **Flask**, что приложение находится в тестовом режиме. **Flask** меняет некоторое внутреннее поведение, чтобы его было легче тестировать, и другие расширения также могут использовать флаг, чтобы упростить их тестирование.

Фикстура **client** вызывает **app.test\_client ()** с объектом приложения, созданным прибором приложения **app**. Тесты будут использовать клиента для выполнения запросов к приложению без запуска сервера.

Фикстура **runner** аналогично **client**. **app.test\_cli\_runner ()** создает средство запуска, которое может вызывать команды **Click**, зарегистрированные в приложении.

**Pytest** использует фикстуры, сопоставляя их имена функций с именами аргументов в тестовых функциях. Например, функция **test\_hello**, которую вы напишете следующей, принимает аргумент **client**. **Pytest** сопоставляет это с функцией фикстуры **client**, вызывает ее и передает возвращенное значение тестовой функции.

### Фабрика (Factory)

В самой фабрике особо нечего проверять. Большая часть кода будет выполняться для каждого теста, поэтому, если что-то не удается, другие тесты это заметят.

Единственное поведение, которое можно изменить, - это прохождение тестовой конфигурации. Если **config** не передан, должна быть какая-то конфигурация по умолчанию, в противном случае конфигурация должна быть переопределена.

&#x20;**`tests/test_factory.py`**

```python
from flaskr import create_app


def test_config():
    assert not create_app().testing
    assert create_app({'TESTING': True}).testing


def test_hello(client):
    response = client.get('/hello')
    assert response.data == b'Hello, World!'
```

Вы добавили маршрут **hello** в качестве примера при написании фабрики в начале руководства. Он возвращает «Hello, World!», Поэтому тест проверяет соответствие данных ответа.

### База данных (Database)

В контексте приложения **get\_db** должен возвращать одно и то же соединение при каждом вызове. После контекста соединение должно быть закрыто.

&#x20;**`tests/test_db.py`**

```python
import sqlite3

import pytest
from flaskr.db import get_db


def test_get_close_db(app):
    with app.app_context():
        db = get_db()
        assert db is get_db()

    with pytest.raises(sqlite3.ProgrammingError) as e:
        db.execute('SELECT 1')

    assert 'closed' in str(e.value)
```

Команда **init-db** должна вызвать функцию **init\_db** и вывести сообщение.

&#x20;**`tests/test_db.py`**

```python
def test_init_db_command(runner, monkeypatch):
    class Recorder(object):
        called = False

    def fake_init_db():
        Recorder.called = True

    monkeypatch.setattr('flaskr.db.init_db', fake_init_db)
    result = runner.invoke(args=['init-db'])
    assert 'Initialized' in result.output
    assert Recorder.called
```

В этом тесте используется фикстура **Monkeypatch** **Pytest** для замены функции **init\_db** той, которая записывает, что она была вызвана. Приставка **runner**, которую вы написали выше, используется для вызова команды **init-db** по имени.

### Аутентификация

Для большинства представлений пользователь должен войти в систему. Самый простой способ сделать это в тестах - отправить запрос **POST** в представление входа с клиентом. Вместо того, чтобы писать это каждый раз, вы можете написать класс с методами для этого и использовать приспособление, чтобы передавать его клиенту для каждого теста.

&#x20;**`tests/conftest.py`**

```python
class AuthActions(object):
    def __init__(self, client):
        self._client = client

    def login(self, username='test', password='test'):
        return self._client.post(
            '/auth/login',
            data={'username': username, 'password': password}
        )

    def logout(self):
        return self._client.get('/auth/logout')


@pytest.fixture
def auth(client):
    return AuthActions(client)
```

С помощью фикстуры **auth** вы можете вызвать **auth.login ()** в тесте, чтобы войти в систему как тестовый пользователь **test**, который был вставлен как часть тестовых данных в фикстур приложения **app**.

Представление **register** должно успешно отображаться при **GET**. При **POST** с действительными данными формы он должен перенаправлять на URL-адрес входа, а данные пользователя должны быть в базе данных. Недействительные данные должны отображать сообщения об ошибках.

&#x20;**`tests/test_auth.py`**

```python
import pytest
from flask import g, session
from flaskr.db import get_db


def test_register(client, app):
    assert client.get('/auth/register').status_code == 200
    response = client.post(
        '/auth/register', data={'username': 'a', 'password': 'a'}
    )
    assert 'http://localhost/auth/login' == response.headers['Location']

    with app.app_context():
        assert get_db().execute(
            "select * from user where username = 'a'",
        ).fetchone() is not None


@pytest.mark.parametrize(('username', 'password', 'message'), (
    ('', '', b'Username is required.'),
    ('a', '', b'Password is required.'),
    ('test', 'test', b'already registered'),
))
def test_register_validate_input(client, username, password, message):
    response = client.post(
        '/auth/register',
        data={'username': username, 'password': password}
    )
    assert message in response.data
```

****[**client.get ()**](https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client.get) делает запрос **GET** и возвращает объект **Response**, возвращенный **Flask**. Точно так же [**client.post ()**](https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client.post) выполняет запрос **POST**, конвертируя данные словаря **data** в данные формы.

Чтобы проверить, что страница успешно отображается, выполняется простой запрос и проверяется наличие `200 OK` **status\_code**. Если рендеринг завершился неудачно, **Flask** вернет код внутренней ошибки сервера `500 Internal Server Error`.

**headers** будут иметь заголовок **Location** с URL-адресом входа, когда представление **register** перенаправляется на представление входа.

**data** содержит тело ответа в байтах. Если вы ожидаете, что на странице отобразится определенное значение, проверьте, есть ли оно в данных **data**. Байты нужно сравнивать с байтами. Если вы хотите сравнить текст в Юникоде, используйте вместо него [get\_data (as\_text = True)](https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.BaseResponse.get\_data).

**pytest.mark.parametrize** указывает **Pytest** запускать одну и ту же тестовую функцию с разными аргументами. Вы используете его здесь, чтобы проверить разные недопустимые вводимые данные и сообщения об ошибках, не записывая один и тот же код три раза.

Тесты для входа в систему **login** очень похожи на тесты для регистрации **register**. Вместо того, чтобы тестировать данные в базе данных, для **session** после входа в систему должен быть установлен **user\_id**.

&#x20;**`tests/test_auth.py`**

```python
def test_login(client, auth):
    assert client.get('/auth/login').status_code == 200
    response = auth.login()
    assert response.headers['Location'] == 'http://localhost/'

    with client:
        client.get('/')
        assert session['user_id'] == 1
        assert g.user['username'] == 'test'


@pytest.mark.parametrize(('username', 'password', 'message'), (
    ('a', 'test', b'Incorrect username.'),
    ('test', 'a', b'Incorrect password.'),
))
def test_login_validate_input(auth, username, password, message):
    response = auth.login(username, password)
    assert message in response.data
```

Использование **client** в блоке **with** позволяет получить доступ к контекстным переменным, таким как **session**, после того, как ответ будет возвращен. Обычно доступ к **session** вне запроса вызывает ошибку.

Проверка выхода из системы **logout** противоположна входу в систему **login**. **session** не должна содержать **user\_id** после выхода из системы.

&#x20;**`tests/test_auth.py`**

```python
def test_logout(client, auth):
    auth.login()

    with client:
        auth.logout()
        assert 'user_id' not in session
```

### Блог

Все представления блога используют фикстуру **auth**, который вы написали ранее. Вызов **auth.login ()** и последующие запросы от клиента будут зарегистрированы как тестовый пользователь **test**.

В представлении **index** должна отображаться информация о публикации, которая была добавлена с тестовыми данными. При входе в систему как автор должна быть ссылка для редактирования сообщения.

Вы также можете протестировать еще несколько способов аутентификации при тестировании представления **index**. Когда вы не вошли в систему, на каждой странице отображаются ссылки для входа или регистрации. При входе в систему есть ссылка для выхода.

&#x20;**`tests/test_blog.py`**

```python
import pytest
from flaskr.db import get_db


def test_index(client, auth):
    response = client.get('/')
    assert b"Log In" in response.data
    assert b"Register" in response.data

    auth.login()
    response = client.get('/')
    assert b'Log Out' in response.data
    assert b'test title' in response.data
    assert b'by test on 2018-01-01' in response.data
    assert b'test\nbody' in response.data
    assert b'href="/1/update"' in response.data
```

Пользователь должен войти в систему, чтобы получить доступ к представлениям **create**, **update** и **delete**. Пользователь, вошедший в систему, должен быть автором сообщения для доступа к **update** и **delete**, в противном случае возвращается статус `403 Forbidden`. Если сообщение _**post**_ с указанным идентификатором _**id**_ не существует, при **update** и **delete** должно возвращаться сообщение `404 Not Found`.

&#x20;**`tests/test_blog.py`**

```python
@pytest.mark.parametrize('path', (
    '/create',
    '/1/update',
    '/1/delete',
))
def test_login_required(client, path):
    response = client.post(path)
    assert response.headers['Location'] == 'http://localhost/auth/login'


def test_author_required(app, client, auth):
    # сменить автора сообщения на другого пользователя
    with app.app_context():
        db = get_db()
        db.execute('UPDATE post SET author_id = 2 WHERE id = 1')
        db.commit()

    auth.login()
    # текущий пользователь не может изменять сообщение другого пользователя
    assert client.post('/1/update').status_code == 403
    assert client.post('/1/delete').status_code == 403
    # текущий пользователь не видит ссылку для редактирования
    assert b'href="/1/update"' not in client.get('/').data


@pytest.mark.parametrize('path', (
    '/2/update',
    '/2/delete',
))
def test_exists_required(client, auth, path):
    auth.login()
    assert client.post(path).status_code == 404
```

Представления **create** и **update** должны отображать и возвращать статус `200 OK` для запроса **GET**. Когда действительные данные отправляются в запросе **POST**, **create** должен вставить новые данные публикации в базу данных, а **update** должен изменить существующие данные. Обе страницы должны отображать сообщение об ошибке о недопустимых данных.

&#x20;**`tests/test_blog.py`**

```python
def test_create(client, auth, app):
    auth.login()
    assert client.get('/create').status_code == 200
    client.post('/create', data={'title': 'created', 'body': ''})

    with app.app_context():
        db = get_db()
        count = db.execute('SELECT COUNT(id) FROM post').fetchone()[0]
        assert count == 2


def test_update(client, auth, app):
    auth.login()
    assert client.get('/1/update').status_code == 200
    client.post('/1/update', data={'title': 'updated', 'body': ''})

    with app.app_context():
        db = get_db()
        post = db.execute('SELECT * FROM post WHERE id = 1').fetchone()
        assert post['title'] == 'updated'


@pytest.mark.parametrize('path', (
    '/create',
    '/1/update',
))
def test_create_update_validate(client, auth, path):
    auth.login()
    response = client.post(path, data={'title': '', 'body': ''})
    assert b'Title is required.' in response.data
```

Представление **delete** должно перенаправлять на URL-адрес **index**, и сообщение больше не должно существовать в базе данных.

&#x20;**`tests/test_blog.py`**

```python
def test_delete(client, auth, app):
    auth.login()
    response = client.post('/1/delete')
    assert response.headers['Location'] == 'http://localhost/'

    with app.app_context():
        db = get_db()
        post = db.execute('SELECT * FROM post WHERE id = 1').fetchone()
        assert post is None
```

### Выполнение тестов

В файл `setup.cfg` проекта можно добавить некоторую дополнительную конфигурацию, которая не требуется, но делает выполнение тестов с охватом менее подробным.

&#x20;**`setup.cfg`**

```bash
[tool:pytest]
testpaths = tests

[coverage:run]
branch = True
source =
    flaskr
```

Для запуска тестов используйте команду **pytest**. Он найдет и запустит все написанные вами тестовые функции.

```bash
$ pytest

========================= test session starts ==========================
platform linux -- Python 3.6.4, pytest-3.5.0, py-1.5.3, pluggy-0.6.0
rootdir: /home/user/Projects/flask-tutorial, inifile: setup.cfg
collected 23 items

tests/test_auth.py ........                                      [ 34%]
tests/test_blog.py ............                                  [ 86%]
tests/test_db.py ..                                              [ 95%]
tests/test_factory.py ..                                         [100%]

====================== 24 passed in 0.64 seconds =======================
```

Если какие-либо тесты не пройдут, **pytest** покажет возникшую ошибку. Вы можете запустить `pytest -v`, чтобы получить список каждой тестовой функции, а не точек.

Чтобы измерить покрытие кода ваших тестов, используйте команду **coverage** для запуска **pytest** вместо того, чтобы запускать его напрямую.

```bash
$ coverage run -m pytest
```

Вы можете просмотреть в терминале простой отчет о покрытии:

```bash
$ coverage report

Name                 Stmts   Miss Branch BrPart  Cover
------------------------------------------------------
flaskr/__init__.py      21      0      2      0   100%
flaskr/auth.py          54      0     22      0   100%
flaskr/blog.py          54      0     16      0   100%
flaskr/db.py            24      0      4      0   100%
------------------------------------------------------
TOTAL                  153      0     44      0   100%
```

Отчет HTML позволяет вам увидеть, какие строки были охвачены в каждом файле:

```bash
$ coverage html
```

Это создает файлы в каталоге **htmlcov**. Откройте в браузере `htmlcov/index.html`, чтобы просмотреть отчет.

Продолжить развертывание в производственной среде.

## Развертывание приложения

В этой части руководства предполагается, что у вас есть сервер, на котором вы хотите развернуть свое приложение. В нем дается обзор того, как создать файл дистрибутива и установить его, но не вдаваться в подробности о том, какой сервер или программное обеспечение использовать. Вы можете настроить новую среду на своем компьютере для разработки, чтобы опробовать приведенные ниже инструкции, но, вероятно, не следует использовать ее для размещения реального общедоступного приложения. См. в разделе «Варианты развертывания» список множества различных способов размещения вашего приложения.

### Сборка и установка

Если вы хотите развернуть свое приложение в другом месте, вы создаете файл распространения. Текущий стандарт распространения Python - это формат **wheel** с расширением `.whl`. Убедитесь, что сначала установлена библиотека **wheel**:

```bash
$ pip install wheel
```

Запуск `setup.py` с Python дает вам инструмент командной строки для выполнения команд, связанных со сборкой. Команда **bdist\_wheel** создаст распространяемый файл **wheel**.

```bash
$ python setup.py bdist_wheel
```

Вы можете найти файл в `dist/flaskr-1.0.0-py3-none-any.whl`. Имя файла имеет формат {название проекта} - {версия} - {тег Python} - {тег abi} - {тег платформы}.

Скопируйте этот файл на другой компьютер, [настройте новый **virtualenv**](ustanovka.md#sozdanie-sredy), затем установите файл с помощью **pip**.

```bash
$ pip install flaskr-1.0.0-py3-none-any.whl
```

**Pip** установит ваш проект вместе с его зависимостями.

Поскольку это другой компьютер, вам нужно снова запустить **init-db**, чтобы создать базу данных в папке экземпляра.

```bash
$ export FLASK_APP=flaskr
$ flask init-db
```

Когда **Flask** обнаруживает, что он установлен (не в редактируемом режиме), он использует другой каталог для папки экземпляра. Вместо этого вы можете найти его в `venv/var/flaskr-instance`.

### Настройка секретного ключа

В начале руководства вы указали значение по умолчанию для **SECRET\_KEY**. Это должно быть изменено на несколько случайных байтов при развертывании. В противном случае злоумышленники могут использовать открытый ключ `'dev'` для изменения файла cookie сеанса или чего-либо еще, что использует секретный ключ.

Вы можете использовать следующую команду для вывода случайного секретного ключа:

```bash
$ python -c 'import os; print(os.urandom(16))'

b'_5#y2L"F4Q8z\n\xec]/'
```

Создайте файл `config.py` в папке экземпляра, из которого фабрика будет читать, если он существует. Скопируйте в него сгенерированное значение.

&#x20;**`venv/var/flaskr-instance/config.py`**

```python
SECRET_KEY = b'_5#y2L"F4Q8z\n\xec]/'
```

Здесь вы также можете установить любую другую необходимую конфигурацию, хотя **SECRET\_KEY** - единственный, необходимый для **Flaskr**.

### Запуск с производственным сервером

При публичном запуске, а не в разработке, вам не следует использовать встроенный сервер разработки (`flask run`). Сервер разработки предоставляется **Werkzeug** для удобства, но не предназначен для обеспечения высокой эффективности, стабильности или безопасности.

Вместо этого используйте производственный сервер **WSGI**. Например, чтобы использовать [Waitress](https://docs.pylonsproject.org/projects/waitress/en/stable/), сначала установите ее в виртуальной среде:

```bash
$ pip install waitress
```

Вам нужно сообщить **Waitress** о своем приложении, но оно не использует **FLASK\_APP**, как `flask run`. Вам нужно указать ему импортировать и вызвать фабрику приложений, чтобы получить объект приложения.

```bash
$ waitress-serve --call 'flaskr:create_app'

Serving on http://0.0.0.0:8080
```

См. в разделе «Варианты развертывания» список множества различных способов размещения вашего приложения. **Waitress** - это просто пример, выбранный для учебника, потому что он поддерживает как **Windows**, так и **Linux**. Есть еще много серверов **WSGI** и вариантов развертывания, которые вы можете выбрать для своего проекта.

Переходим к продолжению развития.

## Продолжайте развиваться!

На протяжении всего руководства вы узнали о нескольких концепциях **Flask** и **Python**. Вернитесь и просмотрите руководство и сравните свой код с шагами, которые вы предприняли для этого. Сравните свой проект с [примером проекта](https://github.com/pallets/flask/tree/1.1.2/examples/tutorial), который может выглядеть немного иначе из-за пошагового характера руководства.

**Flask** - это гораздо больше, чем вы видели до сих пор. Тем не менее, теперь у вас есть все необходимое для разработки собственных веб-приложений. Ознакомьтесь с [кратким руководством](bystryi-start-flask.md#bystryi-start), чтобы узнать о возможностях **Flask**, а затем погрузитесь в документацию, чтобы продолжить обучение. **Flask** за кулисами использует [Jinja](../../../shablonizatory/jinja/), [Click](https://palletsprojects.com/p/click/), [Werkzeug](https://palletsprojects.com/p/werkzeug/) и [ItsDangerous](https://palletsprojects.com/p/itsdangerous/), и все они также имеют свою собственную документацию. Вас также заинтересуют расширения, которые делают такие задачи, как работа с базой данных или проверка данных форм, проще и эффективнее.

Если вы хотите продолжить разработку проекта **Flaskr**, вот несколько идей, что попробовать дальше:

* Подробный вид для отображения отдельного сообщения. Щелкните заголовок сообщения, чтобы перейти на его страницу.
* Нравится / не нравится пост.
* Комментарии.
* Теги. При нажатии на тег отображаются все сообщения с этим тегом.
* Поле поиска, которое фильтрует страницу индекса по имени.
* Пагинация. Показывать только 5 сообщений на странице.
* Загрузите изображение для публикации.
* Форматируйте сообщения с помощью Markdown.
* RSS-канал новых сообщений.

Получайте удовольствие и создавайте классные приложения!
