# AJAX с jQuery

[jQuery](https://jquery.com/) - это небольшая библиотека **JavaScript**, обычно используемая для упрощения работы с **DOM** и **JavaScript** в целом. Это идеальный инструмент для повышения динамичности веб-приложений за счет обмена **JSON** между сервером и клиентом.

Сам **JSON** - это очень легкий транспортный формат, очень похожий на то, как выглядят примитивы Python (числа, строки, словари и списки), который широко поддерживается и очень легко анализируется. Он стал популярным несколько лет назад и быстро заменил **XML** в качестве транспортного формата в веб-приложениях.

## Загрузка jQuery

Чтобы использовать **jQuery**, вы должны сначала загрузить его и поместить в статическую папку вашего приложения, а затем убедиться, что оно загружено. В идеале у вас есть шаблон макета, который используется для всех страниц, где вам просто нужно добавить оператор сценария в нижнюю часть вашего `<body>` для загрузки **jQuery**:

```markup
<script type=text/javascript src="{{
  url_for('static', filename='jquery.js') }}"></script>
```

Другой метод - использование [API библиотек AJAX](https://developers.google.com/speed/libraries/) от Google для загрузки **jQuery**:

```markup
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="{{
  url_for('static', filename='jquery.js') }}">\x3C/script>')</script>
```

В этом случае вы должны поместить **jQuery** в свою статическую папку в качестве запасного варианта, но сначала он попытается загрузить его непосредственно из **Google**. Это имеет то преимущество, что ваш веб-сайт, вероятно, будет загружаться быстрее для пользователей, если они перешли хотя бы на один другой веб-сайт, прежде чем использовать ту же версию **jQuery** от **Google**, потому что он уже будет в кеше браузера.

## Где мой сайт?

Вы знаете, где находится ваше приложение? Если вы разрабатываете, ответ довольно прост: это что-то на порту **localhost** и непосредственно в корне этого сервера. Но что, если позже вы решите переместить свое приложение в другое место? Например, на `http://example.com/myapp`? На стороне сервера это никогда не было проблемой, потому что мы использовали удобную функцию [url\_for ()](../api-dokumentaciya-flask/poleznye-funkcii-i-klassy-flask.md#flask-url\_for), которая могла бы ответить на этот вопрос за нас, но если мы используем **jQuery**, мы не должны жестко кодировать путь к приложению, а сделать его динамическим, так как же мы это делаем?

Простым способом было бы добавить на нашу страницу тег скрипта, который устанавливает глобальную переменную в префикс корня приложения. Что-то вроде этого:

```markup
<script type=text/javascript>
  $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
</script>
```

`|safe` необходим во **Flask** до версии `0.10`, чтобы **Jinja** не избегал кодированной строки **JSON** с помощью правил HTML. Обычно это было бы необходимо, но здесь мы находимся внутри блока **script**, где применяются другие правила.

{% hint style="info" %}
**Информация для профессионалов:**

В HTML тег **script** объявлен **CDATA**, что означает, что объекты не будут анализироваться. Все до **\</script>** обрабатывается как скрипт. Это также означает, что между тегами скрипта никогда не должно быть никаких символов **\</**. **|tojson** достаточно любезен, чтобы поступить здесь правильно и избежать косой черты (**\{{ "\</script>"|tojson|safe \}}** отображается как **"<\\/script>"**).

В **Flask 0.10** он идет дальше и экранирует все теги HTML с помощью экранирования Unicode. Это позволяет **Flask** автоматически помечать результат как безопасный для HTML.
{% endhint %}

## Функции просмотра JSON

Теперь давайте создадим функцию на стороне сервера, которая принимает два аргумента URL с числами, которые следует сложить вместе и затем отправить обратно в приложение в объекте **JSON**. Это действительно нелепый пример, и это то, что вы обычно делаете только на стороне клиента, но простой пример, показывающий, как бы вы, тем не менее, использовали **jQuery** и **Flask**:

```python
from flask import Flask, jsonify, render_template, request
app = Flask(__name__)

@app.route('/_add_numbers')
def add_numbers():
    a = request.args.get('a', 0, type=int)
    b = request.args.get('b', 0, type=int)
    return jsonify(result=a + b)

@app.route('/')
def index():
    return render_template('index.html')
```

Как видите, я также добавил сюда метод **index**, который отображает шаблон. Этот шаблон загрузит **jQuery**, как указано выше, и будет иметь небольшую форму, в которой мы можем добавить два числа и ссылку для запуска функции на стороне сервера.

Обратите внимание, что здесь мы используем метод Werkzeug [get ()](https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict.get), который никогда не даст сбой. Если ключ отсутствует, возвращается значение по умолчанию (здесь `0`). Кроме того, он может преобразовывать значения в определенный тип (например, в нашем случае **int**). Это особенно удобно для кода, который запускается сценарием (**API**, **JavaScript** и т. Д.), Потому что в этом случае вам не нужны специальные отчеты об ошибках.

## HTML

Ваш шаблон `index.html` должен либо расширять шаблон `layout.html` с загруженным **jQuery** и установленной переменной **$SCRIPT\_ROOT**, либо делать это сверху. Вот HTML-код, необходимый для нашего небольшого приложения (`index.html`). Обратите внимание, что здесь мы также помещаем скрипт прямо в HTML. Обычно лучше записать это в отдельный файл сценария:

```javascript
<script type=text/javascript>
  $(function() {
    $('a#calculate').bind('click', function() {
      $.getJSON($SCRIPT_ROOT + '/_add_numbers', {
        a: $('input[name="a"]').val(),
        b: $('input[name="b"]').val()
      }, function(data) {
        $("#result").text(data.result);
      });
      return false;
    });
  });
</script>
<h1>jQuery Example</h1>
<p><input type=text size=5 name=a> +
   <input type=text size=5 name=b> =
   <span id=result>?</span>
<p><a href=# id=calculate>calculate server side</a>
```

Я не буду здесь подробно останавливаться на том, как работает **jQuery**, просто кратко объясню небольшой фрагмент кода выше:

1. `$(function () {...})` определяет код, который должен запускаться после того, как браузер завершит загрузку основных частей страницы.
2. `$('selector')` выбирает элемент и позволяет вам работать с ним.
3. `element.bind ('event', func)` указывает функцию, которая должна запускаться, когда пользователь щелкает элемент. Если эта функция возвращает `false`, поведение по умолчанию не сработает (в этом случае перейдите по URL-адресу `#`).
4. `$.getJSON (url, data, func)` отправляет запрос **GET** на **url** и отправляет содержимое объекта данных в качестве параметров запроса. Как только данные поступят, он вызовет данную функцию с возвращаемым значением в качестве аргумента. Обратите внимание, что мы можем использовать здесь переменную **$SCRIPT\_ROOT**, которую мы установили ранее.

Посмотрите [пример исходного кода](https://github.com/pallets/flask/tree/1.1.2/examples/javascript) полного приложения, демонстрирующего код на этой странице, а также то же самое с использованием **XMLHttpRequest** и **fetch**.
