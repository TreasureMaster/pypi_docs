# Использование SQLite3 с Flask

В **Flask** вы можете легко реализовать открытие соединений с базой данных по запросу и их закрытие, когда контекст умирает (обычно в конце запроса).

Вот простой пример того, как вы можете использовать `SQLite 3` с **Flask**:

```python
import sqlite3
from flask import g

DATABASE = '/path/to/database.db'

def get_db():
    db = getattr(g, '_database', None)
    if db is None:
        db = g._database = sqlite3.connect(DATABASE)
    return db

@app.teardown_appcontext
def close_connection(exception):
    db = getattr(g, '_database', None)
    if db is not None:
        db.close()
```

Теперь, чтобы использовать базу данных, приложение должно либо иметь активный контекст приложения (что всегда истинно, если есть запрос в полете), либо создавать сам контекст приложения. В этот момент можно использовать функцию **get\_db** для получения текущего соединения с базой данных. Всякий раз, когда контекст разрушается, соединение с базой данных будет разорвано.

Примечание: если вы используете `Flask 0.9` или более раннюю версию, вам нужно использовать **flask.\_app\_ctx\_stack.top** вместо **g**, поскольку объект [flask.g](../api-dokumentaciya-flask/globalnyi-obekt-prilozheniya-flask.md#flask-g) был привязан к запросу, а не к контексту приложения.

Пример:

```python
@app.route('/')
def index():
    cur = get_db().cursor()
    ...
```

{% hint style="info" %}
Имейте в виду, что функции запроса **teardown** и **appcontext** всегда выполняются, даже если обработчик предварительного запроса завершился неудачно или никогда не выполнялся. Из-за этого мы должны убедиться, что база данных существует, прежде чем закрывать ее.
{% endhint %}

## Подключение по требованию

Положительная сторона этого подхода (подключение при первом использовании) заключается в том, что он открывает соединение только в том случае, если это действительно необходимо. Если вы хотите использовать этот код вне контекста запроса, вы можете использовать его в оболочке Python, открыв контекст приложения вручную:

```python
with app.app_context():
    # теперь вы можете использовать get_db()
```

## Легкий запрос

Теперь в каждой функции обработки запросов вы можете получить доступ к **get\_db ()**, чтобы получить текущее открытое соединение с базой данных. Для упрощения работы с **SQLite** полезна функция фабрики строк. Он выполняется для каждого результата, возвращаемого из базы данных, чтобы преобразовать результат. Например, чтобы получить словари вместо кортежей, это можно вставить в функцию **get\_db**, которую мы создали выше:

```python
def make_dicts(cursor, row):
    return dict((cursor.description[idx][0], value)
                for idx, value in enumerate(row))

db.row_factory = make_dicts
```

Это заставит модуль **sqlite3** возвращать **dicts** для этого подключения к базе данных, с которыми гораздо удобнее иметь дело. Еще проще, вместо этого мы могли бы поместить это в **get\_db**:

```python
db.row_factory = sqlite3.Row
```

Это будет использовать объекты **Row**, а не **dicts** для возврата результатов запросов. Это **namedtuple**, поэтому мы можем получить к ним доступ либо по индексу, либо по ключу. Например, предположим, что у нас есть `sqlite3.Row` с именем **r** для строк _**id**_, _**FirstName**_, _**LastName**_ и _**MiddleInitial**_:

```python
>>> # Вы можете получить значения на основе имени строки
>>> r['FirstName']
John
>>> # Или вы можете получить их на основе индекса
>>> r[1]
John
# Объекты-строки также можно повторять:
>>> for value in r:
...     print(value)
1
John
Doe
M
```

Кроме того, рекомендуется предоставить функцию запроса, которая объединяет получение курсора, выполнение и выборку результатов:

```python
def query_db(query, args=(), one=False):
    cur = get_db().execute(query, args)
    rv = cur.fetchall()
    cur.close()
    return (rv[0] if rv else None) if one else rv
```

Эта небольшая удобная функция в сочетании с фабрикой строк делает работу с базой данных намного более приятной, чем при использовании простого курсора и объектов соединения.

Вот как это можно использовать:

```python
for user in query_db('select * from users'):
    print user['username'], 'has the id', user['user_id']
```

Или, если вам нужен только один результат:

```python
user = query_db('select * from users where username = ?',
                [the_username], one=True)
if user is None:
    print 'No such user'
else:
    print the_username, 'has the id', user['user_id']
```

Чтобы передать переменные части в оператор SQL, используйте в операторе вопросительный знак и передайте аргументы в виде списка. Никогда не добавляйте их напрямую в оператор SQL с форматированием строки, поскольку это позволяет атаковать приложение с помощью [SQL-инъекций](https://en.wikipedia.org/wiki/SQL\_injection).

## Схемы инициализации

Реляционным базам данных нужны схемы, поэтому приложения часто отправляют файл `schema.sql`, который создает базу данных. Хорошая идея - предоставить функцию, которая создает базу данных на основе этой схемы. Эта функция может сделать это за вас:

```python
def init_db():
    with app.app_context():
        db = get_db()
        with app.open_resource('schema.sql', mode='r') as f:
            db.cursor().executescript(f.read())
        db.commit()
```

Затем вы можете создать такую базу данных из оболочки Python:

```python
>>> from yourapplication import init_db
>>> init_db()
```
