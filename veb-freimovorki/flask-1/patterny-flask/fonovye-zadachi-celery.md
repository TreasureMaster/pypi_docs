# Фоновые задачи Celery

Если у вашего приложения есть длительная задача, такая как обработка некоторых загруженных данных или отправка электронной почты, вам не нужно ждать ее завершения во время запроса. Вместо этого используйте очередь задач для отправки необходимых данных другому процессу, который будет запускать задачу в фоновом режиме, пока запрос возвращается немедленно.

**Celery** - это мощная очередь задач, которую можно использовать как для простых фоновых задач, так и для сложных многоступенчатых программ и расписаний. Это руководство покажет вам, как настроить **Celery** с помощью **Flask**, но предполагается, что вы уже прочитали руководство [Первые шаги с Celery](https://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html) в документации **Celery**.

## Установка

**Celery** - это отдельный пакет Python. Установите его из **PyPI** с помощью **pip**:

```bash
$ pip install celery
```

## Конфигурация

Первое, что вам понадобится, это экземпляр **Celery,** он называется приложением **celery**. Он служит той же цели, что и объект [Flask](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#klass-flask-flask) в **Flask**, только для **Celery**. Поскольку этот экземпляр используется в качестве отправной точки для всего, что вы хотите делать в **Celery**, например, для создания задач и управления рабочими процессами, другие модули должны иметь возможность импортировать его.

Например, вы можете поместить это в модуль **tasks**. Хотя вы можете использовать **Celery** без какой-либо реконфигурации с **Flask**, он становится немного лучше, создавая подклассы задач и добавляя поддержку контекстов приложения **Flask** и связывая его с конфигурацией **Flask**.

Это все, что необходимо для правильной интеграции **Celery** с **Flask**:

```python
from celery import Celery

def make_celery(app):
    celery = Celery(
        app.import_name,
        backend=app.config['CELERY_RESULT_BACKEND'],
        broker=app.config['CELERY_BROKER_URL']
    )
    celery.conf.update(app.config)

    class ContextTask(celery.Task):
        def __call__(self, *args, **kwargs):
            with app.app_context():
                return self.run(*args, **kwargs)

    celery.Task = ContextTask
    return celery
```

Функция создает новый объект **Celery**, настраивает его с помощью брокера из конфигурации приложения, обновляет остальную часть конфигурации **Celery** из конфигурации **Flask**, а затем создает подкласс задачи, который обертывает выполнение задачи в контексте приложения.

## Пример задачи

Напишем задачу, которая складывает два числа и возвращает результат. Мы настраиваем брокер и серверную часть **Celery** для использования **Redis**, создаем приложение **celery**, используя фактор, указанный выше, а затем используем его для определения задачи.

```python
from flask import Flask

flask_app = Flask(__name__)
flask_app.config.update(
    CELERY_BROKER_URL='redis://localhost:6379',
    CELERY_RESULT_BACKEND='redis://localhost:6379'
)
celery = make_celery(flask_app)

@celery.task()
def add_together(a, b):
    return a + b
```

Эту задачу теперь можно вызывать в фоновом режиме:

```python
result = add_together.delay(23, 42)
result.wait()  # 65
```

## Запуск worker

Если вы запрыгнули и уже выполнили приведенный выше код, вы будете разочарованы, узнав, что `.wait ()` никогда не вернется. Это потому, что вам также необходимо запустить **Celery worker** для получения и выполнения задачи.

```bash
$ celery -A your_application.celery worker
```

Строка **your\_application** должна указывать на пакет или модуль вашего приложения, которые создают объект **celery**.

Теперь, когда **worker** запущен, **wait** вернет результат после завершения задачи.
