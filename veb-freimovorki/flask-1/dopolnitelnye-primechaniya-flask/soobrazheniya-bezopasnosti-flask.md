# Соображения безопасности Flask

Веб-приложения обычно сталкиваются со всевозможными проблемами безопасности, и очень сложно все исправить. **Flask** пытается решить некоторые из этих вещей за вас, но есть еще пара, о которой вам нужно позаботиться самостоятельно.

## Межсайтовый скриптинг (XSS)

Межсайтовый скриптинг - это концепция внедрения произвольного HTML (а вместе с ним и **JavaScript**) в контекст веб-сайта. Чтобы исправить это, разработчики должны правильно экранировать текст, чтобы он не мог включать произвольные теги HTML. Для получения дополнительной информации см. статью в Википедии о [межсайтовых сценариях](https://en.wikipedia.org/wiki/Cross-site\_scripting).

**Flask** настраивает **Jinja2** на автоматическое экранирование всех значений, если явно не указано иное. Это должно исключить все проблемы **XSS**, возникающие в шаблонах, но есть и другие места, где вы должны быть осторожны:

* создание HTML без помощи **Jinja2**
* вызов [Markup](../api-dokumentaciya-flask/poleznye-funkcii-i-klassy-flask.md#klass-flask-markup) c данными, отправленных пользователями
* отправка HTML из загруженных файлов, никогда не делайте этого, используйте заголовок `Content-Disposition: attachment`, чтобы предотвратить эту проблему.
* отправка текстовых файлов из загруженных файлов. Некоторые браузеры используют угадывание типа контента на основе первых нескольких байтов, чтобы пользователи могли обмануть браузер для выполнения HTML.

Еще одна важная вещь - это атрибуты без кавычек. Хотя **Jinja2** может защитить вас от проблем **XSS**, избегая HTML, есть одна вещь, от которой он не может вас защитить: **XSS** путем внедрения атрибутов. Чтобы противостоять этому возможному вектору атаки, обязательно всегда заключайте свои атрибуты в двойные или одинарные кавычки при использовании в них выражений **Jinja**:

```markup
<input value="{{ value }}">
```

Зачем это нужно? Потому что, если вы этого не сделаете, злоумышленник может легко внедрить собственные обработчики **JavaScript**. Например, злоумышленник может внедрить этот фрагмент HTML + JavaScript:

```javascript
onmouseover=alert(document.cookie)
```

Когда пользователь затем наведет указатель мыши на ввод, файл **cookie** будет представлен пользователю в окне предупреждения. Но вместо того, чтобы показывать файл **cookie** пользователю, хороший злоумышленник может также выполнить любой другой код **JavaScript**. В сочетании с CSS-инъекциями злоумышленник может даже заставить элемент заполнить всю страницу, так что пользователю достаточно будет навести указатель мыши в любом месте страницы, чтобы вызвать атаку.

Есть один класс проблем **XSS**, от которых экранирование **Jinja** не защищает. Атрибут **href** тега **a** может содержать _**javascript**_: URI, который браузер выполнит при нажатии, если он не защищен должным образом.

```markup
<a href="{{ value }}">click here</a>
<a href="javascript:alert('unsafe');">click here</a>
```

Чтобы этого не произошло, вам нужно установить заголовок ответа [Content Security Policy](soobrazheniya-bezopasnosti-flask.md#politika-bezopasnosti-kontenta-csp) (CSP).

## Подделка межсайтовых запросов (CSRF)

Еще одна большая проблема - **CSRF**. Это очень сложная тема, и я не буду ее здесь подробно описывать, просто упомяну, что это такое и как теоретически предотвратить ее.

Если ваша аутентификационная информация хранится в файлах **cookie**, у вас есть неявное управление состоянием. Состояние «входа в систему» контролируется файлом **cookie**, и этот файл **cookie** отправляется с каждым запросом на страницу. К сожалению, это включает запросы, инициированные сторонними сайтами. Если вы не помните об этом, некоторые люди могут обмануть пользователей вашего приложения с помощью социальной инженерии, чтобы они совершали глупости без их ведома.

Допустим, у вас есть конкретный URL-адрес, который при отправке запросов **POST** удаляет профиль пользователя (например, **http://example.com/user/delete**). Если злоумышленник теперь создает страницу, которая отправляет на эту страницу запрос на публикацию с помощью некоторого кода **JavaScript**, ему просто нужно обманом заставить некоторых пользователей загрузить эту страницу, и их профили будут удалены.

Представьте, что вы запускаете Facebook с миллионами одновременных пользователей, и кто-то рассылает ссылки на изображения маленьких котят. Когда пользователи переходили на эту страницу, их профили удалялись, пока они смотрели изображения пушистых кошек.

Как можно этого предотвратить? В основном для каждого запроса, который изменяет контент на сервере, вам нужно будет либо использовать одноразовый токен **и** сохранить его в файле **cookie**, а также передать его с данными формы. После повторного получения данных на сервере вам нужно будет сравнить два токена и убедиться, что они равны.

Почему **Flask** не делает этого за вас? Идеальное место для этого - структура проверки формы, которой нет во **Flask**.

## Безопасность JSON

Во `Flask 0.10` и ниже **jsonify ()** не сериализовал массивы верхнего уровня в **JSON**. Это произошло из-за уязвимости безопасности в **ECMAScript 4**.

**ECMAScript 5** закрыл эту уязвимость, поэтому только очень старые браузеры остаются уязвимыми. Все эти браузеры имеют [другие более серьезные уязвимости](https://github.com/pallets/flask/issues/248#issuecomment-59934857), поэтому это поведение было изменено, и теперь **jsonify ()** поддерживает сериализацию массивов.

## Заголовки безопасности

Браузеры распознают различные заголовки ответов, чтобы контролировать безопасность. Мы рекомендуем просмотреть каждый из заголовков ниже для использования в вашем приложении. Расширение [Flask-Talisman](https://github.com/GoogleCloudPlatform/flask-talisman) может использоваться для управления HTTPS и заголовками безопасности за вас.

### Строгая безопасность транспорта HTTP (HSTS)

Указывает браузеру преобразовать все HTTP-запросы в HTTPS, предотвращая атаки типа «man-in-the-middle» (MITM).

```python
response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
```

* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)

### Политика безопасности контента (CSP)

Сообщите браузеру, откуда он может загружать различные типы ресурсов. Этот заголовок следует использовать всякий раз, когда это возможно, но требует некоторой работы для определения правильной политики для вашего сайта. Очень строгая политика:

```python
response.headers['Content-Security-Policy'] = "default-src 'self'"
```

* [https://csp.withgoogle.com/docs/index.html](https://csp.withgoogle.com/docs/index.html)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)

### X-Content-Type-Options

Заставляет браузер учитывать тип содержимого ответа вместо того, чтобы пытаться его обнаружить, что может быть использовано для создания атаки межсайтового скриптинга (**XSS**).

```python
response.headers['X-Content-Type-Options'] = 'nosniff'
```

* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options)

### X-Frame-Options

Запрещает внешним сайтам встраивать ваш сайт в **iframe**. Это предотвращает класс атак, при которых клики во внешнем фрейме могут незримо преобразовываться в клики по элементам вашей страницы. Это также известно как «кликджекинг».

```python
response.headers['X-Frame-Options'] = 'SAMEORIGIN'
```

* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)

### X-XSS-Protection

Браузер попытается предотвратить отраженные XSS-атаки, не загружая страницу, если запрос содержит что-то похожее на **JavaScript**, а ответ содержит те же данные.

```python
response.headers['X-XSS-Protection'] = '1; mode=block'
```

* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection)

### Параметры Set-Cookie

Эти параметры можно добавить в заголовок **Set-Cookie** для повышения их безопасности. **Flask** имеет параметры конфигурации, чтобы установить их в **cookie** сеанса. Их можно установить и на другие файлы **cookie**.

* **Secure** ограничивает файлы **cookie** только трафиком HTTPS.
* **HttpOnly** защищает содержимое файлов **cookie** от чтения с помощью **JavaScript**.
* **SameSite** ограничивает отправку файлов **cookie** с запросами с внешних сайтов. Может быть установлен на «**Lax**» (рекомендуется) или «**Strict**». **Lax** предотвращает отправку файлов **cookie** с CSRF-запросами с внешних сайтов, такими как отправка формы. **Strict** предотвращает отправку файлов **cookie** со всеми внешними запросами, включая переход по обычным ссылкам.

```python
app.config.update(
    SESSION_COOKIE_SECURE=True,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE='Lax',
)

response.set_cookie('username', 'flask', secure=True, httponly=True, samesite='Lax')
```

Если указать параметры **Expires** или **Max-Age**, **cookie** будет удален по истечении заданного времени или текущего времени плюс возраст, соответственно. Если ни одна из опций не установлена, **cookie** будет удален при закрытии браузера.

```python
# cookie истекает через 10 минут
response.set_cookie('snakes', '3', max_age=600)
```

Для файла **cookie** сеанса, если установлен [session.permanent](../api-dokumentaciya-flask/sessii-flask.md#permanent), то [PERMANENT\_SESSION\_LIFETIME](../rukovodstvo-polzovatelya-flask/obrabotka-konfiguracii-flask.md#permanent\_session\_lifetime) используется для установки срока действия. Реализация файлов **cookie** по умолчанию в **Flask** проверяет, что криптографическая подпись не старше этого значения. Понижение этого значения может помочь уменьшить атаки повторного воспроизведения, когда перехваченные файлы **cookie** могут быть отправлены позже.

```python
app.config.update(
    PERMANENT_SESSION_LIFETIME=600
)

@app.route('/login', methods=['POST'])
def login():
    ...
    session.clear()
    session['user_id'] = user.id
    session.permanent = True
    ...
```

Используйте **itsdangerous.TimedSerializer** для подписи и проверки других значений файлов **cookie** (или любых значений, требующих защищенных подписей).

* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)

### Закрепление открытого ключа HTTP (HPKP)

Это указывает браузеру аутентифицироваться на сервере, используя только определенный ключ сертификата, чтобы предотвратить атаки MITM.

{% hint style="danger" %}
Будьте осторожны при включении этого параметра, так как его очень сложно отменить, если вы неправильно настроили или обновили свой ключ.
{% endhint %}

* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Public\_Key\_Pinning](https://developer.mozilla.org/en-US/docs/Web/HTTP/Public\_Key\_Pinning)

## Копировать / вставить в терминал

Скрытые символы, такие как символ возврата ( `\b`, `^H`), могут привести к тому, что текст будет отображаться в HTML иначе, чем то, как он интерпретируется при [вставке в терминал](https://security.stackexchange.com/questions/39118/how-can-i-protect-myself-from-this-kind-of-clipboard-abuse).

Например, `import y\bose\bm\bi\bt\be\b` отображается как `import yosemite` в HTML, но при вставке в терминал применяются обратные пробелы, и он становится `import os`.

Если вы ожидаете, что пользователи скопируют и вставят ненадежный код с вашего сайта, например из комментариев, размещенных пользователями в техническом блоге, рассмотрите возможность применения дополнительной фильтрации, например замены всех символов `\b`.

```python
body = body.replace("\b", "")
```

Большинство современных терминалов предупреждают и удаляют скрытые символы при вставке, поэтому в этом нет строгой необходимости. Также можно создавать опасные команды другими способами, которые невозможно отфильтровать. В зависимости от варианта использования вашего сайта может быть полезно показать предупреждение о копировании кода в целом.
