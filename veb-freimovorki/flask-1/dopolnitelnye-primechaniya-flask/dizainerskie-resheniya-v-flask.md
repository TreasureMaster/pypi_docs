# Дизайнерские решения в Flask

Если вам интересно, почему **Flask** делает определенные вещи именно так, а не иначе, этот раздел для вас. Это должно дать вам представление о некоторых дизайнерских решениях, которые на первый взгляд могут показаться произвольными и неожиданными, особенно при прямом сравнении с другими фреймворками.

## Явный объект приложения

Веб-приложение Python, основанное на **WSGI**, должно иметь один центральный вызываемый объект, реализующий реальное приложение. В Flask это экземпляр класса [Flask](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#klass-flask-flask-import\_name-static\_url\_path-none-static\_folder-static-static\_host-none-host\_matching-false-subdomain\_matching-false-template\_folder-templates-instance\_path-none-instance\_relative\_config-false-root\_path-none). Каждое приложение **Flask** должно создать экземпляр этого класса и передать ему имя модуля, но почему **Flask** не может сделать это сам?

Без такого явного объекта приложения следующий код:

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello World!'
```

Вместо этого будет выглядеть так:

```python
from hypothetical_flask import route

@route('/')
def index():
    return 'Hello World!'
```

Для этого есть три основных причины. Самая важная из них заключается в том, что неявные объекты приложения требуют одновременного существования только одного экземпляра. Есть способы подделать несколько приложений с помощью одного объекта приложения, например, поддерживать стек приложений, но это вызывает некоторые проблемы, которые я не буду здесь подробно описывать. Теперь вопрос: когда для микрофреймворка требуется более одного приложения одновременно? Хорошим примером этого является модульное тестирование. Если вы хотите что-то протестировать, может быть очень полезно создать минимальное приложение для проверки определенного поведения. Когда объект приложения будет удален, все, что он выделил, будет снова освобождено.

Еще одна вещь, которая становится возможной, когда у вас есть явный объект, лежащий в вашем коде, - это то, что вы можете создать подкласс базового класса ([Flask](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#klass-flask-flask-import\_name-static\_url\_path-none-static\_folder-static-static\_host-none-host\_matching-false-subdomain\_matching-false-template\_folder-templates-instance\_path-none-instance\_relative\_config-false-root\_path-none)), чтобы изменить конкретное поведение. Это было бы невозможно без хаков, если бы объект был создан заранее для вас на основе класса, который вам не предоставляется.

Но есть еще одна очень важная причина, по которой **Flask** зависит от явного создания экземпляра этого класса: имя пакета. Каждый раз, когда вы создаете экземпляр **Flask**, вы обычно передаете его `__name__` в качестве имени пакета. **Flask** зависит от этой информации для правильной загрузки ресурсов относительно вашего модуля. Благодаря выдающейся поддержке отражения в Python он может получить доступ к пакету, чтобы выяснить, где хранятся шаблоны и статические файлы (см. [open\_resource ()](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#open\_resource-resource-mode-rb)). Теперь очевидно, что вокруг есть фреймворки, которые не нуждаются в какой-либо настройке и по-прежнему смогут загружать шаблоны, относящиеся к вашему модулю приложения. Но для этого они должны использовать текущий рабочий каталог, а это очень ненадежный способ определить, где находится приложение. Текущий рабочий каталог распространяется на весь процесс, и если вы запускаете несколько приложений в одном процессе (что может произойти на веб-сервере без вашего ведома), пути будут отключены. Хуже того: многие веб-серверы устанавливают рабочий каталог не в каталог вашего приложения, а в корень документа, который не обязательно должен быть той же папкой.

Третья причина - «явное лучше, чем неявное». Этот объект - ваше приложение **WSGI**, вам не нужно больше ничего запоминать. Если вы хотите применить промежуточное ПО **WSGI**, просто оберните его, и все готово (хотя есть более эффективные способы сделать это, чтобы не потерять ссылку на объект приложения [wsgi\_app ()](../api-dokumentaciya-flask/obekt-prilozheniya-flask.md#wsgi\_app-environ-start\_response)).

Кроме того, этот дизайн позволяет использовать фабричную функцию для создания приложения, которое очень полезно для модульного тестирования и подобных вещей ([фабрики приложения](../patterny-flask/fabriki-prilozheniya-flask.md)).

## Система маршрутизации

**Flask** использует систему маршрутизации **Werkzeug**, которая была разработана для автоматического упорядочивания маршрутов по сложности. Это означает, что вы можете объявлять маршруты в произвольном порядке, и они по-прежнему будут работать должным образом. Это требование, если вы хотите правильно реализовать маршрутизацию на основе декораторов, поскольку декораторы могут запускаться в неопределенном порядке, когда приложение разделено на несколько модулей.

Еще одно дизайнерское решение системы маршрутизации **Werkzeug** заключается в том, что маршруты в **Werkzeug** стараются обеспечить уникальность URL-адресов. **Werkzeug** зайдет довольно далеко, поскольку он автоматически перенаправит на канонический URL-адрес, если маршрут неоднозначен.

## Один движок шаблонов

**Flask** выбирает один шаблонизатор: **Jinja2**. Почему у **Flask** нет подключаемого интерфейса шаблонизатора? Очевидно, вы можете использовать другой механизм шаблонов, но **Flask** все равно настроит **Jinja2** за вас. Хотя то ограничение, что **Jinja2** всегда настраивается, вероятно, исчезнет, решение связать один механизм шаблонов и использовать его не будет.

Механизмы шаблонов похожи на языки программирования, и каждый из этих механизмов имеет определенное представление о том, как все работает. На первый взгляд, все они работают одинаково: вы говорите движку оценить шаблон с набором переменных и принять возвращаемое значение как строку.

Но на этом сходство заканчивается. **Jinja2**, например, имеет обширную систему фильтров, определенный способ наследования шаблонов, поддержку многоразовых блоков (макросов), которые можно использовать из внутренних шаблонов, а также из кода Python, использует Unicode для всех операций, поддерживает итеративный рендеринг шаблонов, настраиваемый синтаксис и больше. С другой стороны, такой движок, как **Genshi**, основан на оценке потока **XML**, наследовании шаблонов с учетом доступности **XPath** и многом другом. **Mako**, с другой стороны, обрабатывает шаблоны аналогично модулям Python.

Когда дело доходит до подключения механизма шаблонов к приложению или фреймворку, существует нечто большее, чем просто шаблоны отрисовки. Например, **Flask** использует обширную поддержку автоматического экранирования в **Jinja2**. Также он предоставляет способы доступа к макросам из шаблонов **Jinja2**.

Слой абстракции шаблонов, который не лишил бы уникальных возможностей механизмов шаблонов, - это сама по себе наука и слишком сложная задача для микрофреймворка, такого как **Flask**.

Более того, расширения могут легко зависеть от наличия одного языка шаблонов. Вы можете легко использовать свой собственный язык шаблонов, но расширение все равно может зависеть от самого **Jinja**.

## Микро с зависимостями

Почему **Flask** называет себя микрофреймворком, и все же это зависит от двух библиотек (а именно **Werkzeug** и **Jinja2**). Почему бы и нет? Если мы посмотрим на **Ruby**-сторону веб-разработки, у нас будет протокол, очень похожий на **WSGI**. Просто там он называется **Rack**, но кроме этого он очень похож на исполнение **WSGI** для **Ruby**. Но почти все приложения в мире **Ruby** работают не напрямую с **Rack**, а поверх одноименной библиотеки. Эта библиотека **Rack** имеет два эквивалента в Python: **WebOb** (ранее **Paste**) и **Werkzeug**. **Paste** все еще существует, но, насколько я понимаю, она устарела в пользу **WebOb**. Разработка **WebOb** и **Werkzeug** началась параллельно с аналогичными идеями: быть хорошей реализацией **WSGI**, чтобы другие приложения могли воспользоваться преимуществами.

**Flask** - это фреймворк, который использует уже проделанную **Werkzeug** работу для правильного взаимодействия с **WSGI** (что иногда может быть сложной задачей). Благодаря недавним разработкам в инфраструктуре пакетов Python пакеты с зависимостями больше не являются проблемой, и есть очень мало причин против наличия библиотек, которые зависят от других.

## Локальные потоки

**Flask** использует локальные объекты потока (фактически, локальные объекты контекста, они также поддерживают контексты гринлетов) для запроса, сеанса и дополнительного объекта, на который вы можете поместить свои собственные вещи ([g](../api-dokumentaciya-flask/globalnyi-obekt-prilozheniya-flask.md#flask-g)). Почему это так и разве это не плохая идея?

Да, обычно использовать локальных потоков - не самая лучшая идея. Они вызывают проблемы для серверов, которые не основаны на концепции потоков, и затрудняют обслуживание больших приложений. Однако **Flask** просто не предназначен для больших приложений или асинхронных серверов. **Flask** хочет упростить и упрощает написание традиционного веб-приложения.

Также см. раздел документации «[Становление большим](../rukovodstvo-polzovatelya-flask/eshe-bolshe-o-flask.md)», где можно найти вдохновение для создания более крупных приложений на основе **Flask**.

## Что есть Flask, а что нет?

У **Flask** никогда не будет уровня базы данных. У него не будет библиотеки форм или чего-либо еще в этом направлении. Сам **Flask** просто соединяется с **Werkzeug** для реализации надлежащего приложения **WSGI** и с **Jinja2** для обработки шаблонов. Он также связывается с несколькими общими стандартными пакетами библиотек, такими как ведение журнала. Все остальное подлежит расширению.

Почему это так? Потому что у людей разные предпочтения и требования, и **Flask** не смог бы их удовлетворить, если бы что-то из этого было перенесено в ядро. Большинству веб-приложений потребуется какой-то механизм шаблонов. Однако не каждому приложению нужна база данных **SQL**.

Идея **Flask** - создать хорошую основу для всех приложений. Все остальное зависит от вас или расширений.
