# Разработка расширений Flask

**Flask**, будучи микрофреймворком, часто требует некоторых повторяющихся шагов, чтобы заставить работать стороннюю библиотеку. Многие такие расширения уже доступны в [PyPI](https://pypi.org/search/?c=Framework+%3A%3A+Flask).

Если вы хотите создать собственное расширение **Flask** для чего-то, чего еще не существует, это руководство по разработке расширений поможет вам запустить расширение в кратчайшие сроки и почувствовать, что пользователи ожидают, что ваше расширение будет вести себя.

## Анатомия расширений

Все расширения находятся в пакете с именем **flask\_something**, где «**something**» - это имя библиотеки, которую вы хотите связать. Так, например, если вы планируете добавить во **Flask** поддержку библиотеки с именем **simplexml**, вы должны назвать пакет своего расширения **flask\_simplexml**.

Имя фактического расширения (удобочитаемое имя), однако, будет чем-то вроде «**Flask-SimpleXML**». Убедитесь, что где-то в этом имени указано «**Flask**» и что вы проверяете использование заглавных букв. Таким образом пользователи могут регистрировать зависимости от вашего расширения в своих файлах `setup.py`.

Но как выглядят расширения? Расширение должно гарантировать одновременную работу с несколькими экземплярами приложения **Flask**. Это требование, потому что многие люди будут использовать шаблоны, такие как шаблон [Application Factories](../patterny-flask/fabriki-prilozheniya-flask.md), для создания своих приложений, необходимых для поддержки модульных тестов и поддержки нескольких конфигураций. По этой причине очень важно, чтобы ваше приложение поддерживало такое поведение.

Самое главное, что расширение должно быть отправлено с файлом `setup.py` и зарегистрировано в **PyPI**. Кроме того, ссылка для проверки разработки должна работать, чтобы люди могли легко установить версию для разработки в свой виртуальный сервер, не загружая библиотеку вручную.

Расширения **Flask** должны иметь лицензию **BSD**, **MIT** или более либеральную лицензию, чтобы их можно было перечислить в реестре расширений **Flask**. Имейте в виду, что реестр расширений **Flask** находится под контролем, и библиотеки будут проверяться заранее, если они будут вести себя должным образом.

## "Hello Flaskext!"

Итак, приступим к созданию такого расширения **Flask**. Расширение, которое мы хотим здесь создать, будет обеспечивать базовую поддержку **SQLite3**.

Сначала мы создаем следующую структуру папок:

```bash
flask-sqlite3/
    flask_sqlite3.py
    LICENSE
    README
```

Вот содержимое наиболее важных файлов:

### setup.py

Следующим абсолютно необходимым файлом является файл `setup.py`, который используется для установки расширения **Flask**. Вы можете работать со следующим содержимым:

```python
"""
Flask-SQLite3
-------------

Это описание этой библиотеки
"""
from setuptools import setup


setup(
    name='Flask-SQLite3',
    version='1.0',
    url='http://example.com/flask-sqlite3/',
    license='BSD',
    author='Your Name',
    author_email='your-email@example.com',
    description='Very short description',
    long_description=__doc__,
    py_modules=['flask_sqlite3'],
    # если вы будете использовать пакет,
    # используйте packages вместо py_modules:
    # packages=['flask_sqlite3'],
    zip_safe=False,
    include_package_data=True,
    platforms='any',
    install_requires=[
        'Flask'
    ],
    classifiers=[
        'Environment :: Web Environment',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: BSD License',
        'Operating System :: OS Independent',
        'Programming Language :: Python',
        'Topic :: Internet :: WWW/HTTP :: Dynamic Content',
        'Topic :: Software Development :: Libraries :: Python Modules'
    ]
)
```

Это много кода, но вы действительно можете просто скопировать / вставить его из существующих расширений и адаптироваться.

### flask\_sqlite3.py

Теперь это то место, куда идет ваш код расширения. Но как именно должно выглядеть такое расширение? Какие лучшие практики? Продолжайте читать для некоторого понимания.

## Инициализация расширений

Для многих расширений потребуется какой-то этап инициализации. Например, рассмотрим приложение, которое в настоящее время подключается к **SQLite**, как предлагает документация ([Использование SQLite 3 с Flask](../patterny-flask/ispolzovanie-sqlite3-s-flask.md)). Итак, как расширение узнает имя объекта приложения?

Все очень просто: вы передаете это ему.

Есть два рекомендуемых способа инициализации расширения:

* **функции инициализации:** Если ваше расширение называется _**helloworld**_, у вас может быть функция с именем `init_helloworld (app [, extra_args])`, которая инициализирует расширение для приложения. Она может присоединяться до / после обработчиков и т. д.
* **классы:** Классы работают в основном как функции инициализации, но позже их можно использовать для дальнейшего изменения поведения. В качестве примера посмотрите, как работает расширение **OAuth**: существует объект OAuth, который предоставляет некоторые вспомогательные функции, такие как `OAuth.remote_app`, для создания ссылки на удаленное приложение, использующее OAuth.

Что использовать, зависит от того, что вы имеете в виду. Для расширения **SQLite 3** мы будем использовать подход на основе классов, потому что он предоставит пользователям объект, который обрабатывает открытие и закрытие соединений с базой данных.

При разработке классов важно, чтобы их можно было легко использовать повторно на уровне модуля. Это означает, что сам объект ни при каких обстоятельствах не должен хранить какое-либо конкретное состояние приложения и должен использоваться совместно различными приложениями.

## Код расширения

Вот содержимое `flask_sqlite3.py` для копирования / вставки:

```python
import sqlite3
from flask import current_app, _app_ctx_stack


class SQLite3(object):
    def __init__(self, app=None):
        self.app = app
        if app is not None:
            self.init_app(app)

    def init_app(self, app):
        app.config.setdefault('SQLITE3_DATABASE', ':memory:')
        app.teardown_appcontext(self.teardown)

    def connect(self):
        return sqlite3.connect(current_app.config['SQLITE3_DATABASE'])

    def teardown(self, exception):
        ctx = _app_ctx_stack.top
        if hasattr(ctx, 'sqlite3_db'):
            ctx.sqlite3_db.close()

    @property
    def connection(self):
        ctx = _app_ctx_stack.top
        if ctx is not None:
            if not hasattr(ctx, 'sqlite3_db'):
                ctx.sqlite3_db = self.connect()
            return ctx.sqlite3_db
```

Итак, вот что делают эти строки кода:

1. Метод `__init__` принимает необязательный объект приложения и, если он указан, вызывает **init\_app**.
2. Метод **init\_app** существует для того, чтобы можно было создать экземпляр объекта **SQLite3**, не требуя объекта приложения. Этот метод поддерживает фабричный шаблон для создания приложений. **init\_app** установит конфигурацию для базы данных, по умолчанию это база данных в памяти, если конфигурация не предоставлена. Кроме того, метод **init\_app** присоединяет обработчик **teardown**.
3. Затем мы определяем метод **connect**, который открывает соединение с базой данных.
4. Наконец, мы добавляем свойство **connection**, которое при первом доступе открывает соединение с базой данных и сохраняет его в контексте. Это также рекомендуемый способ обработки ресурсов: ленивое извлечение ресурсов при первом их использовании. Обратите внимание, что мы подключаем наше соединение с базой данных к верхнему контексту приложения через `_app_ctx_stack.top`. Расширения должны использовать верхний контекст для хранения собственной информации с достаточно сложным именем.

Так почему же мы выбрали подход, основанный на классах? Потому что использование нашего расширения выглядит примерно так:

```python
from flask import Flask
from flask_sqlite3 import SQLite3

app = Flask(__name__)
app.config.from_pyfile('the-config.cfg')
db = SQLite3(app)
```

Затем вы можете использовать базу данных из таких представлений:

```python
@app.route('/')
def show_all():
    cur = db.connection.cursor()
    cur.execute(...)
```

Точно так же, если вы находитесь за пределами запроса, вы можете использовать базу данных, нажав контекст приложения:

```python
with app.app_context():
    cur = db.connection.cursor()
    cur.execute(...)
```

В конце блока **with** автоматически выполнятся дескрипторы **teardown**.

Кроме того, метод **init\_app** используется для поддержки фабричного шаблона для создания приложений:

```python
db = SQLite3()
# Затем позже.
app = create_app('the-config.cfg')
db.init_app(app)
```

Имейте в виду, что поддержка этого фабричного шаблона для создания приложений требуется для утвержденных расширений **Flask** (описанных ниже).

{% hint style="info" %}
**Примечание по init\_app:**

Как вы заметили, **init\_app** не назначает **app** для **self**. Это сделано намеренно! Расширения **Flask** на основе классов должны сохранять приложение в объекте только тогда, когда приложение было передано конструктору. Это говорит расширению: я не заинтересован в использовании нескольких приложений.

Когда расширению необходимо найти текущее приложение и у него нет ссылки на него, оно должно либо использовать локальный контекст [current\_app](../api-dokumentaciya-flask/poleznye-funkcii-i-klassy-flask.md#flask-current\_app), либо изменить API таким образом, чтобы вы могли явно передать приложение.
{% endhint %}

## Использование app\_ctx\_stack

В приведенном выше примере перед каждым запросом переменная `sqlite3_db` присваивается `_app_ctx_stack.top`. В функции просмотра эта переменная доступна с помощью свойства **connection** SQLite3. Во время **teardown** запроса соединение `sqlite3_db` закрывается. При использовании этого шаблона одно и то же соединение с базой данных sqlite3 доступно для всего, кому оно нужно, на время выполнения запроса.

## Учитесь у других

Эта документация касается только самого минимума для разработки расширений. Если вы хотите узнать больше, неплохо было бы проверить существующие расширения [PyPI](https://pypi.org/search/?c=Framework+%3A%3A+Flask). Если вы чувствуете себя потерянным, есть [список рассылки](https://mail.python.org/mailman/listinfo/flask) и [сервер Discord](https://discord.com/invite/t6rrQZH), чтобы почерпнуть идеи для красивых API. Особенно, если вы делаете что-то, что до вас никто не делал, может быть очень хорошей идеей получить больше отзывов. Это не только создает полезную обратную связь о том, что люди могут хотеть от расширения, но также позволяет избежать того, чтобы несколько разработчиков работали изолированно над почти одной и той же проблемой.

Помните: хороший дизайн API - это непросто, поэтому внесите свой проект в список рассылки и позвольте другим разработчикам протянуть вам руку помощи в разработке API.

Лучшие расширения **Flask** - это расширения, которые имеют общие идиомы для API. И это может сработать только в том случае, если сотрудничество начнется на ранней стадии.

## Утвержденные расширения

Ранее **Flask** имел концепцию одобренных расширений. Они пришли с некоторой проверкой поддержки и совместимости. Хотя со временем поддерживать этот список стало слишком сложно, рекомендации по-прежнему актуальны для всех расширений, поддерживаемых и разрабатываемых сегодня, поскольку они помогают экосистеме **Flask** оставаться согласованной и совместимой.

* Для утвержденного расширения **Flask** требуется сопровождающий. В случае, если автор расширения захочет выйти за рамки проекта, проект должен найти нового сопровождающего и передать доступ к репозиторию, документации, **PyPI** и любым другим сервисам. Если сопровождающий недоступен, предоставьте доступ основной команде **Pallets**.
* Схема именования - **Flask-ExtensionName** или **ExtensionName-Flask**. Он должен предоставлять ровно один пакет или модуль с именем `flask_extension_name`.
* Расширение должно быть лицензировано **BSD** или **MIT**. Он должен быть открытым и общедоступным.
* API расширения должен иметь следующие характеристики:
  * Оно должно поддерживать несколько приложений, работающих в одном процессе Python. Используйте **current\_app** вместо **self.app**, сохраняйте конфигурацию и состояние для каждого экземпляра приложения.
  * Должна быть возможность использовать фабричный шаблон для создания приложений. Используйте шаблон `ext.init_app ()`.
* Из клона репозитория расширение со своими зависимостями должно быть установлено с помощью команды `pip install -e .`.
* Он должен поставлять набор для тестирования, который можно запускать с помощью `tox -e py` или `pytest`. Если не используется **tox**, тестовые зависимости должны быть указаны в файле `requirements.txt`. Тесты должны быть частью дистрибутива **sdist**.
* В документации должна использоваться тема **flask** из [официальных тем для паллет](https://pypi.org/project/Pallets-Sphinx-Themes/). Ссылка на документацию или веб-сайт проекта должна быть в метаданных **PyPI** или в файле **readme**.
* Для максимальной совместимости расширение должно поддерживать те же версии Python, что и **Flask**. Начиная с 2020 года рекомендуется `3.6+`. Используйте `python_requires = "> = 3.6"` в `setup.py`, чтобы указать поддерживаемые версии.
