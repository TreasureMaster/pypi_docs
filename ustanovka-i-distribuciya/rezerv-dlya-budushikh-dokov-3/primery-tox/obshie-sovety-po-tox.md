# Общие советы по tox

## Интерактивная передача позиционных аргументов

Если вы вызываете **tox** так:

```bash
tox -- -x tests/test_something.py
```

аргументы после `--` будут заменены везде, где вы указываете `{posargs}` в своих тестовых командах, например, используя **pytest**:

```bash
[testenv]
# Также может быть в конкретной ``[testenv:<NAME>]`` секции
commands = pytest {posargs}
```

или используя **nosetests**:

```bash
[testenv]
commands = nosetests {posargs}
```

Вышеупомянутый вызов **tox** заставит исполнителей теста остановиться после первого сбоя и запустить только определенный тестовый файл.

Вы можете указать значения по умолчанию для позиционных аргументов, используя этот синтаксис:

```bash
[testenv]
commands = nosetests {posargs:--with-coverage}
```

## Изменения и отслеживание зависимостей

Создание виртуальных сред и установка зависимостей - дорогостоящая операция. Поэтому **tox** старается избегать этого, когда это возможно, то есть он никогда не выполнит этого, если не обнаружит с абсолютной уверенностью, что ему необходимо выполнить обновление. Создание среды **tox** состоит из:

* создание виртуальной среды
* установка зависимостей, указанных внутри **deps**
* если это библиотечный проект (есть этап сборки пакета), установите зависимости библиотеки (с возможными дополнениями)

Эти три шага выполняются только один раз (если все они выполнены успешно). Последующие вызовы, которые не обнаруживают изменений характеристик этого шага, никоим образом не изменят виртуальную среду. Когда изменение обнаруживается для любого из шагов, вся виртуальная среда удаляется, и операция начинается с нуля (это связано с тем, что очень сложно определить, какие изменения дельты потребуются - например, зависимость может перейти от одной зависимости к другой, и в этом случае нам нужно будет установить новый, удалив старый).

Вот какие черты характера мы отслеживаем в настоящий момент для каждого шага:

* признак виртуальной среды привязан к пути Python, который также разрешает **basepython** (если эта конфигурация изменится, виртуальная среда будет воссоздана),
* изменения разделов **deps** (имеется в виду любое изменение на уровне строки для записей, изменения содержимого файла требований примечания не отслеживаются),
* зависимости библиотек отслеживаются на уровне **extras** (поскольку нет Python API, чтобы узнать о фактических зависимостях не привязанным к конкретному инструменту способом, например, у **setuptools** есть один способ, вариант **flit** - другой, а для **poetry** - еще один другой).

Каждый раз, когда вы меняете черты, которые не отслеживаются, мы рекомендуем вам вручную запускать перестройку среды **tox**, передав флаг `-r` для вызова **tox**. Например, для проекта **setuptools** всякий раз, когда вы изменяете ключевое слово **install\_requires** при следующем запуске, принудительно воссоздаете среду **tox**, передавая флаг воссоздания **cli tox**.

## Выбор одной или нескольких сред для запуска тестов

Используя параметр `-e ENV [, ENV36, ...]`, вы явно перечисляете среды, в которых вы хотите запускать тесты. Например, учитывая предыдущий пример **sphinx**, вы можете вызвать:

```bash
tox -e docs
```

что заставит **tox** управлять только средой **docs** и вызывать ее тестовые команды. Вы можете указать более одной среды следующим образом:

```bash
tox -e py27,py36
```

который будет запускать команды тестовых сред **py27** и **py36** соответственно. Специальное значение **ALL** выбирает все среды.

Вы также можете указать список окружений в файле `tox.ini`:

```bash
[tox]
envlist = py27,py36
```

или переопределить его из командной строки или из переменной окружения **TOXENV**:

```bash
export TOXENV=py27,py36 # в оболочках стиля bash
```

## Доступ к артефактам пакета между несколькими запусками tox

Если у вас есть несколько проектов, использующих **tox**, вы можете использовать каталог **distshare**, куда **tox** будет копировать в пакеты **sdist**, чтобы другой прогон **tox** мог найти самую «последнюю» зависимость. Эта функция позволяет вам протестировать пакет на невыпущенной разрабатываемой версии или даже на незафиксированной версии на вашем собственном компьютере.

По умолчанию `{homedir}/.tox/distshare` будет использоваться для копирования в и из копирования артефактов (то есть пакетов Python).

Чтобы проект **two** зависел от пакета **one**, вы используете следующую запись:

```bash
# пример two/tox.ini
[testenv]
# установить самый последний пакет из проекта "one"
deps = {distshare}/one-*.zip
```

Это все. **tox**, запущенный в проекте **one**, скопирует **sdist-package** в каталог **distshare**, после чего **tox**, запущенный в проекте **two**, захватит его, потому что **deps** содержит запись с одним шаблоном `- *.zip`. Если имеется несколько подходящих пакетов, будет выбрана самая высокая версия. **tox** использует [verlib](https://pypi.org/project/verlib/) для сравнения строк версий, которые должны соответствовать [PEP 386](https://www.python.org/dev/peps/pep-0386/).

{% hint style="warning" %}
Возможно, что это не тот **verlib**, т.к. ссылка недействительна в документации **tox**.
{% endhint %}

Если вы хотите использовать это с [Jenkins](https://www.jenkins.io/index.html), также проверьте [Доступ к артефактам пакетов между заданиями Jenkins](ispolzovanie-tox-s-jenkins.md#dostup-k-artefaktam-paketov-mezhdu-zadaniyami-jenkins).

## basepython по умолчанию, переопределение

Для любого имени тестовой среды **pyXY** базовый исполняемый файл `pythonX.Y` будет найден в вашей системе **PATH**. Точно так же для **jython** и **pypy** будут искать соответствующие имена **jython** и **pypy-c**. Исполняемый файл должен существовать, чтобы успешно создавать среды **virtualenv**. В Windows выполняется поиск исполняемого файла с именем `pythonX.Y` в типичных местоположениях по умолчанию с использованием шаблона `C:\PythonXY\python.exe`.

Все остальные цели вместо этого будут использовать системный **python**. Вы можете переопределить любые настройки по умолчанию, определив переменную **basepython** в конкретном разделе тестовой среды, например:

```bash
[testenv:docs]
basepython = python2.7
```

## Избегайте дорогостоящих sdist

Некоторые проекты настолько велики, что запуск **sdist** с последующей установкой каждый раз может быть непомерно дорогостоящим. Чтобы решить эту проблему, есть два разных варианта, которые вы можете добавить в раздел **tox**. Во-первых, вы можете просто попросить **tox** не делать **sdist**:

```bash
[tox]
skipsdist=True
```

Если вы это сделаете, ваш локальный программный пакет не будет установлен в файл **virtualenv**. Вы, вероятно, должны с этим согласиться или предпринять шаги, чтобы справиться с этим в разделе ваших команд:

```bash
[testenv]
commands = python setup.py develop
           pytest
```

Запуск `setup.py develop` - достаточно распространенная модель, у нее есть свой вариант:

```bash
[testenv]
usedevelop=True
```

И соответствующий параметр командной строки `--develop`, который установит для **skipsdist** значение `True`, а затем выполнит этап разработки `setup.py` в том месте, где **tox** обычно выполняет установку **sdist**. В частности, он действительно запускает `pip install -e .` за кулисами, который сам вызывает `setup.py develop`.

В коде есть оптимизация, чтобы не беспокоить повторный запуск команды, если `$projectname.egg-info` новее, чем `setup.py` или `setup.cfg`.

## Общие сведения о кодах выхода InvocationError

Когда команда (определенная `commands=` в `tox.ini`) терпит неудачу, она имеет ненулевой код выхода, и **tox** вызывает исключение **InvocationError**:

```bash
ERROR: InvocationError for command
       '<command defined in tox.ini>' (exited with code 1)
```

Если команда начинается, например, с `pytest` или `python setup.py test`, то актуальны [коды выхода pytest](https://docs.pytest.org/en/latest/usage.html#possible-exit-codes).

В системах unix есть несколько довольно распространенных [кодов выхода](http://www.faqs.org/docs/abs/HTML/exitcodes.html). Вот почему для кодов выхода больше 128, если в модуле **signal** обнаружен сигнал с номером, равным `<exit code> - 128`, дается дополнительная подсказка:

```bash
ERROR: InvocationError for command
       '<command>' (exited with code 139)
Note: this might indicate a fatal error signal (139 - 128 = 11: SIGSEGV)
```

где `<command>` - это команда, определенная в `tox.ini`, без кавычек.

Номера сигналов (например, 11 для ошибки сегментации) можно найти в разделе «Стандартные сигналы» на странице [руководства по сигналам](https://man7.org/linux/man-pages/man7/signal.7.html). Их значение описано в [сигналах POSIX](https://en.wikipedia.org/wiki/Signal\_\(IPC\)#POSIX\_signals).

Помните, что программы могут выдавать пользовательские коды выхода с любым значением, поэтому следует обращаться к их документации.

Иногда код выхода не указывается. Пример можно найти в [выпуске pytest-qt # 170](https://github.com/pytest-dev/pytest-qt/issues/170), где Qt вызывал `abort ()` вместо `exit ()`.

{% hint style="info" %}
**См. также:**

[Игнорирование кода выхода команды](bazovoe-ispolzovanie-tox.md#ignorirovanie-koda-vykhoda-komandy).
{% endhint %}
