# Использование tox с Jenkins

## Использование заданий с несколькими конфигурациями Jenkins

Сервер непрерывной интеграции [Jenkins](https://www.jenkins.io/index.html) позволяет вам определять «задания» с помощью «шагов сборки», которые могут быть тестовыми вызовами. Если вы [устанавливаете](../ustanovka-tox.md) **tox** в свою установку Python по умолчанию на каждом агенте **Jenkins**, вы можете легко создать задание с несколькими конфигурациями **Jenkins**, которое будет управлять вашими запусками **tox** со стороны CI-сервера, используя следующие шаги:

* установите плагин Python для Jenkins согласно «manage jenkins»
* создайте задание с несколькими конфигурациями, дайте ему имя по вашему выбору
* настроить репозиторий так, чтобы Jenkins мог его вытащить
* (необязательно) настроить несколько узлов так, чтобы запуски **tox** выполнялись на нескольких хостах
* Настройте **axes**, используя **TOXENV** в качестве имени оси, а в качестве значений укажите имена тестовой среды, разделенные пробелами, которые вы хотите, чтобы `Jenkins/tox` выполнял.
* добавьте **Python-build step** с этим содержимым (см. также следующий пример):

```python
import tox

os.chdir(os.getenv("WORKSPACE"))
tox.cmdline()  # среда выбирается ``TOXENV`` env переменной
```

* установите флажок `Publish JUnit test result report` и введите `**/junit-*.xml` в качестве шаблона, чтобы **Jenkins** собирал результаты теста в формате **JUnit XML**.

Последний пункт требует, чтобы ваша тестовая команда создавала файлы **JunitXML**, например с **pytest** это делается следующим образом:

```python
[testenv]
commands = pytest --junitxml=junit-{envname}.xml
```

## Нулевая установка для агентов

{% hint style="info" %}
В настоящее время эта функция не работает, так как «**toxbootstrap.py**» был удален. Пожалуйста, сообщите о проблеме, если хотите, чтобы она вернулась.
{% endhint %}

Если вы управляете многими агентами **Jenkins** и хотите использовать последнюю официально выпущенную версию **tox** (или последнюю версию для разработки) и хотите пропустить ручную установку **tox**, замените приведенный выше код **Python build step** следующим образом:

```python
import urllib, os

url = "https://bitbucket.org/hpk42/tox/raw/default/toxbootstrap.py"
# os.environ['USETOXDEV']="1"  # use tox dev version
d = dict(__file__="toxbootstrap.py")
exec urllib.urlopen(url).read() in d
d["cmdline"](["--recreate"])
```

Загруженный файл `toxbootstrap.py` загружает все необходимые файлы для установки **tox** в виртуальной вспомогательной среде. Заметки:

* раскомментируйте строку, содержащую **USETOXDEV**, чтобы использовать последнюю разрабатываемую версию **tox** вместо последней выпущенной версии.
* адаптируйте параметры в последней строке по мере необходимости (пример кода заставит **tox** постоянно переустанавливать все виртуальные среды, что часто бывает в контексте сервера CI)

## Интеграция проверок документации «sphinx» в работу Jenkins

Если вы используете задание **Jenkins** с несколькими конфигурациями, которое собирает результаты теста **JUnit**, вы столкнетесь с проблемами, используя предыдущий метод запуска команды **sphinx-build**, потому что он не будет генерировать результаты **JUnit**. Чтобы решить эту проблему, одно из решений - заставить **pytest** обернуть **sphinx-check** и создать файл результатов **JUnit**, который обертывает результат вызова **sphinx-build**. Вот пример:

* создайте среду **docs** в вашем файле `tox.ini` следующим образом:

```bash
[testenv:docs]
basepython = python
# перейдите в каталог ``doc``, если там находятся ваши sphinx-docs
changedir = doc
deps = sphinx
       pytest
commands = pytest --tb=line -v --junitxml=junit-{envname}.xml check_sphinx.py
```

* создайте файл `doc/check_sphinx.py` следующим образом:

```python
import subprocess


def test_linkcheck(tmpdir):
    doctrees = tmpdir.join("doctrees")
    htmldir = tmpdir.join("html")
    subprocess.check_call(
        ["sphinx-build", "-W", "-blinkcheck", "-d", str(doctrees), ".", str(htmldir)]
    )


def test_build_docs(tmpdir):
    doctrees = tmpdir.join("doctrees")
    htmldir = tmpdir.join("html")
    subprocess.check_call(
        ["sphinx-build", "-W", "-bhtml", "-d", str(doctrees), ".", str(htmldir)]
    )
```

* запустите `tox -e docs`, а затем вы можете интегрировать эту среду вместе с другими средами в **Jenkins**.

Обратите внимание, что **pytest** устанавливается только в среду документации и не должен использоваться или устанавливаться с какой-либо другой средой.

## Доступ к артефактам пакетов между заданиями Jenkins

В расширении для [Доступ к артефактам пакета между несколькими запусками tox](obshie-sovety-po-tox.md#dostup-k-artefaktam-paketa-mezhdu-neskolkimi-zapuskami-tox) вы также можете настроить задания **Jenkins** для доступа к артефактам друг друга. **tox** использует каталог **distshare** для доступа к артефактам и в контексте **Jenkins** (обнаруживается по наличию переменной среды **HUDSON\_URL**); по умолчанию это `{toxworkdir}/distshare`.

Это означает, что каждое рабочее пространство будет иметь свой собственный каталог **distshare**, и нам нужно настроить **Jenkins** для выполнения копирования артефактов. Рекомендуемый способ сделать это - установить [плагин Jenkins Copy Artifact](https://plugins.jenkins.io/copyartifact/) и для каждого задания, которое «получает» артефакты, вы добавляете  **Copy artifacts from another project** этапа сборки, используя примерно такую конфигурацию:

```bash
Project-name: name of the other (tox-managed) job you want the artifact from
Artifacts to copy: .tox/dist/*.zip   # где рабочие места tox создают артефакты
Target directory: .tox/distshare     # где мы хотим, чтобы это появилось для нас
Flatten Directories: CHECK           # не создавать субкаталог-структуру
```

Вам также необходимо настроить «другое» задание для архивации артефактов; Для этого установите флажок `Archive the artifacts` и введите:

```bash
Files to archive: .tox/dist/*.zip
```

Таким образом, наше «другое» задание создаст артефакт **sdist-package**, а плагин «**copy-artifacts**» скопирует его в нашу область **distshare**. Теперь все происходит так, как это показывают [Доступ к артефактам пакета между несколькими запусками tox](obshie-sovety-po-tox.md#dostup-k-artefaktam-paketa-mezhdu-neskolkimi-zapuskami-tox).

Поэтому, если вы используете значения по умолчанию, вы можете повторно использовать и отлаживать точно такой же файл `tox.ini` и использовать автоматический обмен артефактами между запусками или заданиями **Jenkins**.

## Как избежать ошибки «слишком длинный путь» при использовании длинных строк shebang

При использовании **tox** в экземпляре **Jenkins** может возникнуть ситуация, когда **tox** не может вызвать **pip**, потому что строка shebang (Unix) слишком длинная. Некоторые системы поддерживают только ограниченное количество символов для директивы интерпретатора (например, Linux как ограничение 128). Есть два метода решения этой проблемы:

1. Вызов **tox** с параметром `--workdir`, который указывает **tox** использовать определенный каталог для своих виртуальных сред. Использование уникального и короткого пути может предотвратить эту проблему.
2. Используйте переменную среды **TOX\_LIMITED\_SHEBANG** для работы со средами с ограничениями директив интерпретатора (дополнительную информацию см. в [длинных директивах интерпретатора](../specifikaciya-konfiguracii-tox.md#obrabotka-direktivy-interpretatora-s-bolshoi-dlinoi)).

## Параллельное выполнение среды tox

**Jenkins** имеет параллельные этапы, позволяющие запускать команды параллельно, однако создание пакета **tox** не является параллельным безопасным. Используйте флаг `--parallel--safe-build`, чтобы включить параллельные безопасные сборки (это создаст уникальные имена папок для **distdir**, **distshare** и **log**. Вот общее определение этапа, демонстрирующее, как использовать это внутри **Jenkins**:

```python
stage('run tox envs') {
  steps {
    script {
      def envs = sh(returnStdout: true, script: "tox -l").trim().split('\n')
      def cmds = envs.collectEntries({ tox_env ->
        [tox_env, {
          sh "tox --parallel--safe-build -vve $tox_env"
        }]
      })
      parallel(cmds)
    }
  }
}
```
