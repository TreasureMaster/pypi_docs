# Публикация пакета

## The Python Package Index (PyPI)

Индекс пакетов Python (PyPI), ранее известный как Cheeseshop, для Python является тем же, чем [CPAN](glossarii.md#cpan) для [Perl](glossarii.md#perl): центральным хранилищем проектов и [дистрибутивов](glossarii.md#distribution).

{% hint style="info" %}
XXX поместите сюда отрывок из Cheeseshop Monty Python
{% endhint %}

PyPI расположен по адресу [http://pypi.python.org](http://pypi.python.org) и содержит более 9000 проектов, зарегистрированных разработчиками сообщества.

![](../../.gitbook/assets/pypi\_screenshot.jpg)

Такие инструменты, как [pip](ustanovka-instrumentov-upakovki.md#pip-ustanavlivaet-python-pip) или [zc.buildout](https://pypi.org/project/zc.buildout/), используют PyPI в качестве расположения по умолчанию для поиска дистрибутивов для установки. Когда вызывается `pip install Foo`, он просматривает PyPI, чтобы найти последнюю доступную версию проекта **Foo**, используя [протокол Simple Index](publikaciya-paketa.md#protokol-prostogo-indeksa). Если он его найдет, он загрузит и установит его автоматически.

Эта автоматическая установка а-ля [Pip Installs Python (Pip)](ustanovka-instrumentov-upakovki.md#pip-ustanavlivaet-python-pip) будет работать только в том случае, если дистрибутив использует структуру на основе **distutils** и содержит файл `setup.py`.

Это означает, что любой серьезный проект Python должен использовать distutils (см. основы для этого) и должен быть как минимум зарегистрирован в PyPI. Загрузка релизов также является хорошей практикой.

{% hint style="info" %}
??? Почему проект как минимум должен регистрироваться на PyPI? хорошая практика, да; как минимум, нет
{% endhint %}

### Регистрация проектов

Регистрация проекта в PyPI выполняется с помощью команды «_**register**_» **distutils**. Эта команда выполняет простую HTTP-запись с использованием базовой аутентификации с именем входа и паролем, хранящимися в файле `.pypirc`, расположенном в вашем домашнем каталоге. Этот логин должен быть зарегистрирован в PyPI, поэтому вам следует зайти туда и создать учетную запись, прежде чем запускать регистрацию в первый раз.

Другой вариант - вызвать _**register**_ один раз в любом проекте на основе **distutils**. Он зарегистрирует для вас новую учетную запись, и все, что вам нужно будет сделать, это ответить на электронное письмо с подтверждением, которое PyPI отправит вам:

```bash
$ python setup.py register
running register
warning: register: missing required meta-data: version
We need to know who you are, so please choose either:
1. use your existing login,
2. register as a new user,
3. have the server generate a new password for you (and email it to you), or
4. quit
Your selection [default 1]:
...
```

Как только это будет сделано, программа _**register**_ спросит вас, хотите ли вы сохранить данные для входа в файл `.pypirc`. По умолчанию в нем будут храниться имя пользователя **и** пароль:

```bash
[distutils]
index-servers =
    pypi

[pypi]
username:tarek
password:sigourney_as_an_avatar_is_scary
```

По соображениям безопасности, начиная с **Python 2.6**, вы можете удалить пароль из файла, если вы хотите зарегистрироваться, чтобы предлагать вам вводить его каждый раз.

{% hint style="info" %}
Недавний проект GSoC под названием Keyring был создан в 2009 году для того, чтобы использовать любую доступную системную связку ключей, такую как KWallet или KeyChain, для хранения пароля PyPI. Проект существует и может использоваться в **distutils** командами _**register**_ и _**upload**_.

См. [https://pypi.org/project/keyring/](https://pypi.org/project/keyring/)
{% endhint %}

Как только ваша учетная запись будет готова, регистрация ее в PyPI создаст там новую веб-страницу с использованием полей метаданных вашего проекта.

* _**name**_ - будет использоваться как уникальный идентификатор в PyPI. Например, если ваш проект называется **Foo**, его страница будет расположена по адресу _**http://pypi.python.org/pypi/foo**_. Правило в PyPI - первым приходит, первым обслуживается, а это означает, что после регистрации проекта **Foo** ваш логин является владельцем идентификатора PyPI **foo**, и никто другой (если вы не авторизуете их) не сможет зарегистрировать проект под этим имя.
* _**long\_description**_ - будет использоваться для заполнения этой страницы. Отрисованный HTML-код для [reStructuredText](glossarii.md#restructuredtext) будет использоваться в поле перед его отображением.

Рекомендуется использовать **reST** и убедиться, что ваше поле _**long\_description**_ не содержит синтаксических ошибок **reStructuredText**. См. rest\_example для быстрого ознакомления с тем, как написать поле, совместимое с **reST**.

Чтобы выполнить проверку, установите **docutils** с помощью Pip (`pip install docutils`) и запустите:

```bash
$ python setup.py --long-description | rst2html.py > /dev/null
```

В Windows убедитесь, что путь `sys.prefix + «Scripts/»` находится в переменной среды **PATH**, и выполните:

```bash
$ python.exe setup.py --long-description | rst2html.py > dummy.html
```

Если ваш текст содержит какие-либо ошибки или предупреждения reST, они будут отображены.

Начиная с **Python 2.7**, вы можете использовать команду _**check**_ вместо вызова сценария `rst2html.py`, если установлен **docutils**:

```bash
$ python setup.py check
```

Команда _**check**_ проверит соответствие всех полей перед регистрацией проекта в PyPI.

### Загрузка дистрибутивов

PyPI также позволяет разработчикам загружать дистрибутивы своих проектов. Это можно сделать вручную через веб-форму, а также через **distutils** с помощью команды _**upload**_.

Эта команда загрузит только что созданные архивы через HTTP в PyPI. Обычный способ сделать это - вызвать _**upload**_ сразу после _**register**_ и команд, используемых для создания архивов. Например, чтобы загрузить исходный дистрибутив и обновить страницу проекта, можно:

```bash
$ python setup.py register sdist upload
```

Обратите внимание, что вы можете загрузить несколько архивов за один шаг, если хотите:

```bash
$ python setup.py register sdist bdist upload
```

Хорошая практика при загрузке дистрибутивов в PyPI - всегда загружать исходный дистрибутив, если, конечно, ваш проект не является открытым. Двоичное распространение не является обязательным, особенно если ваш проект не содержит расширения для компиляции. Это поможет автоматическим установщикам, таким как **pip**, получить и установить ваш проект на любой платформе. Загрузка только двоичного дистрибутива ограничит автоматическую установку платформой и версией Python, с которой он был скомпилирован.

### Протокол простого индекса

Помимо своих веб-страниц, PyPI предоставляет древовидную структуру по адресу [http://pypi.python.org/simple](http://pypi.python.org/simple), называемую **Simple Index**. Эта структура позволяет установщикам, таким как **pip**, искать архивы распространения.

Например, вызвав:

```bash
$ pip install distribute
```

просмотрит страницу [http://pypi.python.org/simple/distribute](http://pypi.python.org/simple/distribute), которая представляет собой список URL-адресов для проекта **distribute**. Эти URL-адреса включают:

* архивы **distribute**, загруженные на PyPI
* ссылку на главную страницу проекта
* дополнительные ссылки, содержащиеся в полях описания проекта

Индекс пакета соответствует этим правилам (взятым из документации **setuptools**):

* Его страницы в HTML
* URL-адреса страниц отдельных версий проекта должны иметь вид `base/projectname/version`, где _**base**_ - это базовый URL-адрес индекса пакета. Базовый URL-адрес PyPI: [http://pypi.python.org/simple](http://pypi.python.org/simple).
* Если опустить часть `/version` в URL-адресе страницы проекта (но оставить в конце `/`), страница должна иметь либо:
  * Единственную активную версию этого проекта, как если бы версия была явно включена, ИЛИ
  * Страницу со ссылками на все страницы активных версий этого проекта.

В зависимости от конфигурации проекта PyPI будет отображать один из последних двух пунктов.

* Страницы отдельных версий проекта должны содержать прямые ссылки на загружаемые дистрибутивы, где это возможно. Поле «_**long\_description**_» проекта может содержать отображаемые URL.
* Если возможно, информацию **MD5** следует добавлять в URL-адреса загрузки путем добавления идентификатора фрагмента в форме `#md5=...`, где `...` - 32-значный дайджест **MD5** в шестнадцатеричном формате.
* Страницы отдельных версий проекта должны идентифицировать любые URL-адреса «домашней страницы» или «загрузки» с помощью атрибутов `rel = "homepage"` и `rel = "download"` в элементах HTML, ссылающихся на эти URL-адреса. Использование этих атрибутов приведет к тому, что **EasyInstall** всегда будет переходить по предоставленным ссылкам, если только при проверке не будет установлено, что это загружаемые дистрибутивы. Если ссылки не на загружаемые дистрибутивы, они извлекаются, а если они HTML, они сканируются на наличие ссылок для загрузки. Они не сканируются на предмет дополнительных ссылок «домашняя страница» или «загрузка», поскольку они обрабатываются только для страниц, которые являются частью сайта индекса пакетов.
* Корневой URL-адрес индекса, если он получен с завершающим `/`, должен привести к странице, содержащей ссылки на страницы активных версий всех проектов. (_Примечание._ Это требование является обходным путем при отсутствии совпадения имен проектов в путях URL-адресов с помощью функции `safe_name ()` без учета регистра. Если имена проектов совпадают таким образом (например, через сервер PyPI, **mod\_rewrite** или аналогичный механизм), то тогда нет необходимости включать эту страницу со списком всех пакетов.)
* Если доступ к индексу пакета осуществляется через URL-адрес `file://`, **EasyInstall** будет автоматически использовать файлы `index.html`, если они есть, при попытке прочитать каталог с завершающим `/` в URL-адресе.

### Интерфейс XML-RPC

{% hint style="info" %}
XXX указатель на документ разработчика PyPI + демонстрация с желтком
{% endhint %}

### Ограничения системы

За последние несколько лет PyPI стал лидером в экосистеме разработки Python. Например, разработчики **Plone**, которые используют `zc.buildout` для установки приложений на основе **Plone**, делают сотни обращений к PyPI каждый раз при сборке своих проектов. Это потому, что в настоящее время многие веб-приложения используют сотни небольших дистрибутивов Python.

Это имеет плохой побочный эффект: если PyPI не работает, создание некоторых приложений становится невозможным. PyPI действует как  `Single Point of Failure` (**SPOF**).

Сервер PyPI довольно надежен, и его время безотказной работы, вероятно, составляет около 99,99%, хотя люди сталкиваются с проблемой SPOF один или два раза в год. Сообщество начало разрабатывать стратегии, чтобы избежать этого:

* `zc.buildout` поставляется с кешем, в котором будут храниться копии загруженных архивов в локальной системе. Это позволяет избежать получения пакетов в PyPI, когда они уже были загружены один раз.
* проект [collective.eggproxy](https://pypi.org/project/collective.eggproxy/) предоставляет кэш-сервер, который действует как прокси между разработчиками и PyPI, и кэширует файлы PyPI, как это делает `zc.buildout`.
* проект [z3c.pypimirror](https://pypi.org/project/z3c.pypimirror/) - это сценарий зеркалирования, который синхронизирует локальную копию простого индекса, чтобы инструменты могли использовать его вместо вызова PyPI.

В прошлом году был добавлен **PEP 381** для описания протокола зеркалирования и создания официального «кольца» зеркал PyPI. Эта система должна быть готова к концу 2010 года и будет предоставлять запись DNS на `mirrors.pypi.org`, в которой перечислены все IP-адреса зеркал. Это позволит таким инструментам, как [Pip Installs Python (Pip)](ustanovka-instrumentov-upakovki.md#pip-ustanavlivaet-python-pip), перечислить все зеркала и выбрать ближайший или вернуться в случае отказа сервера.

## Частные и вторичные серверы PyPI

{% hint style="info" %}
XXX объясняет здесь, что другие серверы могут иметь функцию pypi (например, **plone.org** или частные).
{% endhint %}

{% hint style="info" %}
XXX объясняет, что pip может указывать на любой pypi-подобный сервер
{% endhint %}

{% hint style="info" %}
ХХХ делает вывод об идее слияния нескольких индексов
{% endhint %}
