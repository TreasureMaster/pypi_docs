# Спецификации

## Спецификация наименования

## Спецификация управления версиями

### Как выбрать версию для вашего проекта Python

Версия пакета определяется в файле `setup.py`. Выглядит `setup.py` примерно так:

```python
from distutils.core import setup

setup(
      name='MyProject',
      version='1.0',
      author='Tarek',
      author_email='tarek@ziade.org',
      url='http://example.com',
)
```

И это дает вам возможность зарегистрировать **register** и загрузить **upload** свой проект в [индекс пакетов Python (PyPI)](ustanovka-instrumentov-upakovki.md#pip-ustanavlivaet-python-pip) так же просто, как:

```bash
$ python setup.py register sdist upload
```

Затем ваш проект добавляется в PyPI среди более чем 9000 других проектов, и люди могут начать его использовать, загрузив архив, созданный с помощью команды **sdist**.

С помощью они даже могут установить его с помощью простой команды **pip,** а-ля **apt-get**:

```bash
$ pip install MyProject
```

### Зачем нужны номера версий?

Как только вы начнете публиковать свой проект в мире, вам потребуется его версия. Например, первая версия вашего программного обеспечения может быть `1.0`.

Каждый раз, когда вы выпускаете новую версию с новыми функциями и исправлениями, повышение номера версии позволит вашим конечным пользователям узнать, что это более новая версия. Обычно это делается путем увеличения версии, поэтому следующей версией может быть `1.1`.

Как только эта новая версия станет доступной всему миру на PyPI, люди смогут установить ее, например, с помощью **pip**:

```bash
$ pip install --upgrade MyProject
```

Опция `--upgrade` здесь означает, что **pip** будет искать все опубликованные версии **MyProject** на PyPI и определять, какая из них является последней, а затем обновлять вашу систему до этой версии, если вы не обновлены.

Теперь представьте, что вы внесли небольшую ошибку в `1.1`, которая делает ваш проект непригодным для использования в Windows. Вы работаете над этим, но знаете, что вам потребуется время, чтобы решить эту проблему.

Лучшая стратегия здесь - посоветовать пользователю Windows придерживаться версии `1.0`, пока вы не исправите проблему. Они могут перейти на версию `1.0`, потому что она все еще доступна в PyPI:

```bash
$ pip install MyProject==1.0
```

Это возможно, потому что **pip** может сортировать различные версии вашего проекта, если он следует стандартной схеме версий.

### Стандартные схемы управления версиями

Две наиболее распространенные схемы, используемые для версии программного обеспечения, - это схемы на основе даты **date-based** и схемы на основе последовательности **sequence-based**.

### Схема на основе даты

Некоторые проекты используют даты для номеров версий. Так было с **Wine** до того, как он начал использовать схему, основанную на последовательностях. Схема даты обычно использует форму ГГГГ-ММ-ДД, поэтому версии могут быть отсортированы в буквенно-цифровом порядке:

* 2009-08-10
* 2005-02-03
* и т.д.

Эта схема управления версиями имеет несколько ограничений:

* вам нужно добавить часы в схему, если вы делаете более одного релиза в день.
* если у вас есть ветки обслуживания над более ранними выпусками, общий порядок больше не будет работать: выпуск обслуживания более старой версии будет казаться более новым, чем последний выпуск.

Хотя схемы дат обычно используются как дополнительные маркеры в схемах версий.

### Схема на основе последовательности

Наиболее распространенной схемой является схема, основанная на последовательностях, где каждая версия представляет собой последовательность числовых значений, обычно разделенных точками (`.`):

* 1.0
* 1.1
* 1.0.1
* 1.3.4

Эта схема снимает ограничения, которые мы видели в схемах, основанных на дате, поскольку вы можете выпускать обслуживаемые версии и поддерживать надлежащий порядок: версии упорядочиваются путем буквенно-цифрового сравнения каждого сегмента версии.

Наиболее частая схема на основе последовательности:

```bash
MAJOR.MINOR[.MICRO]
```

где **MAJOR** обозначает основной номер версии программного обеспечения, например `2` или `3` для Python. Обычно увеличение номера основной версии означает, что вы добавляете множество функций, нарушаете обратную совместимость или радикально меняете API или ABI.

**MINOR** обычно группирует умеренные изменения программного обеспечения, такие как исправления ошибок или незначительные улучшения. В большинстве случаев конечные пользователи могут без риска обновить свое программное обеспечение до новой вспомогательной версии. В случае изменения API конечные пользователи будут уведомлены с предупреждениями об устаревании. Другими словами, стабильность API и ABI обычно возникает между двумя второстепенными выпусками.

Некоторые программы используют третий уровень: **MICRO**. Этот уровень используется, когда цикл выпуска второстепенного выпуска довольно длинный. В этом случае микро-релизы посвящены исправлению ошибок.

Выбор между схемой на основе мажора и схемой на микроуровне - это действительно дело вкуса. Самое важное - задокументировать, как работает ваша схема версий и чего ожидать конечным пользователям, когда вы выпускаете новую версию. Так что не забудьте правильно определить цикл выпуска, прежде чем начинать выпускать в мир!

### Релизы во время разработки

При работе над следующей версией вашего приложения вам может потребоваться выпустить версию для разработки, чтобы поделиться ею с другими разработчиками. Многие проекты предоставляют **ночные сборки**, которые представляют собой ежедневные снимки репозитория кода, которые люди могут установить, чтобы опробовать передовую версию.

Как и обычные версии, разрабатываемые версии должны быть пронумерованы, чтобы их можно было отсортировать и сравнить с любой другой версией. Самый простой способ выполнить эту нумерацию - использовать текущий номер версии репозитория при создании выпуска. Следующая версия имеет суффикс разработчика. Конечно, это означает, что ваш код находится в репозитории, таком как Subversion или Mercurial.

Примеры:

* **1.2.dev1234**: разрабатываемая версия будущего выпуска `1.2`, где `1234` - текущая версия репозитория.
* **1.3a2.dev12**: разрабатываемая версия будущего выпуска `1.3 alpha 2`, где `12` - текущая версия репозитория.

Менеджеры пакетов, которые установят эти версии, должны будут правильно их отсортировать: `1.2.dev1234 < 1.2 < 1.3a2.dev12 < 1.3a2 < 1.3`

Вот пример файла `setup.py` в проекте, который находится в репозитории Mercurial, который автоматически сгенерирует правильную версию разработки при создании исходного дистрибутива:

```python
from distutils.command.sdist import sdist
import os

class sdist_hg(sdist):

    user_options = sdist.user_options + [
            ('dev', None, "Add a dev marker")
            ]

    def initialize_options(self):
        sdist.initialize_options(self)
        self.dev = 0

    def run(self):
        if self.dev:
            suffix = '.dev%d' % self.get_tip_revision()
            self.distribution.metadata.version += suffix
        sdist.run(self)

    def get_tip_revision(self, path=os.getcwd()):
        from mercurial.hg import repository
        from mercurial.ui import ui
        from mercurial import node
        repo = repository(ui(), path)
        tip = repo.changelog.tip()
        return repo.changelog.rev(tip)

setup(name='MyProject',
      version='1.0',
      packages=['package'],
      cmdclass={'sdist': sdist_hg})
```

Этот маркер разработки будет добавлен при использовании опции **dev**.

### Предварительные релизы

Основным версиям программного обеспечения часто предшествуют предварительные версии. Эти предварительные версии сравнимы с версиями для разработки и выпущены для тестирования. Их публикация позволит вашим конечным пользователям опробовать их и отправить вам ценные отзывы до того, как будет опубликована окончательная _**final**_ версия. Это также помогает избежать выпуска версий в коричневой упаковке. Версия с коричневой сумкой - это версия, которая сильно сломана и не может быть использована некоторыми из всех конечных пользователей.

Обычно предварительные релизы проходят в три этапа:

* **alpha**-релизы: ранние пре-релизы. Между альфа-версией и окончательной версией может произойти множество изменений, таких как добавление функций или рефакторинг. Но это незначительные изменения, и к моменту выхода первой бета-версии программное обеспечение должно оставаться практически неизменным.
* **beta**-версии: на данном этапе новые функции не добавляются, и разработчики отслеживают оставшиеся ошибки
* релизы **release-candidate (rc)**: релиз-кандидат - это окончательный релиз до финального релиза. Если не случится чего-то плохого, ничего не изменится.

Конечно, количество предварительных релизов сильно варьируется в зависимости от размера вашего проекта и количества конечных пользователей. У самого Python есть несколько выпусков альфа, бета и релиз-кандидатов, когда выпускается второстепенная версия, потому что это влияет на множество людей и организаций.

У небольших проектов часто нет предварительных релизов, потому что они могут опубликовать новую финальную версию в любое время. У некоторых небольших проектов есть предварительные релизы, даже если они могут их пропустить, потому что это полезно для увеличения обратной связи и оказывает положительное психологическое воздействие на конечных пользователей. Например, наличие серии предварительных релизов для вашей версии «`1.0`» увеличит шансы опубликовать надежную версию. А отметка «`1.0`» может много значить для ваших конечных пользователей: такие круглые числа позволяют им почувствовать, что ваше программное обеспечение достигло важного шага в своем развитии.

### Пост-релизы

Некоторые проекты используют пост-релизы, когда им нужно опубликовать версию, которая просто не подходит для следующей серии или не может быть новой версией в текущей серии. Рассмотрим пример: «`1.9`» - это последний выпуск вашей серии «`1.x`», а вы начали обратную несовместимую серию «`2.x`». Вы хотите, чтобы все ваши пользователи как можно скорее отказались от любого выпуска «`1.x`». Вы довольно долго выпускали отладочные версии серии «`1.x`» и заявили, что «`1.9`» была последней. Однако пользователь находит действительно серьезную ошибку в «`1.9`» и просит вас исправить ее, потому что он не может переключиться на новую серию. В этом случае полезно опубликовать пост-релиз.

Этот вариант использования встречается довольно редко, и, вероятно, вам никогда не придется выпускать пост-релизы.

### Определение цикла выпуска

Программное обеспечение обычно следует этому циклу:

* версии для внутренней разработки могут быть выпущены в целях тестирования. Эти выпуски могут быть частными для круга разработчиков, но они все равно должны иметь версии. Это хорошая практика, потому что, в отличие от захвата текущей версии для разработки из репозитория кода, это поможет протестировать процесс выпуска: если есть ошибка в вашем файле `setup.py` или в любой части вашего `release/deploy/` в процессе установки, они могут быть обнаружены на ранней стадии.
* один или несколько предварительных выпусков предназначены для получения отзывов конечных пользователей и предотвращения выпуска _**коричневой версии**_, как мы видели в предыдущем разделе. Сколько выпустить кандидатов или также apha и бета-версии зависит от вас. Здесь нет никаких правил, но считается излишним иметь альфа- и бета-версии для небольших проектов (небольшой здесь будет менее 5 тыс. SLOC или менее 50 конечных пользователей).
* финальная версия выпускается в мире, обычно начиная с `1.0` или `0.1`. Микроверсии считаются избыточными, если цикл выпуска вашей младшей версии не длится месяцами, а вы хотите сохранить один и тот же основной номер в течение многих лет.
* добавлены исправления, новые функции и выпущены новые версии
* при запуске новой основной версии, такой как «`2.0`», выпуски с исправлениями ошибок могут продолжаться в серии «`1.x`», в зависимости от стоимости перехода на «`2.0`» для конечных пользователей.

### Использование схемы, совместимой с PEP 386

**PEP 386** определяет стандартную схему версий, которая должна использоваться приложениями Python, публикующими выпуски в PyPI. Он обеспечивает взаимодействие между всеми основными диспетчерами пакетов и установщиками. Другими словами, он будет следить за тем, чтобы все версии проекта были правильно распознаны и отсортированы, пока используется схема, совместимая с **PEP 386**.

{% hint style="info" %}
XXX поместите ссылку, подробнее
{% endhint %}

{% hint style="info" %}
XXX говорят здесь, что люди должны смотреть, как работают большие проекты (python, zope, twisted)
{% endhint %}
