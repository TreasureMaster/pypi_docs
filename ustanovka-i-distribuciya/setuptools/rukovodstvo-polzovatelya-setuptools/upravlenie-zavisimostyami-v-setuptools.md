# Управление зависимостями в setuptools

**Setuptools** предлагает три типа стилей зависимости:

1. требование к системе сборки
2. требуемая зависимость
3. необязательная зависимость

{% hint style="info" %}
**ПРИМЕЧАНИЕ:**

Пакеты, которые добавляются в зависимости, могут быть дополнительно указаны с версией, следуя [PEP 440](https://www.python.org/dev/peps/pep-0440/)
{% endhint %}

## Системные требования сборки

### Требования к пакету

После организации всех скриптов и файлов и подготовки к упаковке должен быть способ сообщить Python, какие программы ему действительно нужны для упаковки (в нашем случае, конечно, **setuptools**). Обычно вам также нужен пакет **wheel**, поскольку рекомендуется загружать файл `.whl` в **PyPI** вместе с файлом `.tar.gz`. В отличие от двух других типов зависимостей ключевого слова, это ключевое слово указано в вашем файле `pyproject.toml` (если вы забыли, что это такое, перейдите к [быстрому запуску setuptools](bystryi-start-setuptools.md) или (WIP)):

```bash
[build-system]
requires = ["setuptools", "wheel"]
#...
```

{% hint style="info" %}
**ЗАМЕЧАНИЕ:**

Раньше это выполнялось с помощью ключевого слова `setup_requires`, но теперь считается устаревшим в пользу стиля **PEP 517**, описанного выше. Чтобы узнать, как используется это устаревшее ключевое слово, обратитесь к нашему [руководству по устаревшей практике (WIP)](../rukovodstva-po-obratnoi-sovmestimosti-i-ustarevshei-praktike/)
{% endhint %}

## Объявление необходимой зависимости

Здесь пакет объявляет свои основные зависимости, без которых он не сможет работать. **setuptools** поддерживает автоматическую загрузку и установку этих зависимостей при установке пакета. Хотя в этом есть больше хитрости, давайте начнем с простого примера.

```bash
[options]
#...
install_requires =
    docutils
    BazSpam ==1.1
```

```python
setup(
    #...,
    install_requires = [
        'docutils',
        'BazSpam ==1.1'
    ]
)
```

Когда ваш проект установлен (например, с помощью **pip**), все зависимости, которые еще не установлены, будут найдены (через **PyPI**), загружены, построены (при необходимости) и установлены и 2) Любые скрипты в вашем проекте будут установлены с оболочками, которые проверить доступность указанных зависимостей во время выполнения.

### Зависимости конкретных платформ

Инструменты установки предлагают возможность оценить определенные условия, прежде чем слепо устанавливать все, что указано в `install_requires`. Это отлично подходит для зависимостей от платформы. Например, пакет **enum** был добавлен в Python 3.4, поэтому пакет, который зависит от него, может выбрать его установку только в том случае, если версия Python старше 3.4. Для этого

```bash
[options]
#...
install_requires =
    enum34;python_version<'3.4'
```

```python
setup(
    #...
    install_requires=[
        "enum34;python_version<'3.4'",]
)
```

Точно так же, если вы также хотите объявить **pywin32** с минимальной версией `1.0` и установить его только в том случае, если пользователь использует операционную систему **Windows**:

```bash
[options]
#...
install_requires =
    enum34;python_version<'3.4'
    pywin32 >= 1.0;platform_system=='Windows'
```

```python
setup(
    #...
    install_requires=[
        "enum34;python_version<'3.4'",
        "pywin32 >= 1.0;platform_system=='Windows'"
        ]
)
```

Маркеры окружающей среды, которые могут использоваться для типов платформ тестирования, подробно описаны в [PEP 508](https://www.python.org/dev/peps/pep-0508/).

### Зависимости, которых нет в PyPI

{% hint style="danger" %}
**ПРЕДУПРЕЖДЕНИЕ:**

Поддержка ссылок зависимостей была прекращена в **pip**, начиная с версии 19.0 (выпущенной 22 января 2019 г.).
{% endhint %}

Если ваш проект зависит от пакетов, которых нет в **PyPI**, вы все равно можете полагаться на них, если они доступны для загрузки как:

* **egg** в стандартном формате **distutils** `sdist`
* одиночный файл `.py`
* репозиторий VCS (Subversion, Mercurial или Git)

Вам просто нужно добавить несколько URL-адресов в аргумент `dependency_links` для `setup ()`.

URL-адреса должны быть либо:

1. URL для прямой загрузки
2. URL-адреса веб-страниц, содержащих прямые ссылки для скачивания
3. URL репозитория

В общем, лучше давать ссылки на веб-страницы, потому что, как правило, обновить веб-страницу проще, чем выпустить новую версию вашего проекта. Вы также можете использовать ссылку на **SourceForge** `showfiles.php` в случае, если пакет, от которого вы зависите, распространяется через **SourceForge**.

Если вы зависите от пакета, который распространяется как отдельный файл `.py`, вы должны включить суффикс `"#egg=project-version"` в URL-адрес, чтобы указать имя проекта и номер версии. (Обязательно избегайте дефисов в имени или версии, заменяя их символами подчеркивания.) **EasyInstall** распознает этот суффикс и автоматически создаст тривиальный файл `setup.py`, чтобы обернуть отдельный файл `.py` как **egg**.

В случае проверки VCS вы также должны добавить `#egg=project-version`, чтобы определить, для какого пакета следует использовать эту проверку. Вы можете добавить `@REV` к пути URL (перед фрагментом), чтобы указать версию. Кроме того, вы также можете принудительно использовать VCS, добавив к URL-адресу определенный префикс. В настоящее время доступны:

* `svn+URL` для Subversion
* `git+URL` для Git
* `hg+URL` для Mercurial

более полный пример:

&#x20;`vcs+proto://host/path@revision#egg=project-version`

Будьте осторожны с версией. Он должен соответствовать тому, что находится в файлах проекта. Если вы хотите проигнорировать версию, вы должны опустить ее как в `requires`, так и во фрагменте URL.

Это выполнит проверку (или клон, на языке Git и Mercurial) во временную папку и запустит `setup.py bdist_egg`.

Параметр **dependency\_links** принимает форму списка строк URL. Например, это вызовет поиск на указанной странице **egg** или исходных дистрибутивов, если зависимости пакета еще не установлены:

```bash
[options]
#...
dependency_links = http://peak.telecommunity.com/snapshots/
```

```python
setup(
    #...
    dependency_links=[
        "http://peak.telecommunity.com/snapshots/"
    ],
)
```

## Необязательные зависимости

**Setuptools** позволяет объявлять зависимости, которые устанавливаются только при определенных обстоятельствах. Эти зависимости указываются с помощью ключевого слова **extras\_require** и устанавливаются только в том случае, если от него зависит другой пакет (прямо или косвенно). Это позволяет удобно объявлять зависимости для вспомогательных функций, таких как «tests» и «docs».

{% hint style="info" %}
**ЗАМЕЧАНИЕ:**

**tests\_require** больше не рекомендуется
{% endhint %}

Например, Package-A предлагает дополнительную поддержку PDF и требует для работы двух других зависимостей:

```bash
[metadata]
name = Package-A

[options.extras_require]
PDF = ReportLab>=1.2; RXP
```

```python
setup(
    name="Project-A",
    #...
    extras_require={
        "PDF":  ["ReportLab>=1.2", "RXP"],
    }
)
```

Имя **PDF** - это произвольный идентификатор такого списка зависимостей, на который могут ссылаться другие компоненты и устанавливать их. Есть два распространенных варианта использования.

Сначала точка входа **console\_scripts**:

```bash
[metadata]
name = Project A
#...

[options]
#...
entry_points=
    [console_scripts]
    rst2pdf = project_a.tools.pdfgen [PDF]
    rst2html = project_a.tools.htmlgen
```

```python
setup(
    name = "Project-A"
    #...,
    entry_points={
        "console_scripts": [
            "rst2pdf = project_a.tools.pdfgen [PDF]",
            "rst2html = project_a.tools.htmlgen",
        ],
    }
)
```

Этот синтаксис указывает, что точка входа (в данном случае консольный скрипт) действительна только в том случае, если установлен дополнительный PDF-файл. Установщик должен определить, как справиться с ситуацией, когда PDF не был указан (например, опустить консольный скрипт, предоставить предупреждение при попытке загрузить точку входа, предположить, что дополнительные функции присутствуют, и позволить реализации потерпеть неудачу позже).

Второй вариант использования заключается в том, что другой пакет может использовать это «extra» для своих собственных зависимостей. Например, если «Project-B» требуется «Project-A» с установленной поддержкой PDF, он может объявить зависимость следующим образом:

```bash
[metadata]
name = Project-B
#...

[options]
#...
install_requires =
    Project-A[PDF]
```

```python
setup(
    name="Project-B",
    install_requires=["Project-A[PDF]"],
    ...
)
```

Это приведет к установке **ReportLab** вместе с проектом A, если проект B установлен, даже если проект A уже был установлен. Таким образом, проект может инкапсулировать группы необязательных «подчиненных зависимостей» под именем функции, так что пакеты, которые зависят от него, не должны знать, каковы подчиненные зависимости. Если в более поздней версии проекта A встроена поддержка PDF и больше не требуется **ReportLab**, или если для обеспечения поддержки PDF ему потребуются другие зависимости, помимо **ReportLab**, информацию о настройке проекта B менять не нужно, но нужные пакеты все равно могут быть установлены при необходимости.

{% hint style="info" %}
**ПРИМЕЧАНИЕ:**

Лучшая практика: если проекту не нужны никакие другие пакеты для поддержки функции, он должен сохранить пустой список требований для этой функции в аргументе **extras\_require**, чтобы пакеты, зависящие от этой функции, не ломались (из-за недопустимого имени функции).
{% endhint %}

## Требование Python

В некоторых случаях вам может потребоваться указать минимальную требуемую версию Python. Это обрабатывается с помощью ключевого слова **python\_requires**, передаваемого в `setup.cfg` или `setup.py`.

Пример WIP.
