# Обнаружение пакетов и пакет пространства имен

## Обнаружение пакетов и пакет пространства имен

{% hint style="info" %}
**Замечание:**

полную спецификацию ключевого слова, предоставленного в `setup.cfg` или `setup.py`, можно найти в [справочнике по ключевым словам](../klyuchevye-slova-setuptools.md).
{% endhint %}

{% hint style="info" %}
**Замечание:**

приведенные здесь примеры предназначены только для демонстрации представленных функций. Если вы хотите реплицировать их в своей системе, необходимо предоставить дополнительные метаданные и параметры. Если вы совсем не знакомы с инструментами настройки, начните с [раздела быстрого запуска](bystryi-start-setuptools.md).
{% endhint %}

**Setuptools** предоставляет мощные инструменты для обработки обнаружения пакетов, включая поддержку пакета пространства имен. Обычно вы указываете пакет, который нужно включить вручную, следующим образом:

```bash
[options]
#...
packages =
    mypkg1
    mypkg2
```

```python
setup(
    #...
    packages = ['mypkg1', 'mypkg2']
)
```

Это может очень быстро утомить. Чтобы ускорить процесс, мы представляем две функции, предоставляемые **setuptools**:

```bash
[options]
packages = find:
# или
packages = find_namespace:
```

```python
from setuptools import find_packages
# или
from setuptools import find_namespace_packages
```

## Использование find: или find\_packages

Начнем с первого инструмента. `find:` (`find_packages`) берет исходный каталог и два списка шаблонов имен пакетов для исключения и включения, а затем возвращает список **str**, представляющий пакеты, которые он мог найти. Чтобы использовать его, рассмотрите следующий каталог

```bash
mypkg/
    src/
        pkg1/__init__.py
        pkg2/__init__.py
        additional/__init__.py

    setup.cfg # или setup.py
```

Чтобы ваш `setup.cfg` или `setup.py` автоматически включал пакеты, найденные в `src`, которые начинаются с имени `pkg`, а не `additional`:

```bash
[options]
packages = find:
package_dir =
    =src

[options.packages.find]
where = src
include = pkg*
exclude = additional
```

```python
setup(
    #...
    packages = find_packages(
        where = 'src',
        include = ['pkg*',],
        exclude = ['additional',]
    ),
    package_dir = {"":"src"}
    #...
)
```

## Использование find\_namespace: или find\_namespace\_packages

**setuptools** предоставляет `find_namespace:` (`find_namespace_packages`), который ведет себя аналогично `find:`, но работает с пакетами пространства имен. Прежде чем погрузиться в подробности, важно хорошо понять, что такое пакеты пространств имен. Вот краткое резюме:

Предположим, у вас есть два пакета, названные следующим образом:

```bash
/Users/Desktop/timmins/foo/__init__.py
/Library/timmins/bar/__init__.py
```

Если и `Desktop`, и `Library` находятся в вашем **PYTHONPATH**, то пакет пространства имен с именем `timmins` будет автоматически создан для вас при вызове механизма импорта, что позволит вам выполнить следующие действия.

```python
>>> import timmins.foo
>>> import timmins.bar
```

как будто в вашей системе только один `timmins`. Затем эти два пакета можно распространять по отдельности и устанавливать индивидуально, не затрагивая другой. Предположим, вы упаковываете часть **foo**:

```bash
foo/
    src/
        timmins/foo/__init__.py
    setup.cfg # или setup.py
```

и вы хотите, чтобы **foo** включался автоматически, `find:` не будет работать, потому что `timmins` не содержит напрямую `__init__.py`, вместо этого вам нужно использовать `find_namespace:`:

```bash
[options]
package_dir =
    =src
packages = find_namespace:

[options.packages.find_namespace]
where = src
```

Когда вы установите заархивированный дистрибутив, вашему интерпретатору станет доступен файл `timmins.foo`.

Вы можете считать `find_namespace:` идентичным `find:` за исключением того, что он будет считать каталог как пакет, даже если он не содержит напрямую файла `__init__.py`. В результате это создает интересный побочный эффект. Если вы организовываете свой пакет так:

```bash
foo/
    timmins/
        foo/__init__.py
    setup.cfg # или setup.py
    tests/
        test_foo/__init__.py
```

наивное `find_namespace:` будет включать тесты как часть вашего пакета для установки. Простой способ исправить это - использовать вышеупомянутый макет **src**.

## Устаревшие пакеты пространств имен

Тот факт, что вы можете так легко создать пакет пространства имен, описанный выше, относится к [PEP 420](https://www.python.org/dev/peps/pep-0420/). Раньше он был более громоздким для достижения того же результата. Исторически существовало два метода создания пакетов пространств имен. Один из них - это стиль `pkg_resources`, поддерживаемый **setuptools**, а другой - стиль `pkgutils`, предлагаемый модулем **pkgutils** в Python. Оба теперь считаются устаревшими, несмотря на то, что они все еще присутствуют во многих существующих пакетах. Эти два отличаются во многих тонких, но важных аспектах, и вы можете узнать больше в [руководстве пользователя по упаковке Python](https://packaging.python.org/guides/packaging-namespace-packages/).

### Пакет пространства имен стиля pkg\_resource

Это метод, который напрямую поддерживает **setuptools**. Начиная с того же макета, вам нужно добавить к нему две части. Во-первых, файл `__init__.py` непосредственно в каталоге пакета вашего пространства имен, который содержит следующее:

```python
__import__("pkg_resources").declare_namespace(__name__)
```

И ключевое слово **namespace\_packages** в вашем `setup.cfg` или `setup.py`:

```bash
[options]
namespace_packages = timmins
```

```python
setup(
    # ...
    namespace_packages = ['timmins']
)
```

И ваш каталог должен выглядеть так

```bash
/foo/
    src/
        timmins/
            __init__.py
            foo/__init__.py
    setup.cfg # или setup.py
```

Повторите то же самое для других пакетов, и вы можете добиться того же результата, что и в предыдущем разделе.

### Пакет пространства имен стиля pkgutil

Этот метод почти идентичен **pkg\_resource**, за исключением того, что объявление **namespace\_packages** опущено, а файл `__init__.py` содержит следующее:

```python
__path__ = __import__('pkgutil').extend_path(__path__, __name__)
```

Макет проекта остается прежним, и файл `setup.cfg` остается прежним.
