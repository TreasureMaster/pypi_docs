# Пометка и выпуски «Daily Build» или «Snapshot»

## Пометка и выпуски «Daily Build» или «Snapshot»

Когда набор связанных проектов находится в стадии разработки, может быть важно отслеживать более мелкие приращения версий, чем вы обычно используете, например «стабильные» релизы. В то время как стабильные выпуски могут измеряться пунктирными числами с альфа/бета/и т.д. коды состояния, разрабатываемые версии проекта часто необходимо отслеживать по ревизии, номеру сборки или даже дате сборки. Это особенно верно, когда разрабатываемые проекты должны ссылаться друг на друга и, следовательно, может буквально нуждаться в самой последней версии чего-либо!

Для поддержки этих сценариев **setuptools** позволяет вам «помечать» исходный код и дистрибутивы egg, добавляя одно или несколько из следующих значений к «официальному» идентификатору версии проекта:

* Тег предварительной версии, указанный вручную, например `build` или `dev`, или тег, указанный вручную после выпуска, например номер сборки или версии (`--tag-build=STRING, -bSTRING`)
* 8-символьное представление даты сборки (`--tag-date, -d`) в виде тега после выпуска

Вы можете добавить эти теги, добавив `egg_info` и желаемые параметры в командную строку перед командами **sdist** или **bdist**, для которых вы хотите создать ежедневную сборку или снимок. См. [раздел о команде egg\_info](spravka-po-komandam-setuptools.md#egg\_info-sozdaet-metadannye-egg-i-ustanavlivaet-tegi-sborki) ниже для получения более подробной информации.

{% hint style="info" %}
**ПРИМЕЧАНИЕ:**

Кроме того, перед выпуском проекта обязательно ознакомьтесь с [разделом ниже](pometka-i-vypuski-daily-build-ili-snapshot.md#ukazanie-versii-vashego-proekta), посвященным указанию версии вашего проекта, чтобы получить дополнительную информацию о том, как теги до и после выпуска влияют на интерпретацию номеров версий. Это важно для обеспечения того, чтобы инструменты обработки зависимостей знали, какие версии вашего проекта новее других.
{% endhint %}

Наконец, если вы часто создаете сборки и либо создаете их в загружаемом месте, либо копируете их на сервер распространения, вам, вероятно, также следует проверить команду [rotate](spravka-po-komandam-setuptools.md#rotate-udalyaet-ustarevshie-faily-rasprostraneniya), которая позволяет автоматически удалять все, кроме N самых последних измененных распределения, соответствующие шаблону **glob**. Итак, вы можете использовать командную строку, например:

```bash
setup.py egg_info -rbDEV bdist_egg rotate -m.egg -k3
```

для создания **egg**, информация о версии которого включает «DEV-rNNNN» (где NNNN - это самая последняя ревизия **Subversion**, которая повлияла на дерево исходных текстов), а затем удалить все файлы **egg** из каталога распространения, за исключением трех, которые были созданы совсем недавно.

Если вам нужно управлять автоматическими сборками для нескольких пакетов, каждый из которых имеет разные политики тегов и ротации, вы также можете проверить команду [alias](spravka-po-komandam-setuptools.md#alias-opredelyaet-yarlyki-dlya-chasto-ispolzuemykh-komand), которая позволит каждому пакету определять псевдоним, например `daily`, который будет выполнять необходимые теги, команды **build** и **rotate**. Затем более простой сценарий или задание **cron** может просто ежедневно запускать `setup.py` в каждом каталоге проекта. (И вы также можете определить версии псевдонима `daily` по умолчанию для сайта или для каждого пользователя, чтобы проекты, которые не определяли свои собственные, использовали соответствующие значения по умолчанию.)

## Создание исходных дистрибутивов

**setuptools** расширяет стандартный алгоритм **distutils** для выбора исходного файла с помощью подключаемых конечных точек для поиска файлов для включения. Если вы используете систему контроля версий и ваши исходные дистрибутивы должны включать только файлы, которые вы отслеживаете в системе контроля версий, используйте соответствующий плагин вместо написания файла `MANIFEST.in`. См. раздел «[Добавление поддержки систем контроля версий](sozdanie-rasshirenii-distutils.md#dobavlenie-podderzhki-sistem-kontrolya-versii)» ниже для получения информации о надстройках.

Если вам нужно включить автоматически сгенерированные файлы или файлы, которые хранятся в неподдерживаемой системе контроля версий, вам потребуется создать файл `MANIFEST.in`, чтобы указать любые файлы, которые алгоритм определения местоположения файлов по умолчанию не улавливает. См. документацию distutils для получения дополнительной информации о формате файла `MANIFEST.in`.

Но обязательно игнорируйте любую часть документации **distutils**, которая касается `MANIFEST` или того, как он создается из `MANIFEST.in`; **setuptools** защищает вас от этих проблем и в любом случае работает иначе. В отличие от **distutils**, **setuptools** регенерирует файл манифеста исходного дистрибутива каждый раз, когда вы создаете исходный дистрибутив, и строит его внутри каталога `.egg-info` проекта, а не в основном каталоге проекта. Поэтому вам не нужно беспокоиться о том, актуальна она или нет.

В самом деле, поскольку подход **setuptools** к определению содержимого исходного дистрибутива намного проще, его команда **sdist** опускает почти все параметры, которые требуются более сложному процессу **sdist** `distutils`. Для всех практических целей вы, вероятно, будете использовать только параметр `--formats`, если вы вообще используете какой-либо параметр.

### Создание «официальных» (без снимков) релизов

Когда вы делаете официальный выпуск, создавая исходные или двоичные дистрибутивы, вам нужно будет переопределить настройки тега из `setup.cfg`, чтобы вам не пришлось регистрировать версии, такие как `foobar-0.7a1.dev-r34832`. Это легко сделать, если вы разрабатываете в магистрали и используете теги или ветки для своих выпусков - просто внесите изменения в `setup.cfg` после разветвления или тегирования выпуска, чтобы магистраль по-прежнему создавала моментальные снимки разработки.

В качестве альтернативы, если вы не выполняете ветвление для выпусков, вы можете переопределить параметры версии по умолчанию в командной строке, используя что-то вроде:

```bash
setup.py egg_info -Db "" sdist bdist_egg
```

Первая часть этой команды (`egg_info -Db ""`) переопределит настроенную информацию тега перед созданием исходного и двоичного **egg**. Таким образом, эти команды будут использовать простую версию из вашего `setup.py` без добавления строки обозначения сборки.

Конечно, если вы будете делать это часто, вы можете создать персональный псевдоним для этой операции, например:

```bash
setup.py alias -u release egg_info -Db ""
```

Затем вы можете использовать его так:

```bash
setup.py release sdist bdist_egg
```

Или, конечно, вы можете создать более сложные псевдонимы, которые будут выполнять все вышеперечисленное. Дополнительные идеи см. в разделах ниже о командах [egg\_info](spravka-po-komandam-setuptools.md#egg\_info-sozdaet-metadannye-egg-i-ustanavlivaet-tegi-sborki) и [alias](spravka-po-komandam-setuptools.md#alias-opredelyaet-yarlyki-dlya-chasto-ispolzuemykh-komand).

## Распространение расширений, скомпилированных с помощью Cython

**setuptools** определит во время сборки, установлен ли Cython или нет. Если Cython не найден, **setuptools** игнорирует файлы `.pyx`.

Чтобы обеспечить доступность Cython, включите Cython в раздел **build-requires** вашего `pyproject.toml`:

```bash
[build-system]
requires=[..., "cython"]
```

Создано с помощью **pip** 10 или новее, этого объявления достаточно для включения Cython в сборку. Для более широкой совместимости объявите зависимость в **setup-requires** файла `setup.cfg`:

```bash
[options]
setup_requires =
    ...
    cython
```

Пока Cython присутствует в среде сборки, **setuptools** включает прозрачную поддержку для создания расширений Cython, если расширения определены с помощью `setuptools.Extension`.

Если вы будете следовать этим правилам, вы можете безопасно указать файлы `.pyx` в качестве источника ваших объектов расширения в сценарии установки. Если это так, то **setuptools** будет использовать его.

Конечно, чтобы это работало, ваши исходные дистрибутивы должны включать код C, сгенерированный Cython, а также ваши исходные файлы `.pyx`. Это означает, что вы, вероятно, захотите включить текущие файлы `.c` в свою систему контроля версий, перестраивая их всякий раз, когда вы проверяете изменения для исходных файлов `.pyx`. Это гарантирует, что люди, отслеживающие ваш проект в системе контроля версий, смогут построить его, даже если у них не установлен Cython, и что ваши исходные версии будут одинаково использоваться с Cython или без него.

## Указание версии вашего проекта

**setuptools** могут хорошо работать с большинством схем управления версиями; однако есть несколько особых моментов, на которые следует обратить внимание, чтобы инструменты установки и другие инструменты всегда могли определить, какая версия вашего пакета новее другой. Знание этих вещей также поможет вам правильно указать, от каких версий других проектов зависит ваш проект.

Версия состоит из чередующихся серий номеров выпуска и тегов до или после выпуска. Номер версии - это серия цифр, разделенных точками, например `2.4` или `0.5`. Каждая серия цифр обрабатывается численно, поэтому выпуски `2.1` и `2.1.0` - это разные способы написания одного и того же номера выпуска, обозначающего первый подвыпуск выпуска 2. Но `2.10` - десятый подвыпуск выпуска 2, и поэтому он отличается и новее выпуска `2.1` или `2.1.0`. Начальные нули в серии цифр также игнорируются, поэтому `2.01` совпадает с `2.1` и отличается от `2.0.1`.

После номера выпуска у вас может быть тег до или после выпуска. Предварительные теги делают версию старше той версии, к которой они добавлены. Итак, версия `2.4` новее, чем версия `2.4c1`, которая, в свою очередь, новее, чем `2.4b1` или `2.4a1`. Теги пост-релиза заставляют версию считаться более новой, чем версия, к которой они добавлены. Таким образом, такие версии, как `2.4-1` и `2.4pl3`, новее `2.4`, но старше `2.4.1` (у которого номер версии выше).

Тег предварительного выпуска - это набор букв, которые располагаются в алфавитном порядке перед словом «final». Некоторые примеры предварительных тегов могут включать `alpha`, `beta`, `a`, `c`, `dev` и т. д. Необязательно ставить точку или тире перед предварительным тегом, если он стоит сразу после числа, но вы можете это сделать, если хотите. Таким образом, `2.4c1`, `2.4.c1` и `2.4-c1` представляют собой кандидата на выпуск 1 версии `2.4` и рассматриваются средствами **setuptools** как идентичные.

Кроме того, есть три специальных предварительных тега, которые обрабатываются так, как если бы они были буквой `c`: `pre`, `preview` и `rc`. Итак, версии `2.4rc1`, `2.4pre1` и `2.4preview1` в точности совпадают с версией `2.4c1` и обрабатываются **setuptools** как идентичные.

Тег пост-релиза представляет собой серию букв, которые в алфавитном порядке больше или равны «final», или тире (`-`). Теги после выпуска обычно используются для отделения номеров исправлений, номеров портов, номеров сборки, номеров ревизий или отметок даты от номера выпуска. Например, версия `2.4-r1263` может обозначать ревизию Subversion `1263` патча после выпуска версии `2.4`. Или вы можете использовать `2.4-20051127` для обозначения пост-релиза с датой.

Обратите внимание, что после каждого тега до или после выпуска вы можете разместить еще один номер выпуска, за которым снова следует несколько тегов до или после выпуска. Например, `0.6a9.dev-r41475` может обозначать ревизию Subversion `41475` разрабатываемой версии девятой альфы выпуска `0.6`. Обратите внимание, что `dev` - это тег предварительного выпуска, поэтому эта версия имеет **меньший** номер версии, чем `0.6a9`, который фактически будет девятой альфа-версией выпуска `0.6`. Но `-r41475` является тегом после выпуска, поэтому эта версия **новее**, чем `0.6a9.dev`.

По большей части интерпретация номеров версий средствами **setuptools** интуитивно понятна, но вот несколько советов, которые помогут вам избежать неприятностей в крайних случаях:

* Не склеивайте смежные предварительные теги без точки или числа между ними. Версия `1.9adev` - это предварительная версия `1.9`, а не предварительная версия `1.9a`. Вместо этого используйте `.dev`, как в `1.9a.dev`, или разделите предварительные теги номерами, как в `1.9a0dev`, `1.9a.dev`, `1.9a0dev` и даже `1.9.a.dev` - это идентичные версии с точки зрения инструментов настройки, поэтому вы можете использовать любую схему, которую захотите.
* Если вы хотите быть уверены, что выбранная вами схема нумерации работает так, как вы думаете, вы можете использовать функцию `pkg_resources.parse_version ()` для сравнения различных номеров версий:

```python
>>> from pkg_resources import parse_version
>>> parse_version("1.9.a.dev") == parse_version("1.9a0dev")
True
>>> parse_version("2.1-rc2") < parse_version("2.1")
True
>>> parse_version("0.6a9dev-r41475") < parse_version("0.6a9")
True
```

После того, как вы определились со схемой нумерации версий для своего проекта, вы можете настроить инструменты настройки автоматически пометить выпуски, находящиеся в разработке, различными тегами до или после выпуска. Для получения более подробной информации см. следующие разделы:

* [пометка и выпуски «Daily Build» или «Snapshot»](pometka-i-vypuski-daily-build-ili-snapshot.md#pometka-i-vypuski-daily-build-ili-snapshot)
* [команда egg\_info](spravka-po-komandam-setuptools.md#egg\_info-sozdaet-metadannye-egg-i-ustanavlivaet-tegi-sborki)
