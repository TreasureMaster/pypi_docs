# Поддержка файлов данных

## Поддержка файлов данных

В **distutils** традиционно разрешается установка «файлов данных», которые размещаются в определенном для платформы месте. Однако наиболее распространенный вариант использования файлов данных, распространяемых с пакетом, - использование этим пакетом, обычно путем включения файлов данных в каталог пакета.

**Setuptools** предлагает три способа указать файлы данных, которые будут включены в ваши пакеты. Во-первых, вы можете просто использовать ключевое слово **include\_package\_data**, например:

```python
from setuptools import setup, find_packages
setup(
    ...
    include_package_data=True
)
```

Это указывает программе **setuptools** устанавливать любые файлы данных, которые он найдет в ваших пакетах. Файлы данных должны быть указаны в файле **distutils** `MANIFEST.in`. (Их также можно отслеживать с помощью системы контроля версий, используя соответствующий плагин. См. ниже раздел [Добавление поддержки для систем контроля версий](sozdanie-rasshirenii-distutils.md#dobavlenie-podderzhki-sistem-kontrolya-versii), чтобы узнать, как писать такие плагины.)

Если вам нужен более точный контроль над включенными файлами (например, если у вас есть файлы документации в каталогах пакетов и вы хотите исключить их из установки), вы также можете использовать ключевое слово **package\_data**, например:

```python
from setuptools import setup, find_packages
setup(
    ...
    package_data={
        # Если какой-либо пакет содержит файлы *.txt или *.rst, включите их:
        "": ["*.txt", "*.rst"],
        # И включите любые файлы *.msg из пакета "hello":
        "hello": ["*.msg"],
    }
)
```

Аргумент **package\_data** - это словарь, который отображает имена пакетов в списки шаблонов **glob**. **Glob** могут включать имена подкаталогов, если файлы данных содержатся в подкаталоге пакета. Например, если дерево пакетов выглядит так:

```bash
setup.py
src/
    mypkg/
        __init__.py
        mypkg.txt
        data/
            somefile.dat
            otherdata.dat
```

Файл установки **setuptools** может выглядеть так:

```python
from setuptools import setup, find_packages
setup(
    ...
    packages=find_packages("src"),  # включить все пакеты в src
    package_dir={"": "src"},   # сказать, что пакеты distutils находятся под src

    package_data={
        # Если какой-либо пакет содержит файлы *.txt, включите их:
        "": ["*.txt"],
        # И включите любые файлы *.dat из подкаталога "data"
        # моего пакета "mypkg" также:
        "mypkg": ["data/*.dat"],
    }
)
```

Обратите внимание, что если вы перечисляете шаблоны в **package\_data** под пустой строкой, эти шаблоны используются для поиска файлов в каждом пакете, даже в тех, которые также имеют в списке свои собственные шаблоны. Таким образом, в приведенном выше примере файл `mypkg.txt` включается, даже если он не указан в шаблонах для `mypkg`.

Также обратите внимание, что если вы используете пути, вы **должны** использовать косую черту (`/`) в качестве разделителя пути, даже если вы работаете в **Windows**. **Setuptools** автоматически преобразует косые черты в соответствующие разделители для конкретной платформы во время сборки.

Если файлы данных содержатся в подкаталоге пакета, который не является самим пакетом (без `__init__.py`), тогда имена подкаталогов (или `*`) требуются в аргументе **package\_data** (как показано выше с `"data/*.dat"` ).

При создании **sdist** файлы данных также берутся из файла `package_name.egg-info/SOURCES.txt`, поэтому убедитесь, что он удален, если список `setup.py` **package\_data** обновляется перед вызовом `setup.py`.

{% hint style="info" %}
**ПРИМЕЧАНИЕ:**

хотя аргумент **package\_data** ранее был доступен только в **setuptools**, он также был добавлен в пакет Python **distutils** начиная с Python 2.4; на сайте `python.org` имеется [некоторая документация](https://docs.python.org/3/distutils/setupscript.html#installing-package-data) по этой функции. При использовании аргумента **include\_package\_data**, специфичного для **setuptools**, файлы, указанные в **package\_data**, не будут автоматически добавляться в манифест, если они не указаны в файле `MANIFEST.in`.
{% endhint %}

Иногда одних параметров **include\_package\_data** или **package\_data** недостаточно, чтобы точно определить, какие файлы вы хотите включить. Например, вы можете захотеть включить файлы пакета **README** в вашу систему контроля версий и исходные версии, но исключить их из установки. Итак, **setuptools** также предлагает параметр **exclude\_package\_data**, который позволяет вам делать такие вещи, как это:

```python
from setuptools import setup, find_packages
setup(
    ...
    packages=find_packages("src"),  # включить все пакеты в src
    package_dir={"": "src"},   # сказать, что пакеты distutils находятся под src

    include_package_data=True,    # включить все в систему контроля версий

    # ...но исключить README.txt из всех пакетов
    exclude_package_data={"": ["README.txt"]},
)
```

Параметр **exclude\_package\_data** - это словарь, отображающий имена пакетов в списки шаблонов подстановочных знаков, как и параметр **package\_data**. И, как и в случае с этой опцией, ключ `""` применит данный шаблон(ы) ко всем пакетам. Однако любые файлы, соответствующие этим шаблонам, будут **исключены** из установки, даже если они были перечислены в **package\_data** или были включены в результате использования **include\_package\_data**.

Таким образом, три варианта позволяют:

* &#x20;**include\_package\_data** - Принять все файлы данных и каталоги, соответствующие `MANIFEST.in`.
* &#x20;**package\_data** - Уточнить дополнительные шаблоны для сопоставления файлов, которые могут или не могут совпадать с `MANIFEST.in` или найдены в системе контроля версий.
* &#x20;**exclude\_package\_data** - Указать шаблоны для файлов данных и каталогов, которые **не должны** включаться при установке пакета, даже если в противном случае они были бы включены из-за использования предыдущих параметров.

{% hint style="info" %}
**ПРИМЕЧАНИЕ:**

Из-за того, как работает процесс сборки **distutils**, файл данных, который вы включаете в свой проект, а затем прекращаете включать, может оказаться «осиротевшим» в каталогах сборки вашего проекта, и вам потребуется запустить `setup.py clean --all`, чтобы полностью удалить их. Это также может быть важно для ваших пользователей и участников, если они отслеживают промежуточные версии вашего проекта с помощью **Subversion**; обязательно сообщите им, когда вы вносите изменения, исключающие включение файлов, чтобы они могли запустить `setup.py clean --all`.
{% endhint %}

### Доступ к файлам данных во время выполнения

Обычно существующие программы манипулируют атрибутом `__file__` пакета, чтобы найти расположение файлов данных. Однако эта манипуляция несовместима с обработчиками импорта на основе **PEP 302**, включая импорт из zip-файлов и Eggs Python. Если вы используете файлы данных, настоятельно рекомендуется использовать [ResourceManager API](../obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#resourcemanager-api) из **pkg\_resources** для доступа к ним. Модуль **pkg\_resources** распространяется как часть **setuptools**, поэтому, если вы используете **setuptools** для распространения своего пакета, нет причин не использовать его API управления ресурсами. См. также [ресурсы importlib](https://docs.python.org/3/library/importlib.html#module-importlib.resources) для быстрого примера преобразования кода, который использует `__file__` для использования вместо этого **pkg\_resources**.

### Файлы данных без пакета

Исторически сложилось так, что инструменты установки с помощью **easy\_install** инкапсулируют файлы данных из дистрибутива в **egg** (см. [старую документацию](https://github.com/pypa/setuptools/blob/52aacd5b276fedd6849c3a648a0014f5da563e93/docs/setuptools.txt#L970-L1001)). Поскольку **egg** устарели, а установка на основе **pip** откатывается в зависящее от платформы расположение для установки файлов данных, не существует поддерживаемого средства для надежного извлечения этих ресурсов.

Вместо этого **PyPA** рекомендует включать в пакет любые файлы данных, которые должны быть доступны во время выполнения.
