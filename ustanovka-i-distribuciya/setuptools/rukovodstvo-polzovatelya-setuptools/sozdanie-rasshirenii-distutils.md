# Создание расширений distutils

## Создание расширений distutils

Может быть сложно добавить новые команды или настроить аргументы в **distutils**. Но пакет **setuptools** делает это немного проще, позволяя распространять расширение **distutils** как отдельный проект, а затем иметь проекты, которым требуется расширение, просто ссылаясь на него в аргументе **setup\_requires**.

С помощью **setuptools** ваши проекты расширения **distutils** могут подключать новые команды и аргументы `setup ()`, просто определяя «точки входа». Это сопоставления имен команд или аргументов со спецификацией того, откуда импортировать обработчик. (Дополнительную информацию о точках входа см. в разделе «[Поведение рекламы](tochki-vkhoda.md#reklamnoe-povedenie)» выше.)

### Добавление команд

Вы можете добавлять новые команды настройки, определяя точки входа в группе `distutils.commands`. Например, если вы хотите добавить команду **foo**, вы можете добавить что-то вроде этого в сценарий установки вашего проекта расширения **distutils**:

```python
setup(
    # ...
    entry_points={
        "distutils.commands": [
            "foo = mypackage.some_module:foo",
        ],
    },
)
```

(При условии, конечно, что класс **foo** в `mypackage.some_module` является подклассом `setuptools.Command`)

После того, как проект, содержащий такие точки входа, был активирован в `sys.path` (например, запустив «install» или «develop» с установочным каталогом `site-packages`), команды будут доступны для любых сценариев установки на основе **setuptools**. Нет необходимости использовать опцию `--command-packages` или `monkeypatch` для пакета `distutils.command` для установки ваших команд; **setuptools** автоматически добавляет оболочку к **distutils** для поиска точек входа в активных дистрибутивах на `sys.path`. Фактически, именно так устанавливаются собственные команды **setuptools**: сценарий установки проекта **setuptools** определяет для них точки входа!

### Добавление аргументов setup ()

{% hint style="danger" %}
**ПРЕДУПРЕЖДЕНИЕ:**

Не рекомендуется добавлять аргументы в настройку, поскольку такие аргументы поддерживаются только при императивном выполнении и не поддерживаются в декларативной конфигурации.
{% endhint %}

Иногда вашим командам могут потребоваться дополнительные аргументы для вызова `setup ()`. Вы можете включить это, определив точки входа в группе `distutils.setup_keywords`. Например, если вам нужен аргумент `setup ()` с именем **bar\_baz**, вы можете добавить что-то вроде этого в сценарий установки вашего проекта расширения **distutils**:

```python
setup(
    # ...
    entry_points={
        "distutils.commands": [
            "foo = mypackage.some_module:foo",
        ],
        "distutils.setup_keywords": [
            "bar_baz = mypackage.some_module:validate_bar_baz",
        ],
    },
)
```

Идея здесь в том, что точка входа определяет функцию, которая будет вызываться для проверки аргумента `setup ()`, если он указан. Объект **Distribution** будет иметь начальное значение атрибута, установленное на `None`, и функция проверки будет вызываться только в том случае, если вызов `setup ()` устанавливает для него значение, отличное от `None`. Вот пример функции проверки:

```python
def assert_bool(dist, attr, value):
    """Verify that value is True, False, 0, or 1"""
    if bool(value) != value:
        raise DistutilsSetupError(
            "%r must be a boolean value (got %r)" % (attr,value)
        )
```

Ваша функция должна принимать три аргумента: объект распределения, имя атрибута и значение атрибута. Он должен вызвать **DistutilsSetupError** (из модуля `distutils.errors`), если аргумент недопустим. Помните, ваша функция будет вызываться только с значениями, отличными от `None`, а значение по умолчанию для аргументов, определенных таким образом, всегда равно `None`. Итак, ваши команды всегда должны быть готовы к тому, что атрибут будет `None`, когда они обратятся к нему позже.

Если более одного активного распределения определяют точку входа для одного и того же аргумента `setup ()`, **все** они будут вызваны. Это позволяет нескольким расширениям **distutils** определять общий аргумент, если они согласны с тем, какие значения этого аргумента допустимы.

Также обратите внимание, что, как и в случае с командами, нет необходимости создавать подкласс или `monkeypatch` для класса **distutils** `Distribution`, чтобы добавить свои аргументы; достаточно определить точки входа в вашем расширении, если любой сценарий установки, использующий ваше расширение, перечисляет ваш проект в своем аргументе `setup_requires`.

### Настройка параметров распространения

Плагины могут захотеть расширить или изменить параметры объекта распространения в соответствии с целями этого проекта. Например, инструменту, который определяет версию `Distribution.version` из метаданных **SCM**, может потребоваться подключиться к финализации параметра. Чтобы включить эту функцию, **setuptools** предлагает точку входа `«setuptools.finalize_distribution_options»`. Эта точка входа должна быть вызываемой, принимающей один аргумент (экземпляр **Distribution**).

Если вызываемый объект имеет свойство `.order`, это значение будет использоваться для определения порядка, в котором вызывается ловушка. Сначала вызываются более низкие числа, по умолчанию - ноль (`0`).

Плагины могут читать, изменять и устанавливать свойства в дистрибутиве, но каждому плагину рекомендуется загружать конфигурацию/настройки своего поведения независимо.

### Добавление новых файлов EGG-INFO

Некоторым расширяемым приложениям или фреймворкам может потребоваться разрешить третьим сторонам разрабатывать плагины с метаданными для конкретного приложения или фреймворка, включенными в каталог **EGG-INFO** плагинов, для легкого доступа через API метаданных **pkg\_resources**. Самый простой способ разрешить это - создать расширение **distutils**, которое будет использоваться из сценариев установки проектов плагинов (через **setup\_requires**), которые определяют новое ключевое слово установки, а затем используют эти данные для записи файла **EGG-INFO**, когда команда **egg\_info** запускается.

Команда **egg\_info** ищет точки расширения в группе `egg_info.writers` и вызывает их для записи файлов. Вот простой пример расширения **distutils**, определяющего аргумент настройки **foo\_bar**, который представляет собой список строк, которые будут записаны в `foo_bar.txt` в каталоге **EGG-INFO** любого проекта, который использует этот аргумент:

```python
setup(
    # ...
    entry_points={
        "distutils.setup_keywords": [
            "foo_bar = setuptools.dist:assert_string_list",
        ],
        "egg_info.writers": [
            "foo_bar.txt = setuptools.command.egg_info:write_arg",
        ],
    },
)
```

В этом простом примере используются две служебные функции, определенные с помощью **setuptools** для собственного использования: процедура для проверки того, что ключевое слово настройки является последовательностью строк, и еще одна, которая ищет аргумент настройки и записывает его в файл. Вот как выглядит утилита **writer**:

```python
def write_arg(cmd, basename, filename):
    argname = os.path.splitext(basename)[0]
    value = getattr(cmd.distribution, argname, None)
    if value is not None:
        value = "\n".join(value) + "\n"
    cmd.write_or_delete_file(argname, filename, value)
```

Как видите, точки входа `egg_info.writers` должны быть функцией, принимающей три аргумента: экземпляр команды **egg\_info**, базовое имя файла для записи (например, `foo_bar.txt`) и фактическое полное имя файла, в которое должно быть записано.

В общем, функции записи должны учитывать параметр `dry_run` командного объекта при записи файлов и использовать объект `distutils.log` для вывода любых данных в консоль. Самый простой способ выполнить это требование - использовать методы `write_file ()`, `delete_file ()` и `write_or_delete_file ()` объекта **cmd** исключительно для ваших файловых операций. Дополнительные сведения см. в документации к этим методам.

### Добавление поддержки систем контроля версий

Если файлы, которые вы хотите включить в исходный дистрибутив, отслеживаются с помощью Git, Mercurial или SVN, для этого можно использовать следующие пакеты:

* Git и Mercurial: [setuptools\_scm](https://pypi.org/project/setuptools-scm/)
* SVN: [setuptools\_svn](https://pypi.org/project/setuptools\_svn/)

Если вы хотите создать плагин для **setuptools** для поиска файлов, отслеживаемых другой системой контроля версий, вы можете сделать это, добавив точку входа в группу `setuptools.file_finders`. Точка входа должна быть функцией, принимающей одно имя каталога, и должна выдавать все имена файлов в этом каталоге (и любых его подкаталогах), которые находятся под контролем версий.

Например, если вы собирались создать плагин для системы контроля версий под названием «foobar», вы должны написать функцию примерно так:

```python
def find_files_for_foobar (dirname):
     # цикл для получения путей, начинающихся с `dirname`
```

И вы должны зарегистрировать его в сценарии установки, используя примерно следующее:

```bash
entry_points={
    "setuptools.file_finders": [
        "foobar = my_foobar_module:find_files_for_foobar",
    ]
}
```

Затем любой, кто хочет использовать ваш плагин, может просто установить его, и их локальная установка **setuptools** сможет найти необходимые файлы.

Нет необходимости распространять плагины управления версиями с проектами, которые просто используют другую систему управления версиями, или указывать плагины в **setup\_requires**. Когда вы создаете исходный дистрибутив с помощью команды **sdist**, **setuptools** автоматически записывает, какие файлы были найдены в файле `SOURCES.txt`. Таким образом, получатели исходных текстов вообще не нуждаются в управлении версиями. Однако, если кто-то работает над пакетом, проверяя эту систему, ему потребуются те же плагины, которые использует исходный автор.

Несколько важных моментов для написания средств поиска файлов для контроля версий:

* Ваша функция поиска ДОЛЖНА возвращать относительные пути, созданные путем добавления к переданному имени каталога. Абсолютные пути НЕ допускаются, как и относительные пути, которые ссылаются на родительский каталог переданного каталога.
* Ваша функция поиска ДОЛЖНА принимать в качестве имени каталога пустую строку, означающую текущий каталог. Вы НЕ ДОЛЖНЫ преобразовывать это в точку; просто укажите относительные пути. Таким образом, создание подкаталога с именем `some/dir` в текущем каталоге НЕ должно отображаться как `./some/dir` или `/where/some/dir`, а всегда просто как `some/dir`
* Ваша функция поиска НЕ ДОЛЖНА вызывать какие-либо ошибки и ДОЛЖНА изящно справляться с отсутствием необходимых программ (то есть программ, принадлежащих самой системе контроля версий. Однако она может использовать `distutils.log.warn ()`, чтобы информировать пользователя об отсутствующей программе(ах).
