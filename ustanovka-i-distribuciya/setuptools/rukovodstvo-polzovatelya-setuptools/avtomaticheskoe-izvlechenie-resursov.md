# Автоматическое извлечение ресурсов

## Автоматическое извлечение ресурсов

Если вы используете инструменты, которые ожидают, что ваши ресурсы будут «настоящими» файлами, или ваш проект включает собственные библиотеки, не являющиеся расширениями, или другие файлы, к которым ваши расширения C должны иметь доступ, вам может потребоваться перечислить эти файлы в аргументе **eager\_resources,** в `setup ()`, чтобы файлы извлекались вместе при каждом импорте расширения C в проект.

Это особенно важно, если ваш проект включает общие библиотеки, отличные от расширений C, созданных с помощью **distutils**, и эти общие библиотеки используют расширения файлов, отличные от `.dll`, `.so` или `.dylib`, которые являются расширениями, которые **setuptools** 0.6a8 и выше автоматически определяет как разделяемые библиотеки и добавляет за вас в файл `native_libs.txt`. Любые разделяемые библиотеки, имена которых не заканчиваются одним из этих расширений, должны быть указаны как **eager\_resources**, потому что они должны присутствовать в файловой системе, когда используются расширения C, которые ссылаются на них.

Среда выполнения **pkg\_resources** для сжатых пакетов будет автоматически извлекать все расширения C и **eager\_resources** в одно и то же время, когда любое расширение C или активный ресурс запрашивается через API `resource_filename ()`. (Расширения C импортируются с помощью внутреннего файла `resource_filename ()`.) Это гарантирует, что расширения C будут видеть все «настоящие» файлы, которые они ожидают увидеть.

Также обратите внимание, что вы также можете перечислить имена ресурсов каталога в **eager\_resources**, и в этом случае содержимое каталога (включая подкаталоги) будет извлекаться при каждом запросе любого расширения C или активного ресурса.

Учтите, что если вы не уверены, нужно ли вам использовать этот аргумент, то нет! Он действительно предназначен для поддержки проектов с большим количеством зависимостей, отличных от Python, и в качестве последнего средства для непонятных проектов, которые иначе не справятся со сжатием. Если ваш пакет представляет собой чистый Python, Python плюс файлы данных или Python плюс C, вам это действительно не нужно. Вы должны использовать либо C, либо внешнюю программу, которой требуются «настоящие» файлы в вашем проекте, прежде чем возникнет вероятность того, что **eager\_resources** будет иметь отношение к вашему проекту.

## Определение дополнительных метаданных

Некоторым расширяемым приложениям и фреймворкам может потребоваться определить свои собственные виды метаданных для включения в **eggs**, к которым они могут затем получить доступ с помощью API метаданных **pkg\_resources**. Обычно для этого разработчики подключаемых модулей включают дополнительные файлы в свой каталог `ProjectName.egg-info`. Однако, поскольку создание таких файлов вручную может быть утомительным, вы можете создать расширение **distutils**, которое будет создавать необходимые файлы из аргументов в `setup ()`, почти так же, как **setuptools** для многих из `setup ()` аргументы он добавляет. См. ниже раздел «[Создание расширений distutils](sozdanie-rasshirenii-distutils.md#sozdanie-rasshirenii-distutils)» для получения более подробной информации, особенно подраздел «[Добавление новых файлов EGG-INFO](sozdanie-rasshirenii-distutils.md#dobavlenie-novykh-failov-egg-info)».

## Установка флага zip\_safe

В некоторых случаях использования (например, в комплекте как часть более крупного приложения) пакеты Python могут запускаться непосредственно из zip-файла. Однако не все пакеты могут работать в сжатом виде, поскольку они могут рассчитывать на доступ к исходному коду или файлам данных как к обычным файлам операционной системы. Итак, **setuptools** может установить ваш проект как zip-файл или каталог, и его выбор по умолчанию определяется флагом проекта **zip\_safe**.

Вы можете передать значение `True` или `False` для аргумента **zip\_safe** функции `setup ()` или опустить его. Если вы его опустите, команда **bdist\_egg** проанализирует содержимое вашего проекта, чтобы увидеть, сможет ли он обнаружить какие-либо условия, которые могут помешать его работе с zip-файлом. Он будет выводить на консоль уведомления о любых обнаруженных условиях.

В настоящее время этот анализ крайне консервативен: он сочтет проект небезопасным, если он содержит какие-либо расширения C или файлы данных вообще. Это не значит, что проект не может или не будет работать как zip-файл! Это просто означает, что авторы **bdist\_egg** еще не уверены в том, что проект будет работать. Если проект не содержит C или файлов данных, а также не выполняет интроспекцию `__file__` или `__path__` или манипуляции с исходным кодом, то есть очень большая вероятность, что проект будет работать при установке в виде zip-файла. (И если проект использует **pkg\_resources** для всего доступа к файлам данных, то расширения C и другие файлы данных не должны быть проблемой. Для получения дополнительной информации см. раздел [Доступ к файлам данных во время выполнения](podderzhka-failov-dannykh.md#dostup-k-failam-dannykh-vo-vremya-vypolneniya) выше.)

Однако, если **bdist\_egg** не может быть уверен, что ваш пакет будет работать, но вы проверили все выданные им предупреждения и либо удовлетворены, что он будет работать (или если вы хотите попробовать его самостоятельно), тогда вам следует установите **zip\_safe** в `True` в вызове `setup ()`. Если окажется, что это не работает, вы всегда можете изменить его на `False`, что заставит **setuptools** установить ваш проект как каталог, а не как zip-файл.

В будущем, по мере того, как мы приобретем больше опыта работы с различными пакетами и будем более удовлетворены надежностью среды выполнения **pkg\_resources**, анализ «безопасности zip-архива» может стать менее консервативным. Тем не менее, мы настоятельно рекомендуем вам определить для себя, правильно ли работает ваш проект при установке в виде zip-файла, исправить любые проблемы, если вы можете, а затем сделать явное объявление `True` или `False` для флага **zip\_safe**, чтобы в этом не было необходимости, для **bdist\_egg**, чтобы попытаться угадать, может ли ваш проект работать как zip-файл.
