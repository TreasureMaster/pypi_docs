# Справка по командам setuptools

## Справка по командам

### alias - определяет ярлыки для часто используемых команд

Иногда вам нужно использовать одни и те же команды снова и снова, но вы не можете установить их по умолчанию. Например, если вы создаете и выпуски моментальных снимков для разработки, и «стабильные» выпуски проекта, вы можете захотеть разместить дистрибутивы в разных местах или использовать разные параметры тегов **egg\_info** и т. д. В этих случаях нет смысла устанавливать параметры в файле конфигурации **distutils**, потому что значения параметров меняются в зависимости от того, что вы пытаетесь сделать.

Таким образом, **setuptools** позволяет вам определять «псевдонимы» - имена ярлыков для произвольной строки команд и параметров, используя `setup.py alias aliasname expansion`, где **aliasname** - это имя нового псевдонима, а оставшаяся часть командной строки предоставляет его расширение. Например, эта команда определяет псевдоним «daily» для всего сайта, который устанавливает различные параметры тегов **egg\_info**:

```bash
setup.py alias --global-config daily egg_info --tag-build=development
```

После определения псевдонима его можно использовать с другими командами настройки, например:

```bash
setup.py daily bdist_egg        # создать файл .egg для ежедневной сборки
setup.py daily sdist            # создать дистрибутив с исходным кодом для ежедневной сборки
setup.py daily sdist bdist_egg  # генерировать оба
```

Вышеупомянутые команды интерпретируются так, как если бы слово **daily** было заменено на `egg_info --tag-build=development`.

Обратите внимание, что **setuptools** будет раскрывать каждый псевдоним не более одного раза в данной командной строке. Это служит двум целям. Во-первых, если вы случайно создадите цикл псевдонимов, это не повлияет; вместо этого вы получите сообщение об ошибке о неизвестной команде. Во-вторых, он позволяет вам определить псевдоним для команды, которая использует эту команду. Например, этот (локальный для проекта) псевдоним:

```bash
setup.py alias bdist_egg bdist_egg rotate -k1 -m.egg
```

переопределяет команду **bdist\_egg** таким образом, чтобы она всегда после этого всегда запускала команду **rotate**, чтобы удалить все, кроме самого нового файла **egg**. Он не выполняет бесконечный цикл для **bdist\_egg**, потому что псевдоним раскрывается только один раз при использовании.

Вы можете удалить определенный псевдоним с помощью параметра `--remove` (или `-r`), например:

```bash
setup.py alias --global-config --remove daily
```

удалит указанный выше псевдоним «daily».

Псевдонимы могут быть определены для конкретного проекта, для каждого пользователя или сайта. По умолчанию определяется или удаляется псевдоним для конкретного проекта, но вы можете использовать любую из [опций файла конфигурации](spravka-po-komandam-setuptools.md#parametry-faila-konfiguracii) (перечисленных ниже под командой [**saveopts**](spravka-po-komandam-setuptools.md#saveopts-sokhranyaet-ispolzovannye-parametry-v-fail-konfiguracii)), чтобы определить, в какой файл конфигурации **distutils** будут добавлены (или удалены) псевдонимы.

Обратите внимание: если вы опустите аргумент «**expansion**» в команде **alias**, вы получите вывод, показывающий текущее определение этого псевдонима (и в каком файле конфигурации он определен). Если вы также опустите имя псевдонима, вы получите список всех текущих псевдонимов с указанием расположения их файлов конфигурации.

### bdist\_egg - создает Python Egg для проекта

{% hint style="danger" %}
**ПРЕДУПРЕЖДЕНИЕ:**

**eggs** устарели в пользу **wheels** и не поддерживаются **pip**.
{% endhint %}

Эта команда создает для проекта **Python Egg** (файл `.egg`). **Python Eggs** являются предпочтительным двоичным форматом распространения для **EasyInstall**, поскольку они кроссплатформенны (для «чистых» пакетов), напрямую импортируются и содержат метаданные проекта, включая сценарии и информацию о зависимостях проекта. Их можно просто загрузить и добавить в `sys.path` напрямую, или их можно поместить в каталог на `sys.path` и затем автоматически обнаружить системой среды выполнения **egg**.

Эта команда запускает команду [**egg\_info**](spravka-po-komandam-setuptools.md#egg\_info-sozdaet-metadannye-egg-i-ustanavlivaet-tegi-sborki) (если она еще не запущена) для обновления каталога метаданных проекта (`.egg-info`). Если вы добавили какие-либо дополнительные файлы метаданных в каталог `.egg-info`, эти файлы будут включены в каталог метаданных нового файла **egg** для использования системой выполнения **egg** или любыми приложениями или фреймворками, которые используют эти метаданные.

Обычно вам не нужно указывать какие-либо специальные параметры для этой команды; просто используйте **bdist\_egg**, и все готово. Но есть несколько вариантов, которые иногда могут оказаться полезными:

#### --dist-dir=DIR, -d DIR

Установите каталог, в который будет помещен файл `.egg`. Если вы этого не укажете, то будет использоваться параметр `--dist-dir` команды **bdist**, который обычно представляет собой каталог с именем **dist** в каталоге проекта.

#### --plat-name=PLATFORM, -p PLATFORM

Задайте строку имени платформы, которая будет встроена в имя файла **egg** (при условии, что **egg** содержит расширения C). Это можно использовать для замены имени платформы по умолчанию **distutils** чем-нибудь более значимым. Однако имейте в виду, что система среды выполнения **egg** ожидает увидеть **eggs** с именами платформ **distutils**, поэтому она может игнорировать или отклонять **eggs** с нестандартными именами платформ. Точно так же программа **EasyInstall** может игнорировать их при поиске на веб-страницах ссылок для загрузки. Однако, если вы выполняете кросс-компиляцию или делаете другие необычные вещи, вы можете найти применение этой опции.

#### &#x20;--exclude-source-files

Не включайте в **egg** файлы `.py` каких-либо модулей, только скомпилированные файлы Python, C и данных. (Обратите внимание, что это не влияет на какие-либо файлы `.py` в каталоге **EGG-INFO** или его подкаталогах, поскольку, например, могут быть сценарии с расширением `.py`, которые все еще необходимо сохранить.) Мы не рекомендуем вам использовать это вариант, за исключением пакетов, которые объединяются для проприетарных приложений конечных пользователей, или для «встроенных» сценариев, где пространство является абсолютным преимуществом. С другой стороны, если ваш пакет будет установлен и использоваться в сжатом виде, вы также можете исключить источник, потому что модуль трассировки Python в настоящее время не понимает, как отображать заархивированный исходный код или как работать с файлами, которые находятся не в том месте, где был скомпилирован их код.

Есть также некоторые параметры, которые вам, вероятно, никогда не понадобятся, но они есть потому, что они были скопированы из аналогичных команд **bdist**, использованных в качестве примера для создания этой. Однако они могут быть полезны для тестирования и отладки, поэтому мы сохранили их:

#### --keep-temp, -k

Сохраните содержимое дерева `--bdist-dir` после создания файла `.egg`.

#### --bdist-dir=DIR, -b DIR

Установите временный каталог для создания дистрибутива. Все содержимое этого каталога заархивировано для создания файла `.egg` после выполнения различных команд установки для копирования сюда модулей, данных и расширений пакета.

#### &#x20;--skip-build

Пропустите выполнение любых команд «build»; просто переходите сразу к этапам установки и сжатия.

### develop - разворачивает исходный код проекта в «Режиме разработки»

Эта команда позволяет развернуть исходный код вашего проекта для использования в одной или нескольких «промежуточных областях», где он будет доступен для импорта. Это развертывание выполняется таким образом, что изменения в источнике проекта немедленно становятся доступными в промежуточных областях, без необходимости запускать этап сборки или установки после каждого изменения.

Команда **develop** работает путем создания файла `.egg-link` (названного в честь проекта) в указанной промежуточной области. Если промежуточной областью является каталог `site-packages` Python, он также обновляет файл `easy-install.pth`, чтобы проект по умолчанию находился в `sys.path` для всех программ, запускаемых с помощью этой установки Python.

Команда **develop** также устанавливает сценарии оболочки в промежуточную область (или в отдельный каталог, как указано), что обеспечивает доступность зависимостей проекта в `sys.path` перед запуском исходных сценариев проекта. И он гарантирует, что любые недостающие зависимости проекта доступны в промежуточной области, загружая и устанавливая их при необходимости.

И последнее, но не менее важное: команда **develop** вызывает команду `build_ext -i`, чтобы убедиться, что все расширения C в проекте были созданы и актуальны, и команду `egg_info`, чтобы гарантировать обновление метаданных проекта (чтобы среда выполнения и обертки знают, каковы зависимости проекта). Если вы вносите какие-либо изменения в сценарий установки проекта или расширения C, вам следует повторно запустить команду разработки для всех соответствующих промежуточных областей, чтобы сценарии, метаданные и расширения проекта были в актуальном состоянии. Большинство других видов изменений в вашем проекте не должны требовать каких-либо операций сборки или повторного запуска разработки, но имейте в виду, что даже незначительные изменения в сценарии установки (например, изменение определения точки входа) требуют повторного запуска команд **develop** или **test**, чтобы держать дистрибутив в актуальном состоянии.

Вот некоторые из вариантов, которые принимает команда **develop**. Обратите внимание, что они влияют на зависимости проекта, а также на сам проект, поэтому, если у вас есть зависимости, которые необходимо установить, и вы используете `--exclude-scripts` (например), скрипты зависимостей также не будут установлены! По этой причине вы можете использовать **pip** для установки зависимостей проекта перед использованием команды **develop**, если вам нужен более точный контроль над параметрами установки для зависимостей.

#### --uninstall, -u

Отменить развертывание текущего проекта. Вы можете использовать параметр `--install-dir` или `-d`, чтобы указать промежуточную область. Созданный файл `.egg-link` будет удален, если он есть, и он все еще указывает на каталог проекта. Каталог проекта будет удален из `easy-install.pth`, если промежуточной областью является каталог Python `site-packages`.

Обратите внимание, что эта опция в настоящее время не удаляет оболочки сценариев! Вы должны удалить их самостоятельно или перезаписать с помощью **pip** для установки другой версии пакета. Вы также можете вообще не устанавливать оболочки сценариев, если используете параметр `--exclude-scripts` (он же `-x`) при запуске разработки для развертывания проекта.

#### --multi-version, -m

«Многоверсионный» режим. Указание этого параметра предотвращает добавление в **develop** записи `easy-install.pth` для развертываемых проектов, и если запись для любой версии проекта уже существует, запись будет удалена после успешного развертывания. В многоверсионном режиме для импорта недоступна конкретная версия пакета, если только вы не используете `pkg_resources.require ()`, чтобы поместить ее в `sys.path`, или если вы не запускаете сценарий оболочки, созданный с помощью **setuptools**. (В этом случае сценарий оболочки вызывает для вас `require ()`.)

Обратите внимание, что если вы устанавливаете в каталог, отличный от `site-packages`, эта опция автоматически действует, поскольку файлы `.pth` могут использоваться только в пакетах сайтов (по крайней мере, в Python 2.3 и 2.4). Итак, если вы используете параметр `--install-dir` или `-d` (или они задаются через файл(ы) конфигурации), ваш проект и его зависимости будут развернуты в многоверсионном режиме.

#### --install-dir=DIR, -d DIR

Задайте каталог установки (промежуточную область). Если эта опция не указана напрямую в командной строке или в файле конфигурации **distutils**, используется место установки **distutils** по умолчанию. Обычно это каталог `site-packages`, но если вы используете файлы конфигурации **distutils**, устанавливая такие вещи, как **prefix** или **install\_lib**, то эти настройки учитываются при вычислении промежуточной области по умолчанию.

#### --script-dir=DIR, -s DIR

Задайте каталог установки скрипта. Если вы не указали эту опцию (через командную строку или файл конфигурации), но указали `--install-dir` (через командную строку или файл конфигурации), то эта опция по умолчанию используется в том же каталоге, поэтому сценарии смогут найти установку связанного с ними пакета. В противном случае этот параметр по умолчанию соответствует местоположению, в которое **distutils** обычно устанавливает сценарии, с учетом любых параметров файла конфигурации **distutils**.

#### --exclude-scripts, -x

Не развертывайте оболочки скриптов. Это полезно, если вы не хотите нарушать существующие версии скриптов в промежуточной области.

#### --always-copy, -a

Скопируйте все необходимые дистрибутивы в промежуточную область, даже если они уже находятся в другом каталоге в `sys.path`. По умолчанию, если требование может быть выполнено с использованием дистрибутива, который уже доступен в каталоге на `sys.path`, он не будет скопирован в промежуточную область.

#### &#x20;--egg-path=DIR

Заставить сгенерированный файл `.egg-link` использовать указанный относительный путь к исходному каталогу. Это может быть полезно в обстоятельствах, когда ваш установочный каталог совместно используется кодом, работающим на нескольких платформах (например, Mac и Windows), которые имеют разные абсолютные местоположения для разрабатываемого кода, но те же относительные местоположения относительно каталога установки. Если вы используете эту опцию при установке, вы должны указать тот же относительный путь при деинсталляции.

В дополнение к указанным выше параметрам команда **develop** также принимает все параметры, принятые **easy\_install**. Если вы настроили какие-либо параметры **easy\_install** в файле `setup.cfg` (или других файлах конфигурации **distutils**), команда **develop** будет использовать их по умолчанию, если вы не переопределите их в разделе `[develop]` или в командной строке.

### egg\_info - создает метаданные egg и устанавливает теги сборки

Эта команда выполняет две операции: обновляет каталог метаданных проекта `.egg-info` (используется командами **bdist\_egg**, **develop** и **test**) и позволяет временно изменить строку версии проекта для поддержки релизов «ежедневных сборок» или «моментальных снимков». Он запускается автоматически командами **sdist**, **bdist\_egg**, **develop** и **test** для обновления метаданных проекта, но вы также можете указать его явно, чтобы временно изменить строку версии проекта при выполнении других команд. (Он также создает файл манифеста `.egg-info/SOURCES.txt`, который используется при создании исходных дистрибутивов.)

В дополнение к записи основных метаданных **egg**, определенных **setuptools** и требуемых **pkg\_resources**, эту команду можно расширить для записи других файлов метаданных, определив точки входа в группе `egg_info.writers`. Более подробную информацию см. в разделе «[Добавление новых файлов EGG-INFO](sozdanie-rasshirenii-distutils.md#dobavlenie-novykh-failov-egg-info)» выше. Обратите внимание, что использование дополнительных средств записи метаданных может потребовать от вас включения аргумента **setup\_requires** в `setup ()`, чтобы гарантировать, что нужные средства записи доступны в `sys.path`.

### Параметры маркировки выпуска

Следующие параметры можно использовать для изменения строки версии проекта для всех оставшихся команд в командной строке установки. Параметры обрабатываются в указанном порядке, поэтому, если вы используете более одного, запрошенные теги будут добавлены в следующем порядке:

#### --tag-build=NAME, -b NAME

Добавляет NAME в строку версии проекта. Из-за того, как **setuptools** обрабатывает суффиксы «pre-release» версий, начинающиеся с букв от «а» до «е» (например, «alpha», «beta» и «candidate»), вы обычно захотите использовать такой тег, как «`.build`»или«`.dev`», так как это приведет к тому, что номер версии будет считаться ниже, чем версия проекта по умолчанию. (Если вы хотите, чтобы номер версии был выше, чем версия по умолчанию, вы всегда можете не указывать `–-tag-build`, а затем использовать один или оба следующих параметра.)

Если в вашем `setup.cfg` установлен тег сборки по умолчанию, вы можете подавить его в командной строке, используя `-b ""` или `--tag-build = ""` в качестве аргумента команды **egg\_info**.

#### --tag-date, -d

Добавляет отметку даты в форме «-ГГГГММДД» (например, «-20050528») к номеру версии проекта.

#### --no-date, -D

Не вставляет дату в номере версии. Эта опция включена, поэтому вы можете изменить значение по умолчанию в `setup.cfg`.

{% hint style="info" %}
**ЗАМЕЧАНИЕ:**

Поскольку эти параметры изменяют номер версии, используемый для исходных и двоичных дистрибутивов вашего проекта, вы должны сначала убедиться, что вы знаете, как полученные номера версий будут интерпретироваться автоматическими инструментами, такими как **pip**. См. раздел «[Указание версии вашего проекта](pometka-i-vypuski-daily-build-ili-snapshot.md#ukazanie-versii-vashego-proekta)» выше, чтобы узнать о тегах до и после выпуска, а также узнать, как выбрать и проверить схему управления версиями для вашего проекта.
{% endhint %}

Для расширенного использования есть еще один параметр, который можно настроить, чтобы изменить расположение каталога проекта `.egg-info`. Команды, которым необходимо найти исходный каталог или метаданные проекта, должны получить их из этого параметра:

### Другие параметры egg\_info

#### --egg-base=SOURCEDIR, -e SOURCEDIR

Указывает каталог, который должен содержать каталог `.egg-info`. Обычно это должен быть корень исходного дерева вашего проекта (который не обязательно совпадает с каталогом вашего проекта; некоторые проекты используют подкаталог **src** или **lib** в качестве корня исходного кода). Обычно вам не нужно указывать этот каталог, поскольку он обычно определяется аргументом **package\_dir** функции `setup ()`, если таковой имеется. Если **package\_dir** не задан, по умолчанию используется текущий каталог.

### Примеры egg\_info

Создание датированного **egg** моментального снимка «ночной сборки»:

```bash
setup.py egg_info --tag-date --tag-build=DEV bdist_egg
```

Создание выпуска без тегов версии, даже если некоторые теги по умолчанию указаны в `setup.cfg`:

```bash
setup.py egg_info -RDb "" sdist bdist_egg
```

{% hint style="info" %}
**ПРИМЕЧАНИЕ:**

Обратите внимание, что **egg\_info** всегда должен появляться в командной строке перед любыми командами, к которым вы хотите применить изменения версии.
{% endhint %}

### rotate - удаляет устаревшие файлы распространения

По мере того, как вы разрабатываете новые версии своего проекта, каталог вашего дистрибутива (**dist**) будет постепенно заполняться старыми исходными и/или двоичными файлами распространения. Команда **rotate** позволяет автоматически очищать их, оставляя только N последних измененных файлов, соответствующих заданному шаблону.

#### --match=PATTERNLIST, -m PATTERNLIST

Список шаблонов glob, разделенных запятыми. Эта опция **обязательна**. Имя проекта и `-*` добавляется к предоставленным шаблонам, чтобы соответствовать только дистрибутивам, принадлежащим текущему проекту (в случае, если у вас есть общий каталог распространения для нескольких проектов). Как правило, вы будете использовать шаблон glob, например `.zip` или `.egg`, для сопоставления файлов указанного типа. Обратите внимание, что каждый предоставленный шаблон рассматривается как отдельная группа файлов для целей выбора файлов для удаления.

#### --keep=COUNT, -k COUNT

Количество сохраняемых совпадающих распределений. Для каждой группы файлов, идентифицированной шаблоном, указанным с помощью опции `--match`, удалите все, кроме **COUNT** последних измененных файлов в этой группе. Эта опция **обязательна**.

#### --dist-dir=DIR, -d DIR

Каталог, в котором находятся дистрибутивы. По умолчанию используется значение параметра `--dist-dir` команды **bdist**, который обычно является подкаталогом **dist** проекта.

**Пример 1:** Удалите все файлы `.tar.gz` из каталога распространения, за исключением трех последних измененных:

```bash
setup.py rotate --match=.tar.gz --keep=3
```

**Пример 2:** Удалите все **egg** Python 2.3 или Python 2.4 из каталога распространения, за исключением последнего измененного для каждой версии Python:

```bash
setup.py rotate --match=-py2.3*.egg,-py2.4*.egg --keep=1
```

### saveopts - сохраняет использованные параметры в файл конфигурации

Поиск и редактирование файлов конфигурации **distutils** может быть проблемой, особенно потому, что вам также нужно перевести параметры конфигурации из формы командной строки в правильный формат файла конфигурации. Вы можете избежать этих неприятностей, используя команду **saveopts**. Просто добавьте его в командную строку, чтобы сохранить использованные вами параметры. Например, эта команда собирает проект с помощью компилятора **Mingw32** C, а затем сохраняет параметр `–compiler` по умолчанию для будущих сборок (даже тех, которые запускаются неявно командой `install`):

```bash
setup.py build --compiler=mingw32 saveopts
```

Команда **saveopts** сохраняет все параметры для каждой команды, указанной в командной строке, в локальном файле проекта `setup.cfg`, если только вы не используете один из [параметров файла конфигурации](spravka-po-komandam-setuptools.md#parametry-faila-konfiguracii), чтобы изменить место сохранения параметров. Например, эта команда делает то же самое, что и выше, но сохраняет настройку компилятора в конфигурации **distutils** для всего сайта (глобально):

```bash
setup.py build --compiler=mingw32 saveopts -g
```

Обратите внимание, что не имеет значения, где вы разместите команду **saveopts** в командной строке; он все равно сохранит все параметры, указанные для всех команд. Например, это еще один правильный способ написания последнего примера:

```bash
setup.py saveopts -g build --compiler=mingw32
```

Обратите внимание, однако, что все указанные команды всегда выполняются, независимо от того, где в командной строке размещены **saveopts**.

### Параметры файла конфигурации

Обычно такие настройки, как параметры и псевдонимы, сохраняются в локальном файле проекта `setup.cfg`. Но вы можете переопределить это и сохранить их в глобальных файлах или файлах конфигурации для каждого пользователя или в файле, указанном вручную.

#### --global-config, -g

Сохраняет настройки в глобальном файле `distutils.cfg` внутри каталога пакета **distutils**. Для использования этой опции у вас должны быть права записи в этот каталог. Вы также не можете комбинировать эту опцию с `-u` или `-f`.

#### --user-config, -u

Сохраняет настройки в файл `~/.pydistutils.cfg` (POSIX) или `$HOME/pydistutils.cfg` (Windows) текущего пользователя. Вы не можете комбинировать эту опцию с `-g` или `-f`.

#### --filename=FILENAME, -f FILENAME

Сохраняет настройки в указанный файл конфигурации для использования. Вы не можете комбинировать эту опцию с `-g` или `-u`. Учтите, что если вы укажете нестандартное имя файла, **distutils** и **setuptools** не будут использовать его содержимое. Эта опция в основном предназначена для использования при тестировании.

Эти параметры используются другими командами **setuptools**, которые изменяют файлы конфигурации, например командами [alias](spravka-po-komandam-setuptools.md#alias-opredelyaet-yarlyki-dlya-chasto-ispolzuemykh-komand) и [setopt](spravka-po-komandam-setuptools.md#setopt-ustanavlivaet-parametr-distutils-ili-setuptools-v-faile-konfiguracii).

### setopt - устанавливает параметр distutils или setuptools в файле конфигурации

Эта команда в основном предназначена для использования в сценариях, но ее также можно использовать как быстрый и грязный способ изменить параметр конфигурации **distutils** без необходимости запоминать, в каком файле находятся параметры, а затем открывать редактор.

**Пример 1.** Установите компилятор C по умолчанию на **mingw32** (используя длинные имена параметров):

```bash
setup.py setopt --command=build --option=compiler --set-value=mingw32
```

**Пример 2.** Удалите все настройки для каталога установки пакета **distutils** по умолчанию (короткие имена параметров):

```bash
setup.py setopt -c install -o install_lib -r
```

Параметры команды **setopt**:

#### --command=COMMAND, -c COMMAND

Команда, для которой нужно установить параметр. Эта опция **обязательна**.

#### --option=OPTION, -o OPTION

Имя настраиваемой опции. Эта опция **обязательна**.

#### --set-value=VALUE, -s VALUE

Значение, которое нужно установить для параметра. Не требуется, если установлено `-r` или `--remove`.

#### --remove, -r

Удаляет (отключает) параметр, а не устанавливает его.

В дополнение к указанным выше параметрам вы можете использовать любые [параметры файла конфигурации](spravka-po-komandam-setuptools.md#parametry-faila-konfiguracii) (перечисленные выше под командой [**saveopts**](spravka-po-komandam-setuptools.md#saveopts-sokhranyaet-ispolzovannye-parametry-v-fail-konfiguracii)), чтобы определить, в какой файл конфигурации **distutils** будет добавлен (или из которого удален) параметр.

### test - собирает пакет и запускает пакет unittest

{% hint style="danger" %}
**ПРЕДУПРЕЖДЕНИЕ:**

**test** устарел и будет удален в будущей версии. Пользователям, которые ищут общую точку входа в тест, не зависящую от средства запуска тестов, рекомендуется использовать [tox](https://tox.readthedocs.io/en/latest/).
{% endhint %}

При разработке на основе тестирования или запуске автоматизированных сборок, которые требуют тестирования перед развертыванием для загрузки или использования, часто бывает полезно иметь возможность запускать модульные тесты проекта без фактического развертывания проекта где-либо, даже с помощью команды разработки. Команда **test** запускает модульные тесты проекта без его фактического развертывания, временно помещая исходный код проекта в **sys.path** после первого запуска `build_ext -i` и `egg_info`, чтобы убедиться, что все расширения C и метаданные проекта актуальны.

Чтобы использовать эту команду, тесты вашего проекта должны быть заключены в набор тестов **unittest** либо функцией, либо классом или методом **TestCase**, либо модулем или пакетом, содержащим классы **TestCase**. Если названный набор является модулем, и у модуля есть функция `additional_tests ()`, он вызывается, и результат (который должен быть `unittest.TestSuite`) добавляется к тестам, которые нужно запустить. Если именованный набор является пакетом, любые подмодули и подпакеты рекурсивно добавляются в общий набор тестов.

{% hint style="info" %}
**ПРИМЕЧАНИЕ:**

если в вашем проекте указан **test\_loader**, правила обработки выбранного **test\_suite** могут отличаться; дополнительные сведения см. в [документации test\_loader](novye-i-izmenennye-klyuchevye-slova-setup.md#test\_loader).
{% endhint %}

Обратите внимание, что многие тестовые системы, включая **doctest**, поддерживают упаковку своих не-модульных тестов в объекты **TestSuite**. Итак, если вы используете тестовый пакет, который не поддерживает это, мы рекомендуем вам рекомендовать его разработчикам реализовать поддержку набора тестов, поскольку это удобный и стандартный способ агрегировать набор тестов, которые будут запускаться в общей тестовой системе.

По умолчанию тесты будут запускаться в «подробном» режиме средства запуска текстовых тестов пакета **unittest**, но вы можете получить «тихий» режим (только точки), если укажете опцию `-q` или `--quiet`, либо как глобальную параметр сценария установки (например, `setup.py -q test`) или как параметр самой команды тестирования (например, `setup.py test -q`). Доступен еще один вариант:

#### --test-suite=NAME, -s NAME

Указывает набор тестов (или модуль, класс или метод) для запуска (например, `some_module.test_suite`). Значение по умолчанию для этой опции можно установить, передав аргумент **test\_suite** функции `setup ()`, например:

```bash
setup(
    # ...
    test_suite="my_package.tests.test_all"
)
```

Если вы не установили **test\_suite** в вызове `setup ()` и не предоставили параметр `--test-suite`, произойдет ошибка.

_Новое в версии 41.5.0:_ исключена команда **test**.

### upload - загружает исходный код и/или распределения egg в PyPI

Команда загрузки устарела в версии 40.0 и была удалена в версии 42.0. Вместо этого используйте [twine](https://pypi.org/project/twine/) (**Twine** - это утилита для публикации пакетов Python на **PyPI**).

Дополнительные сведения о текущих передовых методах загрузки пакетов в **PyPI** см. в руководстве пользователя **Python Packaging User Guide** «Упаковка проектов Python», в частности в разделе о [загрузке архивов распространения](https://packaging.python.org/tutorials/packaging-projects/#uploading-the-distribution-archives).
