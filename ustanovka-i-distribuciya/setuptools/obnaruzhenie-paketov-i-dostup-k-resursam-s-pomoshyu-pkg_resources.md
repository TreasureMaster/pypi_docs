# Обнаружение пакетов и доступ к ресурсам с помощью pkg\_resources

Модуль **pkg\_resources**, распространяемый с **setuptools**, предоставляет API для библиотек Python для доступа к их файлам ресурсов, а также для расширяемых приложений и фреймворков для автоматического обнаружения подключаемых модулей. Он также обеспечивает поддержку во время выполнения для использования расширений C, находящихся внутри **eggs** в формате zip-файла, поддержку слияния пакетов, которые имеют отдельно распределенные модули или подпакеты, и API-интерфейсы для управления текущим «рабочим набором» активных пакетов Python.

## Обзор

Модуль **pkg\_resources** предоставляет средства времени выполнения для поиска, анализа, активации и использования установленных дистрибутивов Python. Некоторые из более продвинутых функций (в частности, поддержка параллельной установки нескольких версий) зависят конкретно от формата «**egg**» (в виде zip-архива или подкаталога), в то время как другие (например, обнаружение плагинов) будут работать правильно, пока «каталоги метаданных **egg-info**» доступны для соответствующих дистрибутивов.

**Eggs** - это формат распространения для модулей Python, аналогичный по концепции «**jars**» Java, «**gems**» Ruby или формату «**wheel**», определенному в **PEP 427**. Однако, в отличие от чистого формата распространения, **eggs** также можно устанавливать и добавлять напрямую в `sys.path` в качестве места для импорта. При такой установке **eggs** обнаруживаются, что означает, что они несут метаданные, которые однозначно идентифицируют их содержимое и зависимости. Это означает, что установленное **egg** может быть автоматически найдено и добавлено в `sys.path` в ответ на простой запрос формы: «Дайте мне все, что мне нужно, чтобы использовать поддержку PDF в документах». Эта функция позволяет взаимно конфликтующим версиям дистрибутива сосуществовать в одной установке Python, при этом отдельные приложения активируют желаемую версию во время выполнения, манипулируя содержимым `sys.path` (это отличается от подхода виртуальной среды, который включает создание изолированных сред для каждого приложения).

Следующие термины необходимы для объяснения возможностей, предлагаемых этим модулем:

* **project** - Библиотека, фреймворк, скрипт, плагин, приложение или набор данных или других ресурсов или их комбинация. Предполагается, что проекты имеют «относительно уникальные» имена, например имена, зарегистрированные в PyPI.
* **release** - Снимок проекта в определенный момент времени, обозначенный идентификатором версии.
* **distribution** - Файл или файлы, представляющие конкретный выпуск.
* **importable distribution** - Файл или каталог, который, если он помещен в `sys.path`, позволяет Python импортировать любые содержащиеся в нем модули.
* **pluggable distribution** - Импортируемый дистрибутив, имя файла которого однозначно определяет его выпуск (то есть проект и версию), а содержимое однозначно определяет, какие выпуски других проектов будут удовлетворять его требованиям времени выполнения.
* **extra** - это дополнительная функция выпуска, которая может налагать дополнительные требования к среде выполнения. Например, если для поддержки PDF-файлов в документах требуется наличие библиотеки поддержки PDF-файлов, в документе «docutils» можно определить свою поддержку PDF как «extra» и указать, какие другие выпуски проекта должны быть доступны для ее предоставления.
* **environment** - Коллекция дистрибутивов, потенциально доступных для импорта, но не обязательно активных. В среде может присутствовать более одного дистрибутива (т.е. выпускной версии) для данного проекта.
* **working set** - Коллекция дистрибутивов, фактически доступных для импорта, как в `sys.path`. В рабочем наборе может присутствовать не более одного дистрибутива (выпускной версии) данного проекта, иначе возникнет двусмысленность относительно того, что импортировать.
* eggs - это подключаемые дистрибутивы в одном из трех форматов, которые в настоящее время поддерживает **pkg\_resources**. Есть `built eggs`, `development eggs` и `eggs link`. **Built eggs** - это каталоги или zip-файлы, имена которых заканчиваются на `.egg` и соответствуют соглашениям об именах **egg**, и содержат подкаталог **EGG-INFO** (заархивированный или другой). **Development eggs** - это обычные каталоги кода Python с одним или несколькими подкаталогами `ProjectName.egg-info`. Формат **development eggs** также используется для предоставления версии дистрибутива по умолчанию, доступной для программного обеспечения, которое не использует **pkg\_resources** для запроса определенных версий. **Eggs link** - это файлы `*.egg-link`, которые содержат имя built или development egg, для поддержки символических ссылок на платформах, которые не имеют собственных символических ссылок (или где поддержка символических ссылок ограничена).

(Для получения дополнительной информации об этих терминах и концепциях см. также этот [архитектурный обзор](https://mail.python.org/pipermail/distutils-sig/2005-June/004652.html) **pkg\_resources** и Python Eggs в целом.)

## Справка по API

### Поддержка пакета пространства имен

Пакет пространства имен - это пакет, который содержит только другие пакеты и модули, без прямого собственного содержимого. Такие пакеты можно разделить на несколько раздельно упакованных дистрибутивов. Обычно они используются для разделения больших пакетов, созданных одной организацией, например, в пакете пространства имен **zope** для пакетов Zope Corporation и в пакете пространства имен **peak** для Python Enterprise Application Kit.

Чтобы создать пакет пространства имен, вы указываете его в аргументе **namespace\_packages** функции `setup ()` в файле `setup.py` вашего проекта. (дополнительную информацию см. в документации setuptools по [пакетам пространств имен](rukovodstvo-polzovatelya-setuptools/obnaruzhenie-paketov-i-paket-prostranstva-imen.md#ispolzovanie-find\_namespace-ili-find\_namespace\_packages).) Кроме того, вы должны добавить вызов `declare_namespace ()` в файл(ы) `__init__.py` пакета:

#### &#x20;declare\_namespace(name)

Объявляет, что имя пакета **name**, разделенное точками, является «пакетом пространства имен», пакеты и модули которого могут быть распределены по нескольким дистрибутивам. `__path__` указанного пакета будет расширен, чтобы включить соответствующий пакет во все дистрибутивы в `sys.path`, которые содержат пакет с таким именем. (Точнее, если `find_module(name)` импортера возвращает загрузчик, тогда он также будет искать содержимое пакета.) Каждый раз, когда вызывается метод `activate()` дистрибутива, он проверяет наличие пакетов пространства имен и обновляет их содержимое `__path__` соответственно.

Приложения, которые манипулируют пакетами пространства имен или напрямую изменяют `sys.path` во время выполнения, также могут нуждаться в использовании этой функции API:

#### &#x20;fixup\_namespace\_packages(path\_item)

Объявляет, что **path\_item** - это недавно добавленный элемент в `sys.path`, который, возможно, потребуется использовать для обновления существующих пакетов пространства имен. Обычно это вызывается для вас, когда **egg** автоматически добавляется в `sys.path`, но если ваше приложение изменяет `sys.path`, чтобы включить местоположения, которые могут содержать части пакета пространства имен, вам нужно будет вызвать эту функцию, чтобы убедиться, что они добавлены в существующие пакеты пространства имен.

Хотя по умолчанию **pkg\_resources** поддерживает только пакеты пространств имен для файловой системы и импортеров **zip**, вы можете расширить его поддержку на другие «импортеры», совместимые с **PEP 302**, используя функцию `register_namespace_handler ()`. Подробнее см. в разделе «[Поддержка пользовательских импортеров](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#podderzhka-polzovatelskikh-importerov)» ниже.

### Объекты WorkingSet

Класс **WorkingSet** обеспечивает доступ к коллекции «активных» дистрибутивов. В общем, есть только один значимый экземпляр **WorkingSet**: тот, который представляет дистрибутивы, которые в настоящее время активны в `sys.path`. Этот глобальный экземпляр доступен под именем **working\_set** в модуле **pkg\_resources**. Однако специализированные инструменты могут пожелать манипулировать рабочими наборами, которые не соответствуют `sys.path`, и поэтому могут пожелать создать другие экземпляры **WorkingSet**.

Важно отметить, что глобальный объект **working\_set** инициализируется из `sys.path` при первом импорте **pkg\_resources**, но обновляется только в том случае, если вы в будущем будете выполнять все манипуляции с `sys.path` через API **pkg\_resources**. Если вы вручную измените `sys.path`, вы должны вызвать соответствующие методы в экземпляре **working\_set**, чтобы синхронизировать его. К сожалению, Python не предоставляет никакого способа обнаруживать произвольные изменения объекта списка, такого как `sys.path`, поэтому **pkg\_resources** не может автоматически обновлять **working\_set** на основе изменений в `sys.path`.

#### &#x20;WorkingSet(entries=None)

* Создает **WorkingSet** из итерации записей пути. Если _**entries**_ не указаны, по умолчанию используется значение `sys.path` во время вызова конструктора.
* Обратите внимание, что вы обычно не создаете экземпляры **WorkingSet** самостоятельно, вместо этого вы будете неявно или явно использовать глобальный экземпляр **working\_set**. По большей части API **pkg\_resources** разработан таким образом, что **working\_set** используется по умолчанию, так что вам не нужно явно ссылаться на него большую часть времени.

Все дистрибутивы, доступные непосредственно в `sys.path`, будут автоматически активированы при импорте **pkg\_resources**. Такое поведение может вызвать конфликты версий для приложений, которым требуются версии этих дистрибутивов, отличные от стандартных. Чтобы справиться с этой ситуацией, **pkg\_resources** проверяет наличие атрибута **requires** в модуле `__main__` при инициализации рабочего набора по умолчанию и использует его для обеспечения активации подходящей версии каждого затронутого дистрибутива. Например:

```python
__requires__ = ["CherryPy < 3"] # Должен быть установлен перед импортом pkg_resources
import pkg_resources
```

#### Базовые методы WorkingSet

Следующие методы объектов **WorkingSet** также доступны как функции уровня модуля в **pkg\_resources**, которые применяются к экземпляру **working\_set** по умолчанию. Таким образом, вы можете использовать, например, `pkg_resources.require ()` как сокращение от `pkg_resources.working_set.require ()`:

* **require(\*requirements)** - Убедитесь, что дистрибутивы, соответствующие _**requirements**_, активированы. _**requirements**_ должны быть строкой или (возможно, вложенной) последовательностью, определяющей требуемые дистрибутивы и версии. Возвращаемое значение представляет собой последовательность распределений, которые необходимо активировать для выполнения требований; все соответствующие дистрибутивы включены, даже если они уже были активированы в этом рабочем наборе. Синтаксис спецификаторов требований см. в разделе «[Парсинг требований](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#parsing-trebovanii)» ниже. Как правило, нет необходимости вызывать этот метод напрямую. Он больше предназначен для использования в быстрых сценариях и взломе интерактивных интерпретаторов, чем для производственного использования. Если вы создаете настоящую библиотеку или приложение, настоятельно рекомендуется создать сценарий «`setup.py`» с помощью **setuptools** и объявить там все свои требования. Таким образом, такие инструменты, как **pip**, могут автоматически определять, какие требования предъявляются к вашему пакету, и соответственно обрабатывать их. Обратите внимание, что при вызове `require ('SomePackage')` **SomePackage** не устанавливается, если его еще нет. Если вам нужно это сделать, вы должны вместо этого использовать метод `resolve ()`, который позволяет передать обратный вызов установщика, который будет вызываться, когда необходимый дистрибутив не может быть найден на локальном компьютере. Затем вы можете заставить этот обратный вызов отображать диалоговое окно, автоматически загружать необходимый дистрибутив или что-то еще, подходящее для вашего приложения. См. документацию ниже по методу `resolve ()` для получения дополнительной информации, а также по методу `obtain ()` объектов **Environment**.
* **run\_script(requires, script\_name)** - Ищет дистрибутив, указанный в **Requirement**, и запускает его скрипт _**script\_name**_. _**requires**_ должна быть строкой, содержащей спецификатор требования. (См. синтаксис в разделе [Анализ требований](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#parsing-trebovanii) ниже.) Если сценарий найден, он будет выполнен в глобальных объектах вызывающего объекта. Это потому, что этот метод предназначен для вызова из сценариев оболочки, которые действуют как прокси для «реальных» сценариев в дистрибутиве. Сценарию-оболочке обычно не нужно ничего делать, кроме как вызывать эту функцию с правильными аргументами. Если вам нужен больший контроль над средой выполнения скрипта, вы, вероятно, захотите вместо этого использовать метод `run_script ()` [API метаданных](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#metadata-api) объекта **Distribution**.
* **iter\_entry\_points(group, name=None) -** Получает объекты точки входа из _**group**_, соответствующей _**name**_. Если _**name**_ равно `None`, выводятся все точки входа в группу из всех распределений в рабочем наборе, в противном случае возвращаются только те, которые соответствуют и _**group**_, и _**name**_. Точки входа выдаются из активных дистрибутивов в том порядке, в котором они появляются в рабочем наборе. (Для глобального **working\_set** это должно быть таким же, как порядок, в котором они перечислены в `sys.path`.) Обратите внимание, что внутри точек входа, объявленных отдельным дистрибутивом, нет определенного порядка. Дополнительную информацию см. в разделе «[Точки входа](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#tochki-vkhoda-entry-points)» ниже.

#### Методы и атрибуты WorkingSet

Эти методы используются для запроса или управления содержимым определенного рабочего набора, поэтому они должны быть явно вызваны в конкретном экземпляре **WorkingSet**:

* &#x20;**add\_entry(entry)** - Добавляет элемент пути к записям, найдя на нем какие-либо распределения. Вы должны использовать это, когда вы добавляете дополнительные элементы в `sys.path` и хотите, чтобы глобальный **working\_set** отражал это изменение. Этот метод также вызывается конструктором `WorkingSet ()` во время инициализации. Этот метод использует `find_distributions (entry, True)` для поиска дистрибутивов, соответствующих записи пути, а затем Добавляет `add()` их. _**entry**_ всегда добавляется к атрибуту **entries**, даже если она уже существует. (Это связано с тем, что `sys.path` может содержать одно и то же значение более одного раза, и атрибут **entries** должен отражать это.)
* &#x20;**\_\_contains\_\_(dist) -** `True`, если **dist** активен в этом **WorkingSet**. Обратите внимание, что только один дистрибутив для данного проекта может быть активен в данном **WorkingSet**.
* &#x20;**\_\_iter\_\_() -** Распределения дистрибутивов для неповторяющихся проектов в рабочем наборе. Порядок выхода - это порядок, в котором записи пути элементов были добавлены в рабочий набор.
* &#x20;**find(req) -** Ищет распределение, соответствующее _**req**_ (экземпляр **Requirement**). Если для запрошенного проекта существует активный дистрибутив, он будет возвращен, если он соответствует требованиям к версии, указанным в _**req**_. Но если для проекта есть активный дистрибутив, который не соответствует требованиям _**req**_, возникает **VersionConflict**. Если для запрошенного проекта нет активного дистрибутива, возвращается `None`.
* **resolve(requirements, env=None, installer=None) -** Список всех дистрибутивов, необходимых для (рекурсивного) соответствия _**requirements**_. _**requirements**_ должны быть последовательностью объектов **Requirement**. _**env**_, если он указан, должен быть экземпляром **Environment**. Если не указан, **Environment** создается из **entries** рабочего набора. _**installer**_, если он предоставлен, будет вызываться с каждым требованием, которое не может быть удовлетворено уже установленным дистрибутивом; он должен вернуть `Distribution` или `None`. (Для получения дополнительной информации об аргументе _**installer**_ см. метод `obtain()` [объекта Environment](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#obekty-environment) ниже.)
* **add(dist, entry=None) -** Добавляет _**dist**_ в рабочий набор, связанный с _**entry**_. Если _**entry**_ не указана, по умолчанию используется `dist.location`. При выходе из этой процедуры _**entry**_ добавляется в конец `.entries` рабочего набора (если ее еще не было). _**dist**_ добавляется в рабочий набор только в том случае, если он предназначен для проекта, в котором еще нет активного дистрибутива. Если он успешно добавлен, будут вызваны все обратные вызовы, зарегистрированные с помощью метода `subscribe ()`. (См. раздел [Получение уведомлений об изменениях](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#poluchenie-uvedomlenii-ob-izmeneniyakh) ниже.). _Примечание._ `add ()` автоматически вызывается методом `require ()`, поэтому обычно вам не нужно использовать этот метод напрямую.
* &#x20;**entries -** Этот атрибут представляет собой «тень» `sys.path`, в первую очередь полезную для отладки. Если у вас возникли проблемы с импортом, вам следует проверить записи глобального объекта **working\_set** по `sys.path`, чтобы убедиться, что они совпадают. Если это не так, значит, какая-то часть вашей программы манипулирует `sys.path` без соответствующего обновления **working\_set**. ВАЖНОЕ ПРИМЕЧАНИЕ: не манипулируйте этим атрибутом напрямую! Установка его равным `sys.path` не решит вашу проблему, так же как и наклеивание черной ленты на индикатор «engine warning» не исправит вашу машину! Если этот атрибут не синхронизирован с `sys.path`, это просто **индикатор** проблемы, а не ее причина.

#### Получение уведомлений об изменениях

Расширяемым приложениям и фреймворкам может потребоваться уведомление, когда новый дистрибутив (например, подключаемый компонент) был добавлен в рабочий набор. Для этого предназначены метод `subscribe ()` и функция `add_activation_listener ()`.

* &#x20;**subscribe(callback) -** Вызывает `callback(distribution)` один раз для каждого активного распределения, которое сейчас находится в наборе или добавляется позже. Поскольку обратный вызов вызывается для уже активных дистрибутивов, вам не нужно самостоятельно перебирать рабочий набор для работы с существующими элементами; просто зарегистрируйте обратный вызов и будьте готовы к тому, что он будет немедленно вызван этим методом. Обратите внимание, что обратные вызовы **не должны** допускать распространения исключений, иначе они будут мешать работе других обратных вызовов и, возможно, приведут к несогласованному состоянию рабочего набора. Обратные вызовы должны использовать блок `try/except`, чтобы игнорировать, регистрировать или иным образом обрабатывать любые ошибки, особенно потому, что код, вызвавший вызов обратного вызова, вряд ли сможет обрабатывать ошибки лучше, чем сам обратный вызов.

`pkg_resources.add_activation_listener ()` - это альтернативное написание `pkg_resources.working_set.subscribe ()`.

#### Поиск плагинов

Расширяемые приложения иногда имеют «каталог плагинов» или набор каталогов плагинов, из которых они хотят загружать точки входа или другие метаданные. Метод `find_plugins ()` позволяет вам сделать это, сканируя среду на предмет новейшей версии каждого проекта, которую можно безопасно загрузить без конфликтов или отсутствия требований.

* **find\_plugins(plugin\_env, full\_env=None, fallback=True) -** Сканирует _**plugin\_env**_ и определяет, какие дистрибутивы могут быть добавлены в этот рабочий набор без конфликтов версий или отсутствующих требований. Пример использования:

```python
distributions, errors = working_set.find_plugins(
    Environment(plugin_dirlist)
)
map(working_set.add, distributions)  # добавить плагины + библиотеки в sys.path
print "Couldn't load", errors        # отобразить ошибку
```

_**plugin\_env**_ должен быть экземпляром **Environment**, который содержит только дистрибутивы, которые находятся в «каталоге плагинов» или каталогах проекта. _**full\_env**_, если он указан, должен быть экземпляром **Environment**, содержащим все доступные в настоящее время дистрибутивы.

Если _**full\_env**_ не указан, он создается автоматически из **WorkingSet**, вызываемого этим методом, что обычно означает, что каждый каталог в `sys.path` будет сканироваться на предмет наличия дистрибутивов.

Этот метод возвращает кортеж из двух частей: (`distributions`, `error_info`), где **distributions** - это список загружаемых дистрибутивов, найденных в _**plugin\_env**_, вместе с любыми другими дистрибутивами, которые необходимы для разрешения их зависимостей. **error\_info** - это словарь, сопоставляющий загружаемые дистрибутивы плагинов с экземпляром исключения, описывающим возникшую ошибку. Обычно это будет экземпляр **DistributionNotFound** или **VersionConflict**.

Большинство приложений будут использовать этот метод в основном в главном экземпляре **working\_set** в **pkg\_resources**, а затем сразу же добавят возвращенные дистрибутивы в рабочий набор, чтобы они были доступны в `sys.path`. Это позволит найти любые точки входа и позволит активировать любые другие метаданные и ловушки.

Алгоритм разрешения, используемый `find_plugins ()`, следующий. Сначала сортируются имена проектов дистрибутивов, представленных в _**plugin\_env**_. Затем проверяются «**egg**» каждого проекта в порядке убывания версий (т. е. сначала новейшая версия).

Делается попытка разрешить зависимости каждого **egg**. Если попытка успешна, **egg** и его зависимости добавляются в выходной список и во временную копию рабочего набора. Процесс разрешения продолжается со следующим именем проекта, и более старые **eggs** для этого проекта не пробуются.

Однако, если попытка разрешения не удалась, ошибка добавляется в словарь ошибок. Если _**fallback**_ флаг `True`, выполняется попытка следующей более старой версии плагина, пока не будет найдена рабочая версия. Если `false`, процесс разрешения продолжается со следующим именем проекта плагина.

Некоторые приложения могут иметь более строгие требования к откату, чем другие. Например, приложение, которое имеет схему базы данных или постоянные объекты, может не иметь возможности безопасно понизить версию пакета. Другие могут захотеть убедиться, что новая конфигурация подключаемого модуля работает на 100%, либо вернуться к заведомо исправной конфигурации. (То есть они могут захотеть вернуться к известной конфигурации, если возвращаемое значение **error\_info** не пусто.)

Обратите внимание, что этот алгоритм дает приоритет удовлетворению зависимостей предшествующих в алфавитном порядке имен проектов в случае конфликтов версий. Если два проекта с именами «AaronsPlugin» и «ZekesPlugin» нуждаются в разных версиях «TomsLibrary», то «AaronsPlugin» победит, а «ZekesPlugin» будет отключен из-за конфликта версий.

### Объекты Environment

«**environment**» - это набор объектов **Distribution**, обычно присутствующих и потенциально доступных для импорта на текущей платформе. Объекты **Environment** используются **pkg\_resources** для индексации доступных дистрибутивов во время разрешения зависимостей.

* **Environment(search\_path=None, platform=get\_supported\_platform(), python=PY\_MAJOR - **_**search\_path**_ - Создает моментальный снимок среды, просканировав _**search\_path**_ на наличие дистрибутивов, совместимых с _**platform**_ и _**python**_. _**search\_path**_ должен быть последовательностью строк, такой же как может использоваться в `sys.path`. Если _**search\_path**_ не указан, используется `sys.path`. _**platform**_ - это необязательная строка, определяющая имя платформы, с которой должны быть совместимы дистрибутивы для конкретной платформы. Если не указано, по умолчанию используется текущая платформа. _**python**_ - это необязательная строка, указывающая желаемую версию Python (например, «`2.4`»); по умолчанию используется текущая версия. Вы можете явно установить для _**platform**_ (и/или _**python**_) значение `None`, если хотите включить все дистрибутивы, а не только те, которые совместимы с работающей платформой или версией Python. Обратите внимание, что _**search\_path**_ немедленно сканируется на предмет наличия дистрибутивов, и результирующая **Environment** является моментальным снимком найденных дистрибутивов. Он не обновляется автоматически, если состояние системы изменяется из-за, например, установки или удаления дистрибутивов.
* &#x20;**\_\_getitem\_\_(project\_name) -** Возвращает список дистрибутивов для данного проекта, отсортированный от самой новой до самой старой версии. (И приоритет формата от самого высокого до самого низкого для дистрибутивов, содержащих одну и ту же версию проекта.) Если дистрибутивов для проекта нет, возвращает пустой список.
* &#x20;**\_\_iter\_\_() -** Получает уникальные имена проектов для дистрибутивов в этой среде. Полученные имена всегда в нижнем регистре.
* &#x20;**add(dist) -** Добавьте _**dist**_ в среду, если она соответствует платформе и версии Python, указанным во время создания, и только если дистрибутив еще не был добавлен. (т. е. добавление одного и того же дистрибутива более одного раза невозможно.)
* &#x20;**remove(dist) -** Удалите _**dist**_ из окружения.
* &#x20;**can\_add(dist) -** Приемлем ли дистрибутив **dist** для этой среды? Если он несовместим со значениями _**platform**_ и версии _**python**_, указанными при создании среды, возвращается значение `false`.
* &#x20;**\_\_add\_\_(dist\_or\_env) (+ operator) -** Добавьте дистрибутив или среду в экземпляр `Environment`, возвращая **новый** объект среды, содержащий все дистрибутивы, ранее содержащиеся в обоих. Новая среда будет иметь _**platform**_ и _**python**_ как `None`, что означает, что она не будет отказываться от добавления в нее каких-либо дистрибутивов; он просто примет все, что добавлено. Если вы хотите, чтобы добавленные элементы фильтровались для платформы и версии Python, или вы хотите добавить их в **один и тот же** экземпляр среды, вам следует вместо этого использовать добавление на месте (`+=`).
* &#x20;**\_\_iadd\_\_(dist\_or\_env) (+= operator) -** Добавьте дистрибутив или среду в экземпляр `Environment` на месте, обновив существующий экземпляр и вернув его. Атрибуты фильтра _**platform**_ и _**python**_ вступают в силу, поэтому распределения в источнике, не имеющие подходящей строки платформы или версии Python, автоматически игнорируются.
* **best\_match(req, working\_set, installer=None) -** Найдите распределение, наиболее подходящее для _**req**_ и пригодное для использования в _**working\_set**_. Это вызывает метод `find (req)` для _**working\_set**_, чтобы увидеть, активен ли уже подходящий дистрибутив. (Это может вызвать **VersionConflict**, если неподходящая версия проекта уже активна в указанном _**working\_set**_.) Если подходящий дистрибутив не активен, этот метод возвращает самый новый дистрибутив в среде, который соответствует **Requirement** в _**req**_. Если подходящий дистрибутив не найден, а установщик предоставлен, то будет возвращен результат вызова метода `obtain (req, installer)` среды.
* **obtain (requirement, installer=None) -** Получите дистрибутив, соответствующий требованиям (например, путем загрузки). В базовом классе **Environment** эта подпрограмма просто возвращает `installer(requirement)`, если только установщик не является `None`, и в этом случае вместо этого возвращается `None`. Этот метод является ловушкой, которая позволяет подклассам пробовать другие способы получения дистрибутива перед тем, как вернуться к аргументу _**installer**_.
* &#x20;**scan(search\_path=None) -** Сканировать _**search\_path**_ на наличие дистрибутивов, используемых на _**platform**_. Любые найденные дистрибутивы добавляются в среду. _**search\_path**_ должен быть последовательностью строк, такой как может использоваться в `sys.path`. Если не указан, используется `sys.path`. Добавляются только дистрибутивы, соответствующие версии _**platform**_/_**python**_, определенной при инициализации. Этот метод представляет собой ярлык для использования функции `find_distributions ()` для поиска распределений из каждого элемента в _**search\_path**_ и последующего вызова `add ()` для добавления каждого из них в среду.

### Объекты Requirement

Объекты **Requirement** выражают, какие версии проекта подходят для той или иной цели. Эти объекты (или их строковая форма) используются различными API **pkg\_resources** для поиска дистрибутивов, которые необходимы скрипту или дистрибутиву.

#### Парсинг требований

* &#x20;**parse\_requirements(s) -** Выдает объекты **Requirement** для строки или итерации строк. Каждое требование должно начинаться с новой строки. См. синтаксис ниже.
* &#x20;**Requirement.parse(s) -** Создайте объект **Requirement** из строки или итерации строк. **ValueError** возникает, если строка или строки не содержат допустимого спецификатора требования или если они содержат более одного спецификатора. (Чтобы проанализировать несколько спецификаторов из строки или итерации строк, используйте вместо этого `parse_requirements ()`.) Синтаксис спецификатора требования полностью определен в **PEP 508**. Некоторые примеры допустимых спецификаторов требований:

```bash
FooProject >= 1.2
Fizzy [foo, bar]
PickyThing>1.6,<=1.9,!=1.8.6
SomethingWhoseVersionIDontCareAbout
SomethingWithMarker[foo]>1.0;python_version<"2.7"
```

Имя проекта - единственная необходимая часть строки требования, и если это единственное, что предоставлено, требование будет принимать любую версию этого проекта.

«**extras**» в требовании используются для запроса дополнительных функций проекта, которые могут потребовать дополнительных распределений проекта для работы. Например, если гипотетический проект «Report-O-Rama» предлагал дополнительную поддержку PDF, ему может потребоваться дополнительная библиотека для обеспечения этой поддержки. Таким образом, проект, которому требуются возможности Report-O-Rama в формате PDF, может использовать требование Report-O-Rama \[PDF] для запроса установки или активации как Report-O-Rama, так и любых библиотек, необходимых для обеспечения поддержки PDF. Например, вы можете использовать:

```bash
pip install Report-O-Rama[PDF]
```

Чтобы установить необходимые пакеты с помощью **pip**, или вызовите `pkg_resources.require ('Report-O-Rama [PDF]')`, чтобы добавить необходимые дистрибутивы в `sys.path` во время выполнения.

«**markers**» в требовании используются, чтобы указать, когда требование должно быть установлено - требование будет установлено, если маркер оценивается как истинный в текущей среде. Например, указание `argparse; python_version <"3.0"` не будет установлено в среде Python 3, но будет установлено в среде Python 2.

#### Методы и атрибуты Requirement

* &#x20;**\_\_contains\_\_(dist\_or\_version) -** Вернет `true`, если _**dist\_or\_version**_ соответствует критериям этого требования. Если _**dist\_or\_version**_ является объектом **Distribution**, его имя проекта должно соответствовать имени проекта требования, а его версия должна соответствовать критериям версии требования. Если _**dist\_or\_version**_ является строкой, она анализируется с помощью служебной функции `parse_version ()`. В противном случае предполагается, что это уже проанализированная версия. Спецификаторы версии объекта **Requirement** (`.specs`) внутренне сортируются в порядке возрастания версий и используются для определения приемлемых диапазонов версий. Смежные избыточные условия эффективно объединяются (например, `«>1,>2»` дает те же результаты, что и `«>2»`, а `«<2,<3»` дает те же результаты, что и `«<2»`). `"!="` версии исключаются из диапазонов, в которые они входят. Затем проверяемая версия на приемлемость проверяется на принадлежность к полученным диапазонам.
* &#x20;**\_\_eq\_\_(other\_requirement) -** Требование сравнивается с другим требованием, если они имеют одинаковые имена проектов, спецификаторы версии и дополнительные функции без учета регистра. (Порядок, в котором находятся дополнительные элементы и спецификаторы версии, также игнорируется.) Равные требования также имеют равные хэши, так что требования могут использоваться в наборах или как ключи словаря.
* &#x20;**\_\_str\_\_() -** Строковая форма **Requirement** - это строка, которая при передаче в `Requirement.parse ()` вернет равный объект **Requirement**.
* &#x20;**project\_name -** Название необходимого проекта
* **key** - Версия _**project\_name**_ в нижнем регистре, полезная для сравнения или индексации.
* **extras** - Кортеж имен «extras», которых требует это требование. (Они будут полностью строчными и нормализованы с помощью служебной функции синтаксического анализа `safe_extra ()`, поэтому они могут не точно соответствовать дополнительным функциям, с которыми было создано требование.)
* **specs** - Список кортежей `(op, version)`, отсортированных в порядке возрастания проанализированных версий. _**op**_ в каждом кортеже - это оператор сравнения, представленный в виде строки. _**version**_ - это (не проанализированный) номер версии.
* **marker** - Экземпляр `package.markers.Marker`, который позволяет выполнять оценку в текущей среде. Может быть `None`, если не указан маркер.
* **url** - Местоположение, из которого загружается требование, если указано.

### Точки входа (Entry Points)

Точки входа - это простой способ для дистрибутивов «объявлять» объекты Python (такие как функции или классы) для использования другими дистрибутивами. Расширяемые приложения и фреймворки могут искать точки входа с определенным именем или группой либо из определенного дистрибутива, либо из всех активных дистрибутивов в `sys.path`, а затем проверять или загружать объявленные объекты по желанию.

Точки входа принадлежат «_**groups**_», которым присвоено имя, разделенное точками, аналогично имени пакета или модуля Python. Например, пакет **setuptools** использует точку входа с именем **distutils.commands** для поиска команд, определенных расширениями **distutils**. **setuptools** рассматривает имена точек входа, определенных в этой группе, как допустимые команды для сценария установки.

Аналогичным образом другие пакеты могут определять свои собственные группы точек входа, используя динамические имена внутри группы (например, **distutils.commands**) или, возможно, используя предопределенные имена внутри группы. Например, структура ведения блога, которая предлагает различные перехватчики до или после публикации, может определять группу точек входа и искать точки входа с именами «pre\_process» и «post\_process» в этой группе.

Чтобы объявить точку входа, проект должен использовать **setuptools** и предоставить аргумент _**entry\_points**_ для `setup ()` в своем сценарии установки, чтобы точки входа были включены в метаданные дистрибутива. Дополнительные сведения см. в разделе «[Поведение объявления](rukovodstvo-polzovatelya-setuptools/tochki-vkhoda.md#reklamnoe-povedenie)».

Каждое распространение проекта может анонсировать не более одной точки входа с заданным именем в одной и той же группе точек входа. Например, расширение **distutils** может анонсировать две разные точки входа **distutils.commands**, если у них разные имена. Однако ничто не мешает **разным** проектам объявлять одноименные точки входа в одной группе. В некоторых случаях это желательно, поскольку приложение или фреймворк, использующий точки входа, может вызывать их как перехватчики или каким-то другим образом комбинировать их. Приложение или структура должны решать, что делать, если несколько дистрибутивов объявляют точку входа; некоторые возможности включают использование обеих точек входа, отображение сообщения об ошибке, использование первой из найденных в порядке `sys.path` и т. д.

### Удобное API для Entry Points

В следующих функциях аргумент _**dist**_ может быть экземпляром **Distribution**, экземпляром **Requirement** или строкой, определяющей требование (например, имя проекта, версия и т. д.). Если аргумент является строкой или **Requirement**, указанное распределение находится (и добавляется в `sys.path`, если он еще не указан). Если соответствующий дистрибутив недоступен, возникнет ошибка.

Аргумент _**group**_ должен быть строкой, содержащей идентификатор, разделенный точками, определяющий группу точки входа. Если вы определяете группу точек входа, вы должны включить некоторую часть имени вашего пакета в имя группы, чтобы избежать конфликтов с группами точек входа других пакетов.

* **load\_entry\_point(dist, group, name) -** Загружает именованную точку входа из указанного дистрибутива или вызывает **ImportError**.
* **get\_entry\_info(dist, group, name) -** Вернуть объект **EntryPoint** для данных _**group**_ и _**name**_ из указанного распределения. Возвращает `None`, если дистрибутив не объявил подходящую точку входа.
* **get\_entry\_map(dist, group=None) -** Возвращает карту точек входа распространения для _**group**_ или полную карту точки входа для дистрибутива. Эта функция всегда возвращает словарь, даже если раздача не объявляет точек входа. Если задана _**group**_, словарь сопоставляет имена точек входа с соответствующим объектом **EntryPoint**. Если _**group**_ равно `None`, словарь сопоставляет имена групп со словарями, которые затем сопоставляют имена точек входа с соответствующим экземпляром **EntryPoint** в этой группе.
* **iter\_entry\_points(group, name=None) -** Получает объекты точки входа из _**group**_, соответствующей _**name**_. Если _**name**_ равно `None`, выдаются все точки входа в группе из всех дистрибутивов в рабочем наборе в `sys.path`, в противном случае возвращаются только те, которые соответствуют и _**group**_, и _**name**_. Точки входа выдаются из активных дистрибутивов в том порядке, в котором они появляются в `sys.path`. (Однако внутри точек входа для конкретного дистрибутива нет определенного порядка.)

{% hint style="info" %}
Этот API на самом деле является методом глобального объекта **working\_set**; дополнительную информацию см. в разделе выше, посвященном [основным методам WorkingSet](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#bazovye-metody-workingset).
{% endhint %}

### Создание и парсинг

* **EntryPoint(name, module\_name, attrs=(), extras=(), dist=None) -** Создайте экземпляр **EntryPoint**. _**name**_ - имя точки входа. _**module\_name**_ - это (разделенное точками) имя модуля, содержащего объявляемый объект. _**attrs**_ - это необязательный кортеж имен, который нужно искать в модуле для получения объявленного объекта. Например, атрибут _**attrs**_ `("foo", "bar")` и _**module\_name**_ `"baz"` означают, что объявляемый объект может быть получен с помощью следующего кода:

```python
import baz
advertised_object = baz.foo.bar
```

_**extras**_ - это необязательный кортеж имен «дополнительных функций», который необходим дистрибутиву для обеспечения этой точки входа. Когда точка входа загружена, эти дополнительные функции ищутся в аргументе _**dist**_, чтобы выяснить, какие другие дистрибутивы могут потребоваться активировать в `sys.path`; см. метод `load ()` для более подробной информации. Аргумент _**extras**_ имеет смысл, только если указан _**dist**_. _**dist**_ должен быть экземпляром **Distribution**.

* &#x20;**EntryPoint.parse(src, dist=None) (classmethod) -** Разобрать одну точку входа из строки _**src**_. Синтаксис точки входа имеет следующий вид:

```python
name = some.module:some.attr [extra1,extra2]
```

Имя записи и имя модуля являются обязательными, но части `:attrs` и `[extras]` являются необязательными, как и пробелы между некоторыми элементами. Аргумент _**dist**_ передается конструктору `EntryPoint ()` вместе с другими значениями, полученными из _**src**_.

* &#x20;**EntryPoint.parse\_group(group, lines, dist=None) (classmethod) -** Анализирует _**lines**_ (строку или последовательность строк), чтобы создать словарь, отображающий имена точек входа на объекты **EntryPoint**. **ValueError** возникает, если имена точек входа дублируются, если _**group**_ не является допустимым именем группы точек входа или если есть какие-либо синтаксические ошибки. (Примечание: параметр _**group**_ используется только для проверки и создания более информативных сообщений об ошибках.) Если указан параметр _**dist**_, он будет использоваться для установки атрибута _**dist**_ созданных объектов **EntryPoint**.
* &#x20;**EntryPoint.parse\_map(data, dist=None) (classmethod) -** Анализирует _**data**_ в словарях, сопоставляя имена групп со словарями, сопоставляя имена точек входа с объектами **EntryPoint**. Если _**data**_ является словарем, то ключи используются как имена групп, а значения передаются в `parse_group ()` в качестве аргумента _**lines**_. Если _**data**_ представляют собой строку или последовательность строк, они сначала разделяются на разделы в стиле `.ini` (с помощью служебной функции `split_sections ()`), а имена разделов используются в качестве имен групп. В любом случае аргумент _**dist**_ передается в `parse_group ()`, чтобы точки входа были связаны с указанным распределением.

### Объекты EntryPoint

Для простого самоанализа объекты **EntryPoint** имеют атрибуты, которые точно соответствуют именам аргументов конструктора: доступны _**name**_, _**module\_name**_, _**attrs**_, _**extras**_ и _**dist**_. Кроме того, предусмотрены следующие методы:

* &#x20;**load() -** Загружает точку входа, возвращая объявленный объект Python. Фактически вызывает `self.require ()`, а затем возвращает `self.resolve ()`.
* **require(env=None, installer=None) -** Проверяет, что все «extras», необходимые для точки входа, доступны в `sys.path`. **UnknownExtra** возникает, если у **EntryPoint** есть _**extras**_, но нет _**dist**_, или если названные дополнения не определены распределением. Если указан _**env**_, это должна быть **Environment**, и она будет использоваться для поиска необходимых дистрибутивов, если они еще не присутствуют в `sys.path`. Если предоставляется _**installer**_, это должен быть вызываемый объект, принимающий экземпляр **Requirement** и возвращающий соответствующий импортируемый экземпляр **Distribution** или `None`.
* &#x20;**resolve() -** Разрешить точку входа из ее модуля и _**attrs**_, вернув объявленный объект Python. Вызывает ошибку **ImportError**, если ее невозможно получить.
* &#x20;**\_\_str\_\_() -** Строковая форма **EntryPoint** - это строка, которую можно передать в `EntryPoint.parse ()` для создания эквивалентной **EntryPoint**.

### Объекты Distribution

Объекты **Distribution** представляют собой коллекции кода Python, которые могут быть или не быть импортируемыми, и могут иметь или не иметь связанные с ними метаданные и ресурсы. Их метаданные могут включать такую информацию, как то, от каких других проектов зависит распространение, какие точки входа объявляет дистрибутив и т. д.

### Получение или создание дистрибутивов

Чаще всего вы получаете объекты **Distribution** из **WorkingSet** или **Environment**. (См. разделы выше об объектах [WorkingSet](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#obekty-workingset) и [Environment](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#obekty-environment), которые являются контейнерами для активных дистрибутивов и доступных дистрибутивов соответственно.) Вы также можете получить объекты **Distribution** из одного из этих высокоуровневых API:

* **find\_distributions(path\_item, only=False) -** Получение дистрибутивов доступно через _**path\_item**_. Если _**only**_ имеет значение `True`, вывести только те распределения, _**location**_ которых равно _**path\_item**_. Другими словами, если _**only**_ истинно, это дает любые дистрибутивы, которые можно было бы импортировать, если бы _**path\_item**_ находился в `sys.path`. Если _**only**_ имеет значение `False`, это также дает дистрибутивы, которые находятся «в» или «ниже» _**path\_item**_, но не будут импортированы, если их расположение не было также добавлено в `sys.path`.
* &#x20;**get\_distribution(dist\_spec) -** Возвращает объект **Distribution** для заданного **Requirement** или строки. Если _**dist\_spec**_ уже является экземпляром **Distribution**, он возвращается. Если это объект **Requirement** или строка, которую можно проанализировать, она используется для поиска и активации соответствующего распределения, которое затем возвращается.

Однако, если вы создаете специализированные инструменты для работы с дистрибутивами или создаете новый формат распространения, вам также может потребоваться создать объекты **Distribution** напрямую, используя один из трех конструкторов ниже.

Все эти конструкторы принимают необязательный аргумент _**metadata**_, который используется для доступа к любым ресурсам или метаданным, связанным с распределением. _**metadata**_ должны быть объектом, реализующим интерфейс **IResourceProvider**, или `None`. Если это `None`, вместо него используется **EmptyProvider**. Объекты **Distribution** реализуют методы [IResourceProvider](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#iresourceprovider) и [IMetadataProvider](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#metody-imetadataprovider), делегируя их объекту метаданных.

* &#x20;**Distribution.from\_location(location, basename, metadata=None, \*\*kw) (classmethod) -** Создает дистрибутив для _**location**_, которое должно быть строкой, такой как URL-адрес, имя файла или другой строкой, которая может использоваться в `sys.path`. _**basename**_ - это строка с названием дистрибутива, например `Foo-1.2-py2.4.egg`. Если _**basename**_ заканчивается на `.egg`, то имя проекта, версия, версия python и платформа извлекаются из имени файла и используются для установки этих свойств созданного дистрибутива. Любые дополнительные аргументы ключевого слова передаются конструктору `Distribution ()`.
* &#x20;**Distribution.from\_filename(filename, metadata=None\*\*kw) (classmethod) -** Создает дистрибутив, проанализировав локальное имя файла. Это более короткий способ обозначить `Distribution.from_location(normalize_path(filename), os.path.basename(filename), metadata)`. Другими словами, он создает дистрибутив, расположение которого является нормализованной формой имени файла, анализируя имя и информацию о версии из базовой части имени файла. Любые дополнительные аргументы ключевого слова передаются конструктору `Distribution ()`.
* &#x20;**Distribution(location,metadata,project\_name,version,py\_version,platform,precedence) -** Создает дистрибутив, задав его свойства. Все аргументы являются необязательными и по умолчанию равны `None`, за исключением _**py\_version**_ (по умолчанию используется текущая версия Python) и _**precedence**_ (по умолчанию **EGG\_DIST**; для получения дополнительных сведений см. [приоритет в разделе «Атрибуты распределения»](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#atributy-distribution) ниже). Обратите внимание, что обычно проще использовать конструкторы `from_filename ()` или `from_location ()`, чем указывать все эти аргументы по отдельности.

### Атрибуты Distribution

* **location** - Строка, указывающая местонахождение раздачи. Для импортируемого дистрибутива это строка, которая будет добавлена в `sys.path`, чтобы сделать его активно импортируемым. Для не импортируемых дистрибутивов это просто имя файла, URL-адрес или другой способ поиска дистрибутива.
* **project\_name** - Строка с названием проекта, для которого предназначен этот дистрибутив. Имена проектов определяются сценарием установки проекта, и они используются для идентификации проектов в PyPI. При создании распределения аргумент _**project\_name**_ передается через служебную функцию `safe_name ()` для фильтрации любых недопустимых символов.
* **key** - `dist.key` - это сокращение от `dist.project_name.lower ()`. Он используется для сравнения без учета регистра и индексации дистрибутивов по названию проекта.
* **extras** - Список строк, дающий имена дополнительных функций, определенных списком зависимостей проекта (аргумент _**extras\_require**_, указанный в сценарии настройки проекта).
* **version** - Строка, обозначающая, какой выпуск проекта содержит этот дистрибутив. При создании **Distribution** аргумент версии передается через служебную функцию `safe_version ()`, чтобы отфильтровать любые недопустимые символы. Если во время создания _**version**_ не указана, то попытка получить доступ к этому атрибуту позже приведет к тому, что **Distribution** попытается обнаружить его версию, прочитав файл метаданных **PKG-INFO**. Если **PKG-INFO** недоступен или не может быть проанализирован, возникает ошибка **ValueError**.
* **parsed\_version** - это объект, представляющий «проанализированную» форму _**version**_ дистрибутива. `dist.parsed_version` - это ярлык для вызова `parse_version (dist.version)`. Он используется для сравнения или сортировки дистрибутивов по версии. (См. раздел «[Утилиты синтаксического анализа](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#utility-sintaksicheskogo-analiza)» ниже для получения дополнительной информации о функции `parse_version ()`.) Обратите внимание, что доступ к _**parsed\_version**_ может привести к ошибке **ValueError**, если распространение было создано без _**version**_ и без _**metadata**_, способных предоставить информацию об отсутствующей версии.
* **py\_version** - Основная/дополнительная версия Python, поддерживаемая дистрибутивом, в виде строки. Например, «`2.7`» или «`3.4`». По умолчанию используется текущая версия Python.
* **platform** - Строка, представляющая платформу, для которой предназначен дистрибутив, или `None`, если дистрибутив является «чистым Python» и, следовательно, кроссплатформенным. См. раздел «[Утилиты платформы](obnaruzhenie-paketov-i-dostup-k-resursam-s-pomoshyu-pkg\_resources.md#utility-platformy)» ниже для получения дополнительной информации о строках платформы.
* **precedence** - Приоритет дистрибутива используется для определения относительного порядка двух дистрибутивов с одинаковыми _**project\_name**_ и _**parsed\_version**_. Приоритет по умолчанию - `pkg_resources.EGG_DIST`, что является наивысшим (т.е. наиболее предпочтительным) приоритетом. Полный список предопределенных приоритетов от наиболее предпочтительного до наименее предпочтительного: `EGG_DIST`, `BINARY_DIST`, `SOURCE_DIST`, `CHECKOUT_DIST` и `DEVELOP_DIST`. Обычно приоритеты, отличные от **EGG\_DIST**, используются только модулем `setuptools.package_index` при сортировке дистрибутивов, найденных в индексе пакета, для определения их пригодности для установки. «System» и «Development» **eggs** (т.е. те, которые используют формат `.egg-info`), однако, автоматически получают приоритет **DEVELOP\_DIST**.

### Методы Distribution

### ResourceManager API

### Базовый доступ к ресурсам

### Извлечение ресурса

### Интерфейс "Provider"

### Metadata API

### Методы IMetadataProvider

### Исключения

### Поддержка пользовательских импортеров

### IResourceProvider

### Встроенные провайдеры ресурсов

### Служебные функции

### Утилиты синтаксического анализа

### Утилиты платформы
