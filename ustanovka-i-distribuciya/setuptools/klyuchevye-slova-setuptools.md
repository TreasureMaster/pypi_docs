# Ключевые слова setuptools

### name

Строка, определяющая имя пакета.

### version

Строка, указывающая номер версии пакета.

### description

Строка, описывающая пакет в одной строке.

### long\_description

Строка с более подробным описанием пакета.

### long\_description\_content\_type

Строка, определяющая тип содержимого, используется для _**long\_description**_ (например, `text/markdown`)

### author

Строка, определяющая автора пакета.

### author\_email

Строка, определяющая адрес электронной почты автора пакета.

### maintainer

Строка, определяющая имя текущего сопровождающего, если оно отличается от автора. Обратите внимание: если сопровождающий предоставляется, **setuptools** будет использовать его как автора в **PKG-INFO**.

### maintainer\_email

Строка, указывающая адрес электронной почты текущего сопровождающего, если он отличается от автора.

### url

Строка, определяющая URL-адрес домашней страницы пакета.

### download\_url

Строка, указывающая URL-адрес для загрузки пакета.

### packages

Список строк, определяющих **пакеты**, которыми будет управлять **setuptools**.

### py\_modules

Список строк, определяющих **модули**, которыми будет управлять **setuptools**.

### scripts

Список строк, определяющих **отдельные файлы сценариев**, которые необходимо собрать и установить.

### ext\_package

Строка, определяющая имя базового пакета для расширений, предоставляемых этим пакетом.

### ext\_modules

Список экземпляров `setuptools.Extension`, содержащий список создаваемых расширений Python.

### classifiers

Список строк, описывающих категории пакета.

### distclass

Подкласс **Distribution** для использования.

### script\_name

Строка, определяющая имя сценария `setup.py` - по умолчанию `sys.argv [0]`

### script\_args

Список строк, определяющих аргументы, передаваемые сценарию установки.

### options

Словарь, содержащий параметры по умолчанию для сценария установки.

### license

Строка, определяющая лицензию пакета.

### keywords

Список строк или разделенных запятыми строк, содержащих описательные метаданные. См .: [PEP 0314](https://www.python.org/dev/peps/pep-0314/).

### platforms

Список строк или строк, разделенных запятыми.

### cmdclass

Словарь, обеспечивающий отображение имен команд на подклассы `Command`.

### data\_files

Список строк, определяющих файлы данных для установки.

{% hint style="danger" %}
_**data\_files**_ устарел. Он не работает с **wheel**, поэтому его следует избегать.
{% endhint %}

### package\_dir

Словарь, обеспечивающий отображение пакета на имена каталогов.

### requires

{% hint style="danger" %}
_**require**_ заменяется на _**install\_requires**_ и больше не должен использоваться.
{% endhint %}

### obsoletes

Список строк, описывающих пакеты, которые этот пакет считает устаревшими, что означает, что эти два проекта не должны устанавливаться одновременно.

{% hint style="danger" %}
_**obsoletes**_ в настоящее время игнорируется **pip**.
{% endhint %}

Объявления версии могут быть предоставлены. Номера версий должны быть в формате, указанном в спецификаторах версии (например, `foo (<3.0)`).

Это поле может сопровождаться маркером среды после точки с запятой (например, `foo; os_name == "posix"`)

Чаще всего это поле используется в случае изменения имени проекта, например Gorgon 2.3 входит в состав Torqued Python 1.0. При установке Torqued Python дистрибутив Gorgon следует удалить.

### provides

Список строк, описывающих имена пакетов и виртуальных пакетов, содержащихся в этом пакете.

{% hint style="danger" %}
_**provides**_ в настоящее время игнорируется **pip**.
{% endhint %}

Пакет может содержать дополнительные имена, например чтобы указать, что несколько проектов были объединены вместе. Например, исходные дистрибутивы проекта ZODB исторически включали проект транзакции, который теперь доступен как отдельный дистрибутив. Установка такого исходного дистрибутива удовлетворяет требованиям как для ZODB, так и для транзакции.

Пакет также может предоставлять «виртуальное» имя проекта, которое не соответствует никакому отдельно распределенному проекту: такое имя может использоваться для обозначения абстрактной возможности, которая может быть предоставлена одним из нескольких проектов. Например, несколько проектов могут предоставлять привязки RDBMS для использования данной ORM: каждый проект может объявлять, что он предоставляет ORM-привязки, позволяя другим проектам зависеть только от наличия хотя бы одного из них.

Объявление версии может быть предоставлено и должно соответствовать правилам, описанным в спецификаторах версии. Номер версии дистрибутива будет подразумеваться, если ничего не указано (например, `foo (<3.0)`).

За каждым пакетом может следовать маркер среды после точки с запятой (например, `foo; os_name == "posix"`).

### include\_package\_data

Если установлено значение `True`, это указывает программе **setuptools** автоматически включать любые файлы данных, которые он находит в каталогах пакетов, указанных в файле `MANIFEST.in`. Для получения дополнительной информации см. раздел «[Включение файлов данных](rukovodstvo-polzovatelya-setuptools/podderzhka-failov-dannykh.md)».

### exclude\_package\_data

Словарь, отображающий имена пакетов в списки шаблонов glob, которые следует исключить из каталогов пакетов. Вы можете использовать это, чтобы обрезать любые лишние файлы, включенные _**include\_package\_data**_. Полное описание и примеры см. в разделе «[Включение файлов данных](rukovodstvo-polzovatelya-setuptools/podderzhka-failov-dannykh.md)».

### package\_data

Словарь, отображающий имена пакетов в списки шаблонов glob. Полное описание и примеры см. в разделе «[Включение файлов данных](rukovodstvo-polzovatelya-setuptools/podderzhka-failov-dannykh.md)». Вам не нужно использовать эту опцию, если вы используете _**include\_package\_data**_, если вам не нужно добавлять, например, файлы, которые создаются вашим сценарием установки и процессом сборки. (И поэтому они не находятся в системе контроля версий или являются файлами, которые вы не хотите включать в свой исходный дистрибутив.)

### zip\_safe

Логический флаг (**True** или **False**), указывающий, можно ли безопасно установить и запустить проект из zip-файла. Если этот аргумент не указан, команде **bdist\_egg** придется анализировать все содержимое вашего проекта на предмет возможных проблем каждый раз, когда она создает **egg**.

### install\_requires

Строка или список строк, определяющих, какие другие дистрибутивы необходимо установить. См. раздел [Объявление требуемой зависимости](rukovodstvo-polzovatelya-setuptools/upravlenie-zavisimostyami-v-setuptools.md#obyavlenie-neobkhodimoi-zavisimosti) для получения подробной информации и примеров формата этого аргумента.

### entry\_points

Словарь, отображающий имена групп точек входа в строки или списки строк, определяющих точки входа. Точки входа используются для поддержки динамического обнаружения сервисов или плагинов, предоставляемых проектом. Подробности и примеры формата этого аргумента см. в разделе «[Поведение объявления](rukovodstvo-polzovatelya-setuptools/tochki-vkhoda.md#reklamnoe-povedenie)». Кроме того, это ключевое слово используется для поддержки [автоматического создания сценария](rukovodstvo-polzovatelya-setuptools/tochki-vkhoda.md#tochki-vkhoda-entry-points).

### extras\_require

Словарь, отображающий имена «**extras**» (дополнительных функций вашего проекта) в строки или списки строк, определяющие, какие другие дистрибутивы должны быть установлены для поддержки этих функций. См. раздел [Объявление требуемой зависимости](rukovodstvo-polzovatelya-setuptools/upravlenie-zavisimostyami-v-setuptools.md#obyavlenie-neobkhodimoi-zavisimosti) для получения подробной информации и примеров формата этого аргумента.

### python\_requires

Строка, соответствующая спецификатору версии (как определено в **PEP 440**) для версии Python, используемой для указания Requires-Python, определенного в **PEP 345**.

### setup\_requires

{% hint style="danger" %}
Использование _**setup\_requires**_ не рекомендуется в пользу [PEP-518](https://www.python.org/dev/peps/pep-0518/).
{% endhint %}

Строка или список строк, указывающих, какие другие дистрибутивы должны присутствовать для запуска сценария установки. **setuptools** попытается получить их (вплоть до загрузки с помощью **EasyInstall**) перед обработкой остальной части сценария или команд установки. Этот аргумент необходим, если вы используете расширения **distutils** как часть процесса сборки; например, расширения, которые обрабатывают аргументы `setup ()` и превращают их в файлы метаданных **EGG-INFO**.

{% hint style="info" %}
проекты, перечисленные в _**setup\_requires**_, **НЕ** будут автоматически установлены в системе, в которой выполняется сценарий установки. Они просто загружаются в каталог **./.eggs**, если они еще не доступны локально. Если вы хотите, чтобы они были установлены, а также были доступны при запуске сценария установки, вы должны добавить их в _**install\_requires**_ и _**setup\_requires**_.
{% endhint %}

### dependency\_links

Список строк с именами URL-адресов, по которым будет выполняться поиск при удовлетворении зависимостей. Эти ссылки будут использоваться при необходимости для установки пакетов, указанных в _**setup\_requires**_ или _**tests\_require**_. Они также будут записаны в метаданные **egg** для использования такими инструментами, как **EasyInstall**, для установки файла `.egg`.

{% hint style="danger" %}
_**dependency\_links**_ устарел. Он больше не поддерживается **pip**.
{% endhint %}

### namespace\_packages

Список строк, называющих «пакеты пространства имен» проекта. Пакет пространства имен - это пакет, который можно разделить на несколько дистрибутивов проекта. Например, пакет **zope** Zope 3 представляет собой пакет пространства имен, поскольку подпакеты, подобные **zope.interface** и **zope.publisher**, могут распространяться отдельно. Система среды выполнения **egg** может автоматически объединять такие подпакеты в один родительский пакет во время выполнения, если вы объявляете их в каждом проекте, содержащем любые подпакеты пакета пространства имен, и пока `__init__.py` пакета пространства имен не содержит никакого кода кроме объявления пространства имен. См. раздел [Использование find\_namespace: или find\_namespace\_packages](rukovodstvo-polzovatelya-setuptools/obnaruzhenie-paketov-i-paket-prostranstva-imen.md#ispolzovanie-find\_namespace-ili-find\_namespace\_packages) для получения дополнительной информации.

### test\_suite

Строка с именем подкласса `unittest.TestCase` (или пакетом или модулем, содержащим один или несколько из них, или методом такого подкласса), или с именем функции, которая может быть вызвана без аргументов и возвращает `unittest.TestSuite`. Если названный набор является модулем, и у модуля есть функция `additional_tests ()`, он вызывается, и результаты добавляются к тестам, которые нужно запустить. Если именованный набор является пакетом, любые подмодули и подпакеты рекурсивно добавляются в общий набор тестов.

Указание этого аргумента позволяет использовать пакет [test - сборка пакет и запуск пакета unittest](rukovodstvo-polzovatelya-setuptools/spravka-po-komandam-setuptools.md#test-sobiraet-paket-i-zapuskaet-paket-unittest) для запуска указанного набора тестов, например через `setup.py test`. См. раздел о test - Сборка пакета и выполнение команды unittest suite ниже для получения дополнительных сведений.

{% hint style="warning" %}
_Новое в версии 41.5.0:_ устарела команда **test**.
{% endhint %}

### tests\_require

Если для тестов вашего проекта требуется один или несколько дополнительных пакетов помимо тех, которые необходимы для его установки, вы можете использовать эту опцию, чтобы указать их. Это должна быть строка или список строк, определяющих, какие другие дистрибутивы должны присутствовать для запуска тестов пакета. Когда вы запустите команду **test**, **setuptools** попытается получить их (даже до того, что загрузит их с помощью **EasyInstall**). Обратите внимание, что эти необходимые проекты не будут установлены в системе, в которой выполняются тесты, а будут загружены в каталог установки проекта только в том случае, если они еще не установлены локально.

{% hint style="warning" %}
_Новое в версии 41.5.0:_ устарела команда **test**.
{% endhint %}

### test\_loader

Если вы хотите использовать другой способ поиска тестов для запуска, отличный от того, который обычно использует **setuptools**, вы можете указать имя модуля и имя класса в этом аргументе. Именованный класс должен создавать экземпляры без аргументов, а его экземпляры должны поддерживать метод `loadTestsFromNames ()`, как определено в классе **TestLoader** модуля Python **unittest**. **setuptools** передаст только одно тестовое «имя» в аргументе _**names**_: значение, указанное для аргумента _**test\_suite**_. Указанный вами загрузчик может интерпретировать эту строку как угодно, поскольку нет никаких ограничений на то, что может содержаться в строке _**test\_suite**_.

Имя модуля и имя класса должны быть разделены знаком `:`. Значение этого аргумента по умолчанию - `«setuptools.command.test: ScanningLoader»`. Если вы хотите использовать поведение **unittest** по умолчанию, вы можете вместо этого указать `unittest: TestLoader` в качестве аргумента _**test\_loader**_. Это предотвратит автоматическое сканирование субмодулей и субпакетов.

Указанные здесь модуль и класс могут содержаться в другом пакете, если вы используете параметр _**tests\_require**_, чтобы гарантировать, что пакет, содержащий класс загрузчика, доступен при запуске команды **test**.

{% hint style="warning" %}
_Новое в версии 41.5.0:_ устарела команда **test**.
{% endhint %}

### eager\_resources

Список строк с именами ресурсов, которые должны быть извлечены вместе, если они необходимы, или если какие-либо расширения C, включенные в проект, импортируются. Этот аргумент полезен только в том случае, если проект будет установлен как zip-файл, и необходимо, чтобы все перечисленные ресурсы были извлечены в файловую систему как единое целое. Перечисленные здесь ресурсы должны быть разделены «`/`» путями относительно исходного корня, поэтому для перечисления ресурса **foo.png** в пакете **bar.baz** вы должны включить в этот аргумент строку `bar/baz/foo.png`.

Если вам нужно получать ресурсы только по одному или у вас нет каких-либо расширений C, которые обращаются к другим файлам в проекте (например, к файлам данных или разделяемым библиотекам), вам, вероятно, **НЕ** нужен этот аргумент и не следует путаться с этим. Подробнее о том, как работает этот аргумент, см. ниже в разделе «[Автоматическое извлечение ресурсов](rukovodstvo-polzovatelya-setuptools/avtomaticheskoe-izvlechenie-resursov.md#avtomaticheskoe-izvlechenie-resursov)».

### use\_2to3

Преобразует исходный код из Python 2 в Python 3 с помощью **2to3** в процессе сборки. Дополнительные сведения см. в разделе «[Поддержка Python 2 и Python 3 с помощью setuptools](rukovodstva-po-obratnoi-sovmestimosti-i-ustarevshei-praktike/podderzhka-python-2-i-python-3-s-pomoshyu-setuptools.md)».

### convert\_2to3\_doctests

Список исходных файлов **doctest**, которые необходимо преобразовать с помощью **2to3**. Дополнительные сведения см. в разделе «[Поддержка Python 2 и Python 3 с помощью setuptools](rukovodstva-po-obratnoi-sovmestimosti-i-ustarevshei-praktike/podderzhka-python-2-i-python-3-s-pomoshyu-setuptools.md)».

### use\_2to3\_fixers

Список модулей для поиска дополнительных исправлений, которые будут использоваться во время преобразования **2to3**. Дополнительные сведения см. в разделе «[Поддержка Python 2 и Python 3 с помощью setuptools](rukovodstva-po-obratnoi-sovmestimosti-i-ustarevshei-praktike/podderzhka-python-2-i-python-3-s-pomoshyu-setuptools.md)».

### use\_2to3\_exclude\_fixers

Список имен фиксаторов, которые следует пропустить.

### project\_urls

Произвольное сопоставление имен URL-адресов с гиперссылками, позволяющее более расширяемую документацию о том, где можно найти различные ресурсы, чем предоставляют простые параметры _**url**_ и _**download\_url**_.
