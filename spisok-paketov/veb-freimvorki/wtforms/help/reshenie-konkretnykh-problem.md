# Решение конкретных проблем

Далее следует сборник рецептов, которые помогут вам решить конкретные проблемы, которые могут возникнуть при использовании **WTForms** вместе с различными другими фреймворками Python.

### Прелюдия: Ткните его палкой!

Цель **WTForms** не в том, чтобы делать все это, а в том, чтобы придерживаться основ, сохраняя при этом совместимость с максимально возможным количеством фреймворков. Мы пытаемся разместить полезные вещи в API, чтобы разработчики могли получить от него то, что они хотят, если поведение по умолчанию нежелательно.

Например, многие поля в **WTForms** являются итеративными, чтобы вы могли получить доступ к закрытым полям внутри них, предоставляя вам еще один способ настроить их отображение. Многие атрибуты полей легко доступны для использования в ваших шаблонах. Мы рекомендуем вам использовать способности интерпретатора python к самоанализу, чтобы найти новые способы управления полями. Когда самоанализ не дает результатов, вам следует попробовать прочитать источник, чтобы понять, как все работает и как вы можете использовать вещи в своих интересах.

Если вы придумали решение, которое, по вашему мнению, будет полезным для других, и хотите поделиться им, сообщите нам об этом по электронной почте или через список рассылки, и мы добавим его в этот документ.

### Удаление полей для каждого экземпляра

Иногда вы создаете форму, в которой есть поля, которые могут использоваться не во всех случаях и не для всех пользователей. Хотя с помощью наследования форм действительно возможно определить форму именно с теми полями, которые вам нужны, иногда необходимо просто настроить существующую форму. К счастью, поля форм могут быть удалены после создания экземпляра с помощью ключевого слова `del`:

```python
class MagazineIssueForm(Form):
    title  = StringField()
    year   = IntegerField('Year')
    month  = SelectField(choices=MONTHS)

def edit_issue():
    publication = get_something_from_db()
    form = MagazineIssueForm(...)

    if publication.frequency == 'annual':
        del form.month

    # сделать нашу форму
```

Удаление поля из формы приведет к тому, что оно не будет проверено, и оно не будет отображаться при повторении формы. Как будто поле никогда не было определено с самого начала. Обратите внимание, что вы не можете добавлять поля таким образом, так как все поля должны существовать в форме при обработке входных данных.

### Композиция динамической формы

Это редкое явление, но иногда необходимо динамически создавать или изменять форму в вашем представлении. Это возможно путем создания внутренних подклассов:

```python
def my_view():
    class F(MyBaseForm):
        pass

    F.username = StringField('username')
    for name in iterate_some_model_dynamically():
        setattr(F, name, StringField(name.title()))

    form = F(request.POST, ...)
    # смотреть вещи
```

### Рендеринг ошибок

В своем шаблоне вы часто будете сталкиваться с повторяющейся задачей отображения ошибок для поля формы. Вот макрос **Jinja**, который поможет вам сэкономить время:

```python
{% raw %}
{% macro with_errors(field) %}
    <div class="form_field">
    {% if field.errors %}
        {% set css_class = 'has_error ' + kwargs.pop('class', '') %}
        {{ field(class=css_class, **kwargs) }}
        <ul class="errors">
            {% for error in field.errors %}<li>{{ error|e }}</li>{% endfor %}
        </ul>
    {% else %}
        {{ field(**kwargs) }}
    {% endif %}
    </div>
{% endmacro %}
{% endraw %}

Usage: {{ with_errors(form.field, style='font-weight: bold') }}
```

### Специальные трюки полей

Используя комбинации виджетов и полей, можно создавать новые модели поведения и совершенно новые способы отображения ввода формы для пользователя.

Классический пример легко поддерживается с использованием ключевой аргумент `widget=`, например, создание скрытого поля, в котором хранятся и приводятся целочисленные данные:

```python
user_id = IntegerField(widget=HiddenInput())
```

В качестве альтернативы вы можете создать поле, которое делает это путем создания подклассов:

```python
class HiddenInteger(IntegerField):
    widget = HiddenInput()
```

Некоторые поля поддерживают даже более сложную настройку. Например, что, если бы был желателен множественный выбор `<select>`, где вместо использования многострочного  использовалась серия флажков? Используя виджеты, можно очень легко добиться такого поведения:

```python
class MultiCheckboxField(SelectMultipleField):
    """
    Множественный выбор, за исключением отображения списка флажков.

    Итерация поля приведет к созданию подполей, позволяющих настраивать
    отображение вложенные поля флажков.
    """
    widget = widgets.ListWidget(prefix_label=False)
    option_widget = widgets.CheckboxInput()
```

При переопределении _**option\_widget**_ наш новый множественный выбор при повторении теперь будет создавать поля, которые отображаются как флажки.
