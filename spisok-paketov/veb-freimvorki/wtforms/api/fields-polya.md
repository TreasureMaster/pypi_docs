# Fields (поля)

Поля отвечают за рендеринг и преобразование данных. Они передают полномочия валидаторам для проверки данных.

## Определения полей

Поля декларативно определяются как члены в форме:

```python
class MyForm(Form):
    name    = StringField(u'Full Name',
                          [validators.required(), validators.length(max=10)])
    address = TextAreaField(u'Mailing Address',
                            [validators.optional(), validators.length(max=200)])
```

Когда поле определяется в форме, параметры построения сохраняются до тех пор, пока форма не будет создана. Во время создания формы создается копия поля со всеми параметрами, указанными в определении. Каждый экземпляр поля хранит свои собственные данные поля и список ошибок.

Метка и валидаторы могут быть переданы конструктору как последовательные аргументы, тогда как все остальные аргументы должны быть переданы как аргументы ключевого слова. Некоторые поля (например, **SelectField**) также могут принимать дополнительные аргументы ключевого слова для конкретного поля. Обратитесь к справке по встроенным полям для получения информации о них.

## Базовый класс Field

### _class_ wtforms.fields.Field

Хранит и обрабатывает данные, а также создает HTML-код для поля формы.

Экземпляры полей содержат данные этого экземпляра, а также функции для его отображения в вашей форме. Они также содержат ряд свойств, которые можно использовать в ваших шаблонах для визуализации поля и метки.

#### Конструктор

&#x20;**\_\_init\_\_**(_label=None_, _validators=None_, _filters=()_, _description=''_, _id=None_, _default=None_, _widget=None_, _render\_kw=None_, _\_form=None_, _\_name=None_, _\_prefix=''_, _\_translations=None_, _\_meta=None_)

Создает новое поле.

### Параметры конструктора

* _**label**_ - Метка поля.
* _**validators**_ - Последовательность валидаторов, вызываемых при вызове проверки **validate**.
* _**filters**_ - Последовательность фильтров, которые запускаются для входных данных процессом **process**.
* _**description**_ - Описание поля, обычно используется для текста справки.
* _**id**_ - Идентификатор, используемый для поля. Разумное значение по умолчанию задается формой, и вам не нужно устанавливать его вручную.
* _**default**_ - Значение по умолчанию, назначаемое полю, если не предусмотрена форма или ввод объекта. Может быть вызываемым.
* _**widget**_ - Если предоставляется, переопределяет виджет, используемый для визуализации поля.
* _**render\_kw (dict)**_ - Если предоставляется, словарь, который предоставляет ключевые слова по умолчанию, которые будут переданы виджету во время рендеринга.
* _**\_form**_ - Форма, содержащая это поле. Его пропускает сама форма при строительстве. Вы никогда не должны передавать это значение самостоятельно.
* _**\_name**_ - Имя этого поля, передаваемое внешней формой во время его создания. Вы никогда не должны передавать это значение самостоятельно.
* _**\_prefix**_ - Префикс, добавляемый к имени формы этого поля, передаваемый закрывающей формой во время построения.
* _**\_translations**_ - Объект переводов, обеспечивающий переводы сообщений. Обычно проходили ограждающей формой при строительстве. См. **Документацию i18n** для информации о переводах сообщений.
* _**\_meta**_ - Если указано, это экземпляр «meta» из формы. Обычно вы сами этого не проходите.

Если _**\_form**_ и _**\_name**_ не указаны, вместо этого будет возвращено **UnboundField**. Вызовите его метод `bind ()` с экземпляром формы и именем для создания поля.

### Проверка

Чтобы проверить поле, вызовите его метод проверки `validate()`, предоставив форму и все необходимые дополнительные валидаторы. Чтобы расширить поведение проверки, переопределите `pre_validate()` или `post_validate()`.

* &#x20;**validate**(_form_, _extra\_validators=()_) - Проверяет поле и возвращает `True` или `False`. `self.errors` будет содержать любые ошибки, возникшие во время проверки. Обычно это вызывается только `Form.validate`. Субполя не должны переопределять это, а должны переопределять `pre_validate()`, `post_validate()` или оба, в зависимости от потребностей. **Параметры:**
  * _**form**_ - Форма, к которой принадлежит поле.
  * _**extra\_validators**_ - Последовательность дополнительных валидаторов для запуска.
* &#x20;**pre\_validate**(_form_) - Переопределите, если вам нужна проверка на уровне поля. Работает раньше других валидаторов. Параметры:
  * _**form**_ - Форма, к которой принадлежит поле.
* &#x20;**post\_validate**(_form_, _validation\_stopped_) - Переопределите, если вам нужно запустить какие-либо задачи проверки на уровне поля после обычной проверки. В большинстве случаев это не требуется. **Параметры:**
  * _**form**_ - Форма, к которой принадлежит поле.
  * _**validation\_stopped**_ - `True`, если какой-либо валидатор вызвал **StopValidation**.
* _**errors**_ - Если проверка `validate()` обнаружит какие-либо ошибки, они будут вставлены в этот список.

### Доступ к данным и их обработка

Чтобы обрабатывать входящие данные из Python, переопределите `process_data()`. Точно так же для обработки входящих данных извне переопределите `process_formdata()`.

* &#x20;**process**(_formdata_ \[, _data_ ]) - Обработка входящих данных, вызов `process_data()`, `process_formdata()` по мере необходимости и запуск фильтров. Если данные _**data**_ не предоставлены, по умолчанию для поля будет вызываться `process_data()`. Подклассы полей обычно не переопределяют это, вместо этого переопределяют методы `process_formdata()` и `process_data()`. Переопределите это только для специальной расширенной обработки, например, когда поле инкапсулирует множество входных данных.
* &#x20;**process\_data**(_value_) - Обрабатывает данные Python, примененные к этому полю, и сохраняет результат. Это будет вызываться во время построения формы с помощью аргумента формы _**kwargs**_ или _**obj**_. **Параметры:**
  * _**value**_ - Объект python, содержащий значение для обработки.
* &#x20;**process\_formdata**(_valuelist_ ) - Обработка данных, полученных по сети от формы. Это будет вызываться во время создания формы с данными, предоставленными через аргумент _**formdata**_. **Параметры**:
  * _**valuelist**_ - Список строк для обработки.
* _**data**_ - Содержит результирующее (очищенное) значение вызова любого из методов процесса. Обратите внимание, что при использовании в шаблонах HTML не экранируется.
* _**raw\_data**_ - Если данные формы обрабатываются, это список значений, полученный из оболочки _**formdata**_. В противном случае `raw_data()` будет `None`.
* _**object\_data**_ - Это данные, переданные из объекта или из _**kwargs**_ в поле, сохраненные в неизмененном виде. Это может использоваться шаблонами, виджетами, валидаторами по мере необходимости (например, для сравнения)

### Рендеринг

Чтобы отобразить поле, просто вызовите его, предоставив любые значения, которые виджет _**widget**_ ожидает в качестве аргументов ключевого слова _**kwargs**_. Обычно аргументы ключевого слова _**kwargs**_ используются для дополнительных атрибутов HTML.

* &#x20;**\_\_call\_\_**(_\*\*kwargs_) - Отображает это поле как HTML, используя аргументы ключевого слова _**kwargs**_ в качестве дополнительных атрибутов. Делегирует рендеринг `meta.render_field()`, поведение которого по умолчанию - вызывать виджет поля, передавая любые аргументы ключевого слова _**kwargs**_ из этого вызова виджету _**widget**_. Во всех HTML-виджетах **WTForms** аргументы ключевого слова _**kwargs**_ превращаются в атрибуты HTML, хотя теоретически виджет может делать все, что захочет, с предоставленными аргументами ключевого слова, а виджетам не нужно даже делать что-либо, связанное с HTML. Если кто-то хочет передать аргумент «class», который является зарезервированным ключевым словом в некоторых языках шаблонов на основе Python, можно сделать:

```python
form.field(class_="text_blob")
```

Это выведет (для текстового поля):

```markup
<input type="text" name="field_name" value="blah" class="text_blob" id="field_name" />
```

{% hint style="info" %}
**Примечание:**

Простое приведение поля к строке или Unicode отобразит его так, как если бы оно было вызвано без аргументов.
{% endhint %}

* &#x20;**\_\_html\_\_**() - Возвращает HTML-представление поля. Для более мощного рендеринга см. метод `__call__()`. Многие движки шаблонов используют метод `__html__()`, когда он существует в печатном объекте, чтобы получить строку, "html-safe", которая не будет экранирована автоматически. Чтобы разрешить печать пустого поля без его вызова, все поля **WTForms** также реализуют этот метод.

### Переводы сообщений

* &#x20;**gettext**(_string_ ) - Получает перевод данного сообщения. Это прокси для внутреннего объекта переводов.&#x20;
  * **Параметры**: _**string**_ - Строка в Юникоде для перевода.
  * **Возвращает**: - Строку в Юникоде, которая является переведенным выводом.
* &#x20;**ngettext**(_singular_, _plural_, _n_ ) - Получает перевод сообщения, который можно использовать во множественном числе. **Параметры**:
  * _**singular(str)**_ - Форма сообщения в единственном числе.
  * _**plural(str)**_ - Форма множественного числа сообщения.
  * _**n(int)**_ - Количество элементов, к которым относится это сообщение

### Свойства

* _**name**_ - Имя HTML-формы этого поля. Это имя, как определено в вашей форме, с префиксом, переданным конструктору формы.
* _**short\_name**_ - Имя этого поля без префикса.
* _**id**_ - HTML-идентификатор этого поля. Если не указано, оно создается для вас, чтобы оно совпадало с именем поля.
* _**label**_ - Это экземпляр **Label**, который при оценке как строка возвращает конструкцию HTML  `<label for="id">`.
* _**default**_ - Это то, что передали конструктору поля по умолчанию, в противном случае - `None`.
* _**description**_ - Строка, содержащая значение описания, переданное в конструкторе полю; это не экранированный HTML.
* _**errors**_ - Последовательность, содержащая ошибки проверки для этого поля.
* _**process\_errors**_ - Ошибки, полученные при обработке ввода. Они будут добавлены к списку ошибок во время проверки.
* _**widget**_ - Виджет, используемый для визуализации поля.
* _**type**_ - Тип этого поля в виде строки. Это можно использовать в ваших шаблонах для выполнения логики в зависимости от типа поля:

```python
{% raw %}
{% for field in form %}
    <tr>
    {% if field.type == "BooleanField" %}
        <td></td>
        <td>{{ field }} {{ field.label }}</td>
    {% else %}
        <td>{{ field.label }}</td>
        <td>{{ field }}</td>
    {% end %}
    </tr>
{% endfor %}
{% endraw %}
```

* _**flags**_ - Объект, содержащий логические флаги, установленные либо самим полем, либо валидаторами в поле. Например, встроенный валидатор **InputRequired** устанавливает требуемый флаг. Неустановленный флаг приведет к `False`.

```python
{% raw %}
{% for field in form %}
    <tr>
        <th>{{ field.label }} {% if field.flags.required %}*{% endif %}</th>
        <td>{{ field }}</td>
    </tr>
{% endfor %}
{% endraw %}
```

* _**meta**_ - Тот же экземпляр метаобъекта, который доступен как **Form.meta.**
* _**filters**_** -** Та же последовательность фильтров, которая была передана как `filters=` конструктору поля. Обычно это последовательность вызываемых функций.

## Основные поля

Базовые поля обычно представляют скалярные типы данных с отдельными значениями и относятся к одному входу из формы.

* &#x20;_class_ **wtforms.fields.BooleanField**(_default field arguments_, _false\_values=None_) - Представляет  `<input type="checkbox">`. Установите отмеченный статус _**checked**_ с помощью опции по умолчанию _**default**_. Любое значение по умолчанию, например `default = "checked"` помещает _**checked**_ в html-элемент и устанавливает для данных _**data**_ значение `True`. **Параметры**:
  * _**false\_values**_ - Если предоставляется, последовательность строк, каждая из которых является строкой точного соответствия тому, что считается «false» значением. По умолчанию используется кортеж `(False, 'false', '',)`.
* &#x20;_class_ **wtforms.fields.DateField**(_default field arguments_, _format='%Y-%m-%d'_) - То же, что и **DateTimeField**, за исключением того, что хранит `datetime.date`.
* &#x20;_class_ **wtforms.fields.DateTimeField**(_default field arguments_, _format='%Y-%m-%d %H:%M:%S'_) - Текстовое поле, в котором хранится значение `datetime.datetime`, соответствующее формату. Дополнительные сведения о полях даты и времени см. расширение **dateutil**.
* &#x20;_class_ **wtforms.fields.DecimalField**(_default field arguments_, _places=2_, _rounding=None_, _use\_locale=False_, _number\_format=None_) - Текстовое поле, которое отображает и приводит данные типа `decimal.Decimal`. **Параметры**:
  * _**places**_ - Сколько десятичных разрядов значения следует квантовать для отображения в форме. Если `None`, значение не квантуется.
  * _**rounding**_ - Как округлить значение при квантовании, например `decimal.ROUND_UP`. Если не задано, использует значение округления из контекста текущего потока.
  * _**use\_local**_ - Если `True`, используйте форматирование чисел на основе локали. Для форматирования чисел на основе локали требуется пакет babel.
  * _**number\_format**_ - Необязательный числовой формат для языкового стандарта. Если опущено, используйте десятичный формат по умолчанию для локали.
* &#x20;_class_ **wtforms.fields.FileField**(_default field arguments_) - Отображает поле загрузки файла. По умолчанию значением будет имя файла, отправленное в данных формы. **WTForms** не занимается возможностями обработки файлов фреймворком. Расширение **WTForms** для фреймворка может заменять значение имени файла на объект, представляющий загруженные данные. Пример использования:

```python
class UploadForm(Form):
    image        = FileField(u'Image File', [validators.regexp(u'^[^/\\]\.jpg$')])
    description  = TextAreaField(u'Image Description')

    def validate_image(form, field):
        if field.data:
            field.data = re.sub(r'[^a-z0-9_.-]', '_', field.data)

def upload(request):
    form = UploadForm(request.POST)
    if form.image.data:
        image_data = request.FILES[form.image.name].read()
        open(os.path.join(UPLOAD_PATH, form.image.data), 'w').write(image_data)
```

* &#x20;_class_ **wtforms.fields.MultipleFileField**(_default field arguments_) - **FileField**, позволяющий выбирать несколько файлов.
* &#x20;_class_ **wtforms.fields.FloatField**(_default field arguments_) - Текстовое поле, за исключением того, что все вводимые данные приводятся к типу с плавающей точкой. Ошибочный ввод игнорируется и не будет принят в качестве значения. Для большинства применений **DecimalField** предпочтительнее **FloatField**, за исключением случаев, когда IEEE float абсолютно желателен вместо десятичного значения.
* &#x20;_class_ **wtforms.fields.IntegerField**(_default field arguments_) - Текстовое поле, кроме всего ввода, приводится к целому числу. Ошибочный ввод игнорируется и не будет принят в качестве значения.
* &#x20;_class_ **wtforms.fields.RadioField**(_default field arguments_, _choices=\[]_, _coerce=unicode_) - Подобно **SelectField**, но отображает список переключателей. Итерация поля приведет к созданию субполей (каждое из которых также содержит метку), чтобы разрешить настраиваемую визуализацию отдельных радиополей.

```python
{% raw %}
{% for subfield in form.radio %}
    <tr>
        <td>{{ subfield }}</td>
        <td>{{ subfield.label }}</td>
    </tr>
{% endfor %}
{% endraw %}
```

Простой вывод поля без итерации его субполей приведет к появлению `<ul>` списка  вариантов радио.

* &#x20;_class_ **wtforms.fields.SelectField**(_default field arguments_, _choices=\[]_, _coerce=unicode_, _option\_widget=None_, _validate\_choice=True_) - Поля выбора принимают параметр выбора _**choices**_, который представляет собой список пар `(value, label)`. Это также может быть список только значений, и в этом случае значение используется как метка. Значение может быть любого типа, но поскольку данные формы отправляются в браузер в виде строк, вам нужно будет предоставить функцию _**coerce**_, которая преобразует строку обратно в ожидаемый тип.

#### Выберите поля со статическими значениями выбора:

```python
class PastebinEntry(Form):
    language = SelectField(u'Programming Language',
                    choices=[('cpp', 'C++'), ('py', 'Python'), ('text', 'Plain Text')])
```

Обратите внимание, что ключевое слово _**choices**_ оценивается только один раз, поэтому, если вы хотите создать динамический раскрывающийся список, вам нужно будет назначить список вариантов для поля после создания экземпляра. Любые введенные варианты, которых нет в данном списке вариантов, приведут к сбою проверки в поле. Если этот параметр не может быть применен к вашей проблеме, вы можете пропустить проверку выбора (см. ниже).

#### Выберите поля со значениями динамического выбора:

```python
class UserDetails(Form):
    group_id = SelectField(u'Group', coerce=int)

def edit_user(request, id):
    user = User.query.get(id)
    form = UserDetails(request.POST, obj=user)
    form.group_id.choices = [(g.id, g.name) for g in Group.query.order_by('name')]
```

Обратите внимание, что мы не передали варианты выбора конструктору **SelectField**, а создали список в функции просмотра. Кроме того, ключевое слово _**coerce**_ аргумент для **SelectField** говорит о том, что мы используем `int ()` для приведения данных формы. _**coerce**_ по умолчанию - `unicode ()`.

#### Пропуск проверки выбора:

```python
class DynamicSelectForm(Form):
    dynamic_select = SelectField("Choose an option", validate_choice=False)
```

Обратите внимание на параметр _**validate\_choice**_ - устанавливая для него значение `False`, мы сообщаем **SelectField** пропустить этап выбора валидации и вместо этого принять любой введенный вариант без проверки, если он был одним из заданных вариантов. Это следует использовать только в ситуациях, когда вы не можете использовать значения динамического выбора, как показано выше - например, когда выбор **SelectField** определяется динамически другим полем на странице, например при выборе страны и штата/региона.

### Расширенная функциональность

**SelectField** и его потомки являются итерируемыми, и при его итерации создается список полей, каждое из которых представляет вариант. Отрисовку этого можно дополнительно контролировать, указав `option_widget=`.

* &#x20;_class_ **wtforms.fields.SelectMultipleField**(_default field arguments_, _choices=\[]_, _coerce=unicode_, _option\_widget=None_) - Ничем не отличается от обычного поля выбора, за исключением того, что оно может принимать (и проверять) несколько вариантов. Вам нужно будет указать атрибут _**size**_ размера для поля выбора при визуализации HTML. Данные в **SelectMultipleField** хранятся в виде списка объектов, каждый из которых проверяется и вызывается из ввода формы. Любые введенные варианты, которых нет в данном списке вариантов, приведут к сбою проверки в поле.
* &#x20;_class_ **wtforms.fields.SubmitField**(_default field arguments_) - Представляет `<nput type="submit">`. Это позволяет проверить, была ли нажата данная кнопка отправки.
* &#x20;_class_ **wtforms.fields.StringField**(_default field arguments_) - Это поле является базовым для большинства более сложных полей и представляет собой `<input type="text">`.

```python
{{ form.username(size=30, maxlength=50) }}
```

## Поля для удобства

* &#x20;_class_ **wtforms.fields.HiddenField**(_default field arguments_) - **HiddenField** - это "синтаксический сахар" для **StringField** с виджетом **HiddenInput**. Он будет отображаться как `<input type="hidden">`, но в остальном приведен к строке. **HiddenField** полезен для предоставления данных из модели или приложения, которые будут использоваться на стороне обработчика формы для выбора или поиска записей. Очень часто формы CRUD используют скрытое поле для идентификатора объекта _**id**_. Скрытые поля похожи на любые другие поля тем, что они могут принимать валидаторы и значения и быть доступны в объекте формы. Вам следует подумать о проверке скрытых полей так же, как вы проверяете поле ввода, чтобы злонамеренные люди не искажали ваши данные.
* &#x20;_class_ **wtforms.fields.PasswordField**(_default field arguments_) - То же, что и **StringField**, за исключением рендеринга `<input type="password">`. Кроме того, любое значение, принимаемое этим полем, не отображается обратно в браузер, как обычные поля.
* &#x20;_class_ **wtforms.fields.TextAreaField**(_default field arguments_) - Это поле представляет собой HTML-код `<textarea>` и может использоваться для ввода многострочного текста.

## Вложенные поля

Вложения позволяют иметь поля, которые представляют собой набор полей, так что форма может состоять из нескольких повторно используемых компонентов или могут быть представлены более сложные структуры данных, такие как списки и вложенные объекты.

### класс fields.FormField

_class_ **wtforms.fields.FormField**(_form\_class_, _default field arguments_, _separator='-'_ ) - Инкапсулирует форму как поле в другой форме. **Параметры**:

* _**form\_class**_ - Подкласс формы, который будет инкапсулирован.
* _**separator**_ - Строка, которая будет добавлена к имени этого поля, чтобы создать префикс для заключенных полей. Значение по умолчанию подходит для большинства случаев использования.

**FormField** полезны для редактирования дочерних объектов или включения нескольких связанных форм на странице, которые отправляются и проверяются вместе. В то время как создание подклассов форм фиксирует наиболее желаемое поведение, иногда для повторного использования или объединения с **FieldList** имеет смысл создать **FormField**.

Например, возьмем пример контактной формы, которая использует аналогичный набор из трех полей для представления телефонных номеров:

```python
class TelephoneForm(Form):
    country_code = IntegerField('Country Code', [validators.required()])
    area_code    = IntegerField('Area Code/Exchange', [validators.required()])
    number       = StringField('Number')

class ContactForm(Form):
    first_name   = StringField()
    last_name    = StringField()
    mobile_phone = FormField(TelephoneForm)
    office_phone = FormField(TelephoneForm)
```

В этом примере мы повторно использовали **TelephoneForm** для инкапсуляции общей телефонной записи вместо написания настраиваемого поля для обработки трех подполей. Свойство _**data**_ поля _**mobile\_phone**_ вернет словарь данных вложенной формы. Точно так же свойство _**errors**_ инкапсулирует ошибки формы.

### класс fields.FieldList

_class_ **wtforms.fields.FieldList**(_unbound\_field_, _default field arguments_, _min\_entries=0_, _max\_entries=None_) - Инкапсулирует упорядоченный список из нескольких экземпляров поля одного и того же типа, сохраняя данные в виде списка.

```python
authors = FieldList(StringField('Name', [validators.required()]))
```

#### Параметры FieldList:

* _**unbound\_field**_ - Определение поля с частичным экземпляром, точно так же, как это было бы определено непосредственно в форме.
* _**min\_entries**_ - если предоставлено, всегда имейте по крайней мере такое количество записей в поле, создавая пустые, если предоставленные входные данные не указывают достаточное количество.
* _**max\_entries**_ - принимает в качестве входных данных не более этого количества записей, даже если в _**formdata**_ их больше.

{% hint style="info" %}
**Примечание:**

Из-за ограничений в том, как HTML отправляет значения, **FieldList** не может включать экземпляры **BooleanField** или **SubmitField**.
{% endhint %}

#### Свойства и методы FieldList:

* &#x20;**append\_entry**(\[_data_]) - Создает новую запись с необязательными данными по умолчанию. Однако записи, добавленные таким образом, не будут получать данные формы, а могут получать только данные объекта.
* &#x20;**pop\_entry**() - Удаляет последнюю запись из списка и возвращает ее.
* **entries** - Каждая запись в **FieldList** на самом деле является экземпляром переданного вами поля. Итерация, проверка длины и индексация **FieldList** работают, как ожидалось, и прокси-серверы к приложенному списку записей. **Не изменяйте размер списка записей напрямую**, это приведет к неопределенному поведению. См. `append_entry()` и `pop_entry()`, чтобы узнать, как вы можете управлять списком.
* &#x20;**\_\_iter\_\_**()
* &#x20;**\_\_len\_\_**()
* &#x20;**\_\_getitem\_\_**(_index_) - **FieldList** не ограничивается включением простых полей; и действительно может представлять список закрытых форм, комбинируя **FieldList** с **FormField**:

```python
class IMForm(Form):
    protocol = SelectField(choices=[('aim', 'AIM'), ('msn', 'MSN')])
    username = StringField()

class ContactForm(Form):
    first_name  = StringField()
    last_name   = StringField()
    im_accounts = FieldList(FormField(IMForm))
```

## Настраиваемые поля

Хотя **WTForms** обеспечивает настройку существующих полей с помощью виджетов и атрибутов аргументов ключевых слов, иногда необходимо разработать настраиваемые поля для обработки специальных типов данных в вашем приложении.

Давайте создадим поле, которое представляет собой список тегов, разделенных запятыми:

```python
class TagListField(Field):
    widget = TextInput()

    def _value(self):
        if self.data:
            return u', '.join(self.data)
        else:
            return u''

    def process_formdata(self, valuelist):
        if valuelist:
            self.data = [x.strip() for x in valuelist[0].split(',')]
        else:
            self.data = []
```

Метод _**\_value**_ вызывается виджетом **TextInput** для предоставления значения, отображаемого в форме. Переопределение метода `process_formdata ()` обрабатывает входящие данные формы обратно в список тегов.

## Поля с пользовательскими конструкторами

Настраиваемые поля также могут переопределить конструктор поля по умолчанию, если необходимо обеспечить дополнительную настройку:

```python
class BetterTagListField(TagListField):
    def __init__(self, label='', validators=None, remove_duplicates=True, **kwargs):
        super(BetterTagListField, self).__init__(label, validators, **kwargs)
        self.remove_duplicates = remove_duplicates

    def process_formdata(self, valuelist):
        super(BetterTagListField, self).process_formdata(valuelist)
        if self.remove_duplicates:
            self.data = list(self._remove_duplicates(self.data))

    @classmethod
    def _remove_duplicates(cls, seq):
        """Удаляет дубликаты без учета регистра, но с сохранением регистра"""
        d = {}
        for item in seq:
            if item.lower() not in d:
                d[item.lower()] = True
                yield item
```

Когда вы переопределяете конструктор **Field**, чтобы поддерживать единообразное поведение, вы должны спроектировать свой конструктор так, чтобы:

* Вы берете `label=’‘`, `validators=None` в качестве первых двух позиционных аргументов.
* Добавьте любые дополнительные аргументы, которые принимает ваше поле, как аргументы ключевого слова _**kwargs**_ после метки и валидаторов.
* Возьмите _**\*\*kwargs**_, чтобы поймать любые дополнительные аргументы ключевого слова.
* Сначала вызовите конструктор **Field**, передав первые два позиционных аргумента и все остальные аргументы ключевого слова.

## Соображения по поводу переопределения _process()_

Для подавляющего большинства полей нет необходимости переопределять `Field.process ()`. В большинстве случаев вы можете добиться того, что вам нужно, переопределив `process_data()` и/или `process_formdata()`. Однако для специальных типов полей, таких как вложения форм и других особых случаев обработки нескольких значений, это может потребоваться.

Если вы собираетесь переопределить `process ()`, будьте осторожны при работе с параметром _**formdata**_. Для совместимости с максимальным количеством фреймворков мы предлагаем вам ограничить себя манипулированием данными формы только следующими способами:

* Проверка пустоты: `if formdata`
* Проверка наличия ключа: `key in formdata`
* Итерация всех ключей: `for key in formdata` (обратите внимание, что некоторые оболочки могут возвращать несколько экземпляров одного и того же ключа)
* Получение списка значений для ключа: `formdata.getlist(key)`

Самое главное, вы не должны использовать доступ в стиле словаря для работы с вашей оболочкой _**formdata**_, потому что ее поведение сильно варьируется в оболочке: некоторые возвращают первый элемент, другие возвращают последний, а некоторые могут возвращать список.

## Дополнительные классы помощи

* &#x20;_class_ **wtforms.fields.Flags -** Содержит набор логических флагов в качестве атрибутов. Доступ к несуществующему атрибуту возвращает значение `False`. Применение:

```python
>>> flags = Flags()
>>> flags.required = True
>>> 'required' in flags
True
>>> 'nonexistent' in flags
False
>>> flags.fake
False
```

* &#x20;_class_ **wtforms.fields.Label -** Во всех полях свойство _**label**_ является экземпляром этого класса. Ярлыки можно распечатать, чтобы получить вложение тега HTML `<label for="field_id">Label Text</label>`. Подобно полям, вы также можете вызвать метку с дополнительными параметрами html.
  * _**field\_id**_ - Идентификатор поля ID, на которое будет ссылаться эта метка.
  * _**text**_ - Исходный текст метки, переданный конструктору поля.

## Поля HTML5

В дополнение к основным полям HTML, **WTForms** также предоставляет поля для стандарта HTML5. Доступ к этим полям можно получить в пространстве имен `wtforms.fields.html5`. На самом деле эти поля представляют собой просто удобные поля, которые расширяют базовые поля и реализуют виджеты, специфичные для HTML5. Эти виджеты расположены в пространстве имен `wtforms.widgets.html5` и могут быть переопределены или изменены, как и любой другой виджет.

* &#x20;_class_ **wtforms.fields.html5.SearchField**(_default field arguments_) - Представляет собой  `<input type="search">`
* &#x20;_class_ **wtforms.fields.html5.TelField**(_default field arguments_) - Представляет собой  `<input type="tel">`
* _class_ **wtforms.fields.html5.URLField**(_default field arguments_) - Представляет собой  `<input type="url">`
* _class_ **wtforms.fields.html5.EmailField**(_default field arguments_) - Представляет собой  `<input type="email">`
* _class_ **wtforms.fields.html5.DateTimeField**( _default field arguments_, _format='%Y-%m-%d %H:%M:%S'_ ) - Представляет собой  `<input type="datetime">`
* _class_ **wtforms.fields.html5.DateField**( _default field arguments_, _format='%Y-%m-%d'_ ) - Представляет собой  `<input type="date">`
* _class_ **wtforms.fields.html5.TimeField**( _default field arguments_, _format='%H:%M'_ ) - Представляет собой  `<input type="time">`
* _class_ **wtforms.fields.html5.DateTimeLocalField**( _default field arguments_, _format='%Y-%m-%d %H:%M:%S'_ ) - Представляет собой  `<input type="datetime-local">`
* _class_ **wtforms.fields.html5.IntegerField**(_default field arguments_) - Представляет собой  `<input type="number">`
* _class_ **wtforms.fields.html5.DecimalField**(_default field arguments_) - Представляет собой  `<input type="number">`
* _class_ **wtforms.fields.html5.IntegerRangeField**(_default field arguments_) - Представляет собой  `<input type="range">`
* _class_ **wtforms.fields.html5.DecimalRangeField**(_default field arguments_) - Представляет собой  `<input type="range">`
