# Forms (формы)

Формы предоставляют API самого высокого уровня в WTForms. Они содержат определения ваших полей, делегируют проверку, принимают ввод, объединяют ошибки и в целом служат связующим звеном, скрепляющим все вместе.

## Класс форм Form

### _class_ wtforms.form.Form

Базовый класс декларативной формы.

### Конструктор

&#x20;**\_\_init\_\_**(_formdata=None_, _obj=None_, _prefix=''_, _data=None_, _meta=None_, _\*\*kwargs_)

#### Параметры конструктора

* _**formdata**_ - Используется для передачи данных, поступающих от конечного пользователя, обычно request.POST или аналогичный. _**formdata**_ должна быть своего рода оберткой данных запроса, которая может получать несколько параметров из ввода формы, а значения представляют собой строки Unicode, например Werkzeug / Django / WebOb MultiDict.
* _**obj**_ - Если _**formdata**_ пуста или не предоставлена, этот объект проверяется на предмет атрибутов, соответствующих именам полей формы, которые будут использоваться для значений полей.
* _**prefix**_ - Если указано, все поля будут иметь префикс со значением.
* _**data**_ - Принимает словарь данных. Это используется только в том случае, если _**formdata**_ и _**obj**_ отсутствуют.
* _**meta**_ - Если предоставляется, это словарь значений для переопределения атрибутов в мета-экземпляре этой формы.
* _**\*\*kwargs**_ - Если _**formdata**_ пуста или не предоставлена, а объект _**obj**_ не содержит атрибута, названного так же, как поле, форма присвоит полю значение соответствующего аргумента ключевого слова, если таковое существует.

_**Инициализация формы**_. Обычно это делается в контексте представления / контроллера в вашем приложении. Когда форма создается, поля заполняют свой ввод на основе _**formdata**_, _**obj**_ и _**kwargs**_.

{% hint style="info" %}
_**Примечание.**_ Ожидается, что объекты резервного хранилища и _**kwargs**_ будут предоставлены со значениями, являющимися уже приведенными типами данных. **WTForms** не проверяет типы входящих объектных данных и не принуждает их, как это делается для данных формы, поскольку ожидается, что эти данные являются значениями по умолчанию или данными из резервного хранилища, которое представляет эта форма. См. **Раздел об использовании форм** для получения дополнительной информации.
{% endhint %}

### Свойства

* _**data**_ - Словарь, содержащий данные для каждого поля. Обратите внимание, что он генерируется каждый раз, когда вы обращаетесь к свойству, поэтому при его использовании следует проявлять осторожность, поскольку это может оказаться очень дорогостоящим, если вы будете использовать его повторно. Обычно используется, если вам нужно перебрать все данные в форме. Если вам просто нужно получить доступ к данным для известных полей, вы должны использовать `form.<field>.data`, а не это свойство прокси.
* _**errors**_ - Словарь, содержащий список ошибок для каждого поля. Пусто, если форма не была проверена или ошибок не было.
* _**meta**_ - Это объект, который содержит различные параметры конфигурации, а также возможность настраивать поведение формы. См. **Документ class Meta** для получения дополнительной информации о том, что можно настроить с помощью параметров класса Meta.

### Методы

* &#x20;**validate**(_extra\_validators=None_) - Проверяет форму, вызвав функцию `validate` для каждого поля. Возвращает `True`, если проверка прошла. Если форма определяет метод `validate_<fieldname>`, он добавляется как дополнительный валидатор для проверки поля. **Параметры:**
  * _**extra\_validators**_ - Словарь имен полей сопоставления со списками дополнительных методов валидатора для запуска. Дополнительные валидаторы запускаются после того, как валидаторы прошли при создании поля. Если в форме есть `validate_<fieldname>`, это последний дополнительный валидатор.
* &#x20;**populate\_obj**(_obj_) - Заполняет атрибуты переданного объекта данными из полей формы.

{% hint style="info" %}
**Примечание:** Это разрушительная операция; любой атрибут с тем же именем, что и поле, будет переопределен. Используйте с осторожностью.
{% endhint %}

Одним из распространенных способов использования этого является просмотр профиля редактирования:

```python
def edit_profile(request):
    user = User.objects.get(pk=request.session['userid'])
    form = EditProfileForm(request.POST, obj=user)

    if request.POST and form.validate():
        form.populate_obj(user)
        user.save()
        return redirect('/home')
    return render_to_response('edit_profile.html', form=form)
```

В приведенном выше примере, поскольку форма не привязана напрямую к объекту пользователя, вам не нужно беспокоиться о том, что туда попадут какие-либо грязные данные, пока вы не будете готовы их переместить.

* &#x20;**\_\_iter\_\_**() - итерирует поля формы в порядке создания.

```python
{% raw %}
{% for field in form %}
    <tr>
        <th>{{ field.label }}</th>
        <td>{{ field }}</td>
    </tr>
{% endfor %}
{% endraw %}
```

* &#x20;**\_\_contains\_\_**(_name_) - Возвращает `True`, если указанное поле является членом этой формы.
* &#x20;**\_get\_translations**() - _Не рекомендуется с версии 2.0:_ _**\_get\_translations**_ удаляется в WTForms 3.0, вместо этого используйте _**Meta.get\_translations**_. Переопределение в подклассах для обеспечения фабрики альтернативных переводов. Должен возвращать объект, который предоставляет методы `gettext ()` и `ngettext ()`.

## Определение форм

Чтобы определить форму, необходимо создать подкласс **Form** и декларативно определить поля как атрибуты класса:

```python
class MyForm(Form):
    first_name = StringField(u'First Name', validators=[validators.input_required()])
    last_name  = StringField(u'Last Name', validators=[validators.optional()])
```

Имена полей могут быть любым допустимым идентификатором Python со следующими ограничениями:

* Имена полей чувствительны к регистру.
* Имена полей не могут начинаться с символа «\_» (подчеркивание).
* Имена полей не могут начинаться с «validate».

## Наследование форм

Формы могут при необходимости создавать подклассы других форм. Новая форма будет содержать все поля родительской формы, а также любые новые поля, определенные в подклассе. Повторное использование имени поля в подклассе приводит к тому, что новое определение скрывает исходное.

```python
class PastebinEdit(Form):
    language = SelectField(u'Programming Language', choices=PASTEBIN_LANGUAGES)
    code     = TextAreaField()

class PastebinEntry(PastebinEdit):
    name = StringField(u'User Name')
```

## Встроенные валидаторы

Чтобы обеспечить настраиваемую проверку для одного поля без необходимости писать одноразовый валидатор, проверка может быть определена встроенной, путем определения метода с соглашением `validate_fieldname`:

```python
class SignupForm(Form):
    age = IntegerField(u'Age')

    def validate_age(form, field):
        if field.data < 13:
            raise ValidationError("We're sorry, you must be 13 or older to register")
```

## Использование форм

Форма чаще всего создается в коде контроллера для обработки действия, при этом оболочка данных формы из фреймворка передается ее конструктору и, возможно, объект ORM. Типичный вид начинается примерно так:

```python
def edit_article(request):
    article = Article.get(...)
    form = MyForm(request.POST, article)
```

В типичном представлении CRUD пользователь редактирует объект, которому необходимо обновить различные поля. Форма будет иметь поля, описывающие поля, которые должны быть обновлены, и правила проверки, где имена атрибутов полей совпадают с именами атрибутов объекта. Второй параметр формы, параметр _**obj**_, используется для заполнения значений формы по умолчанию в начальном представлении.

{% hint style="info" %}
**Примечание.**

Хотя мы передали объект в качестве источника данных, эти данные объекта используются только в том случае, если данные POST отсутствуют. Если вообще есть какие-либо данные POST, то данные объекта игнорируются. Это сделано из соображений безопасности и согласованности.

Этот шаблон в основном удобен, поскольку большинство контроллеров приложений не разделяют запросы GET и POST на отдельные методы просмотра.
{% endhint %}

Созданная форма может затем проверять любые входные данные и генерировать ошибки, если они недействительны. Обычно шаблон проверки в представлении выглядит так:

```python
if request.POST and form.validate():
    form.populate_obj(article)
    article.save()
    return redirect('/articles')
```

Обратите внимание, что у нас это есть, поэтому `validate ()` вызывается только при наличии данных POST. Причина, по которой мы пропускаем проверку валидации таким образом, заключается в том, что при отсутствии данных POST (например, в типичной форме CRUD) мы не хотим вызывать ошибки валидации.

Внутри закрытого блока мы вызываем `populate_obj ()`, чтобы скопировать данные в поля объекта «article». Мы также перенаправляем после успешного завершения. Причина, по которой мы перенаправляем после публикации, - это передовой опыт, связанный с шаблоном проектирования Post / Redirect / Get.

Если нет данных POST или данные не проходят проверку, тогда представление «проваливается» в часть визуализации. Объект **Form** может быть передан в шаблон, а его атрибуты могут использоваться для визуализации полей, а также для отображения ошибок:

```python
return render('edit.html', form=form, article=article)
```

Итак, у нас есть полная простая настройка страницы «edit object», которая иллюстрирует лучший способ использования WTForms. Это ни в коем случае не единственный способ использования WTForms, это просто иллюстрация того, как работают различные функции.

Вот полный код только что созданного представления:

```python
def edit_article(request):
    article = Article.get(...)
    form = MyForm(request.POST, article)

    if request.POST and form.validate():
        form.populate_obj(article)
        article.save()
        return redirect('/articles')

    return render('edit.html', form=form, article=article)
```

## Низкоуровневый API

{% hint style="warning" %}
Этот раздел предназначен для полноты; и нацелен на авторов дополнительных библиотек и тех, кто ищет очень особенное поведение. Не используйте **BaseForm**, если вы точно не знаете, для чего вы его используете.
{% endhint %}

Тем, кто хочет настроить работу **WTForms** для библиотек или специальных приложений, возможно, стоит использовать класс **BaseForm**. **BaseForm** является родительским классом **Form**, и большая часть логики реализации **Form** фактически обрабатывается **BaseForm**.

Основное различие между **BaseForm** и **Form** заключается в том, что поля не определены декларативно в подклассе **BaseForm**. Вместо этого вы должны передать конструктору набор полей. Точно так же нельзя добавлять поля по наследованию. Кроме того, **BaseForm** не предоставляет: сортировку полей по порядку определения или встроенные валидаторы `validate_foo`. Из-за этого для подавляющего большинства случаев использования мы рекомендуем использовать в коде форму **Form** вместо **BaseForm**.

**BaseForm** предоставляет контейнер для коллекции полей, которые он будет связывать при создании экземпляра и удерживать во внутреннем словаре. Доступ в стиле Dict к экземпляру **BaseForm** позволит вам получить доступ (и изменить) вложенные поля.

### _class_ wtforms.form.BaseForm

Базовый класс формы. Обеспечивает базовое поведение, такое как построение полей, проверка и проксирование данных и ошибок.

### Конструктор

&#x20;**\_\_init\_\_**(_fields_, _prefix=''_, _meta=\<DefaultMeta>_)

#### Параметры конструктора

* _**fields**_ - Словарь или последовательность двух кортежей частично построенных полей.
* _**prefix**_ - Если указано, все поля будут иметь префикс со значением.
* _**meta**_ - Мета-экземпляр, который используется для конфигурации и настройки поведения WTForms.

```python
form = BaseForm({
    'name': StringField(),
    'customer.age': IntegerField("Customer's Age")
})
```

Поскольку **BaseForm** не требует, чтобы имена полей были действительными идентификаторами, они могут быть практически любой строкой Python. Мы рекомендуем сохранять простоту, чтобы избежать несовместимости с браузерами и различными платформами ввода форм, где это возможно.

### Свойства

* _**data**_ - см. **Form.data**
* _**errors**_ - см. **Form.errors**

### Методы

*   &#x20;**process**(_formdata=None_, _obj=None_, _data=None_, _\*\*kwargs_) - Берет форму, данные объекта и аргументы _**kwargs**_ и просит поля обработать их. **Параметры:**

    * _**formdata**_ - Используется для передачи данных, поступающих от конечного пользователя, обычно `request.POST` или аналогичный.
    * _**obj**_ - Если _**formdata**_ пуст или не предоставлен, этот объект проверяется на предмет атрибутов, соответствующих именам полей формы, которые будут использоваться для значений полей.
    * _**data**_ - Если предоставляется, должен быть словарь данных. Это используется только в том случае, если _**formdata**_ пуст или не предоставлен, а объект _**obj**_ не содержит атрибута, названного так же, как поле.
    * _**\*\*kwargs**_ - Если _**formdata**_ пуст или не предоставлен, а объект _**obj**_ не содержит атрибута, названного так же, как поле, форма form присвоит полю значение соответствующего аргумента ключевого слова _**kwargs**_, если таковое существует.

    Поскольку **BaseForm** не принимает свои данные при создании экземпляра, вы должны вызвать это, чтобы предоставить данные формы во вложенные поля. Доступ к данным поля перед вызовом процесса не рекомендуется.
*   &#x20;**validate**(_extra\_validators=None_) - Проверяет форму, вызывая `validate` для каждого поля. **Параметры:**

    * _**extra\_validators**_ - Если предоставлено, это имя поля сопоставления словаря с последовательностью вызываемых объектов, которые будут переданы в качестве дополнительных валидаторов методу проверки поля.

    Возвращает `True`, если ошибок не происходит.
* &#x20;**\_\_iter\_\_**() - Итерирует поля формы в порядке создания. В отличие от формы **Form**, поля повторяются не в порядке определения, а в том порядке, в каком словарь dict решает их выдать.
* &#x20;**\_\_contains\_\_**(_name_) - Возвращает `True`, если указанное поле является членом этой формы.
* &#x20;**\_\_getitem\_\_**(_name_) - Доступ к полям этой формы в стиле словаря Dict.
* &#x20;**\_\_setitem\_\_**(_name_, _value_) - Привязывает поле к этой форме.

```python
form['openid.name'] = StringField()
```

Поля могут быть добавлены и заменены таким образом, но это необходимо сделать до вызова `process ()`, иначе у полей не будет возможности получать входные данные. Точно так же изменение полей после `validate ()` будет иметь нежелательные эффекты.

* &#x20;**\_\_delitem\_\_**(_name_) - Удаляет поле из этой формы. Применяются те же предостережения, что и для `__setitem__()`.

