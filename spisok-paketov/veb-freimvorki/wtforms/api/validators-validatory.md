# Validators (валидаторы)

Валидатор просто принимает ввод, проверяет, соответствует ли он некоторому критерию, например максимальной длине строки, и возвращает. Или, если проверка не удалась, вызывает **ValidationError**. Эта система очень проста и гибка и позволяет связывать любое количество валидаторов по полям.

## Исключения validators

* &#x20;_class_ **wtforms.validators.ValidationError**(_message=''_, _\*args_, _\*\*kwargs_) - Возникает, когда валидатор не может проверить свой ввод.
* &#x20;_class_ **wtforms.validators.StopValidation**(_message=''_, _\*args_, _\*\*kwargs_) - Останавливает цепочку проверки. Если вызывается **StopValidation**, больше не вызываются валидаторы в цепочке проверки. Если возникает с сообщением, оно будет добавлено в список ошибок.

## Встроенные валидаторы

### класс validators.DataRequired

* &#x20;_class_ **wtforms.validators.DataRequired**(_message=None_) - Проверяет, что данные поля «правдивы», в противном случае цепочка проверки останавливается. Этот валидатор проверяет, является ли атрибут данных в поле «истинным» значением `True` (фактически, он имеет значение, если есть `field.data`.) Кроме того, если данные являются строковыми, строка, содержащая только символы пробела, считается ложной. Если данные пусты, также удаляются предыдущие ошибки (например, ошибки обработки) из поля.

{% hint style="info" %}
ПРИМЕЧАНИЕ, этот валидатор раньше назывался обязательным **Required**, но его поведение (требующее принудительных данных, а не входных данных) означало, что он функционировал не симметрично опциональному валидатору **Optional** и, кроме того, вызывал путаницу с некоторыми полями, которые заставляли данные становиться "ложными '' такие значения, как `0`, `Decimal (0)`, `time (0)` и т. д. Если нет очень конкретной причины, мы рекомендуем вместо этого использовать **InputRequired**.
{% endhint %}

#### Параметры DataRequired:

* _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки.

Это также устанавливает обязательный флаг `required` _**flag**_ для полей, в которых он используется.

### класс validators.Email

*   &#x20;_class_ **wtforms.validators.Email**(_message=None_, _granular\_message=False_, _check\_deliverability=False_, _allow\_smtputf8=True_, _allow\_empty\_local=False_) - Проверяет адрес электронной почты. Требуется установка пакета **email\_validator**. Например: `pip install wtforms [email]`. Параметры:

    * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки.
    * _**granular\_message**_ - Использовать сообщение об ошибке проверки из библиотеки **email\_validator** (по умолчанию `False`).
    * _**check\_deliverability**_ - Выполните проверку разрешения доменного имени (по умолчанию `False`).
    * _**allow\_smtputf8**_ - Сбой проверки для адресов, для которых требуется SMTPUTF8 (по умолчанию `True`).
    * _**allow\_empty\_local**_ - Разрешает пустую локальную часть (например, `@example.com`), например для проверки псевдонимов Postfix (по умолчанию `False`).



### класс validators.EqualTo

* &#x20;_class_ **wtforms.validators.EqualTo**(_fieldname_, _message=None_) - Сравнивает значения двух полей. Параметры:
  * _**fieldname**_ - Имя другого поля для сравнения.
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки. Может быть интерполирован с помощью `%(other_label)s` и `%(other_name)s`, чтобы получить более полезную ошибку.

Этот валидатор можно использовать для облегчения одного из наиболее распространенных сценариев формы смены пароля:

```python
class ChangePassword(Form):
    password = PasswordField('New Password',
                    [InputRequired(), EqualTo('confirm', message='Passwords must match')])
    confirm  = PasswordField('Repeat Password')
```

В этом примере мы используем валидатор **InputRequired**, чтобы предотвратить попытку валидатора **EqualTo** проверить, не совпадают ли пароли, если пароли не были указаны вообще. Поскольку **InputRequired** останавливает цепочку проверки, **EqualTo** не запускается, если поле пароля остается пустым.

### класс validators.InputRequired

* &#x20;_class_ **wtforms.validators.InputRequired**(_message=None_) - Проверяет, что ввод был предоставлен для этого поля. **** Обратите внимание, что существует различие между **InputRequired** и **DataRequired** в том, что **InputRequired** смотрит, что данные для ввода формы были предоставлены, а **DataRequired** смотрит на данные после принуждения (post-coercion). Это также устанавливает обязательный флаг `required` _**flag**_ для полей, в которых он используется.

### класс validators.IPAddress

* &#x20;_class_ **wtforms.validators.IPAddress**(_ipv4=True_, _ipv6=False_, _message=None_) - Проверяет IP-адрес. Для поддержки Python 2 требуется установить пакет **ipaddress**. Параметры:
  * _**ipv4**_ - Если `True`, примите IPv4-адреса как действительные (по умолчанию `True`)
  * _**ipv6**_ - Если `True`, принять IPv6-адреса как действительные (по умолчанию `False`)
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки.

### класс validators.Length

* &#x20;_class_ **wtforms.validators.Length**(_min=-1_, _max=-1_, _message=None_) - Проверяет длину строки. Параметры:
  * _**min**_ - Минимальная необходимая длина строки. Если не указан, минимальная длина проверяться не будет.
  * _**max**_ - Максимальная длина строки. Если не указан, максимальная длина проверяться не будет.
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки. При желании может быть интерполирован с использованием `%(min)d` и `%(max)d`. Полезные значения по умолчанию предоставляются в зависимости от наличия _**min**_ и _**max**_.

### класс validators.MacAddress

* &#x20;_class_ **wtforms.validators.MacAddress**(_message=None_) - Проверяет MAC-адрес. Параметры:
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки.

### класс validators.NumberRange

* &#x20;_class_ **wtforms.validators.NumberRange**(_min=None_, _max=None_, _message=None_) - Проверяет, имеет ли число минимальное и/или максимальное значение включительно. Это будет работать с любым сопоставимым числовым типом, таким как числа с плавающей запятой и десятичные дроби, а не только с целыми числами. Параметры:
  * _**min**_ - Минимально необходимое значение числа. Если не указано, минимальное значение проверяться не будет.
  * _**max**_ - Максимальное значение числа. Если не указано, максимальное значение проверяться не будет.
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки. При желании может быть интерполирован с использованием `%(min)s` и `%(max)s`. Полезные значения по умолчанию предоставляются в зависимости от наличия _**min**_ и _**max**_.

### класс validators.Optional

* &#x20;_class_ **wtforms.validators.Optional**(_strip\_whitespace=True_) - Разрешает пустой ввод и останавливает продолжение цепочки проверки. Если ввод пуст, также удаляются предыдущие ошибки (например, ошибки обработки) из поля. Параметры:
  * _**strip\_whitespace**_ - Если `True` (по умолчанию), также останавливает цепочку проверки на вводе, состоящем только из пробелов.

Это также устанавливает `optional` **flag** для полей, в которых он используется.

### класс validators.Regexp

* &#x20;_class_ **wtforms.validators.Regexp**(_regex_, _flags=0_, _message=None_) - Проверяет поле на соответствие регулярному выражению, предоставленному пользователем. Параметры:
  * _**regex**_ - Строка регулярного выражения для использования. Также может быть скомпилированным шаблоном регулярного выражения.
  * _**flags**_ - Используемые флаги регулярного выражения, например `re.IGNORECASE`. Игнорируется, если регулярное выражение не является строкой.
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки.

### класс validators.URL

* &#x20;_class_ **wtforms.validators.URL**(_require\_tld=True_, _message=None_) - Простая проверка URL на основе регулярных выражений. Как и в случае с валидатором электронной почты, вы, вероятно, захотите проверить URL-адрес позже другими способами, если URL-адрес должен разрешиться. Параметры:
  * _**require\_tld**_ - Если это `True`, то часть URL-адреса с именем домена должна содержать суффикс `.tld`. Установите значение `False`, если вы хотите разрешить использование таких доменов, как `localhost`.
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки.

### класс validators.UUID

* &#x20;_class_ **wtforms.validators.UUID**(_message=None_) - Проверяет UUID. Параметры:
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки.

### класс validators.AnyOf

* &#x20;_class_ **wtforms.validators.AnyOf**(_values_, _message=None_, _values\_formatter=None_) - Сравнивает входящие данные с последовательностью допустимых входных данных. Параметры:
  * _**values**_ - Последовательность допустимых входных данных.
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки. `%(values)s` содержит список значений.
  * _**values\_formatter**_ - Функция, используемая для форматирования списка значений в сообщении об ошибке.

### класс validators.NoneOf

* &#x20;_class_ **wtforms.validators.NoneOf**(_values_, _message=None_, _values\_formatter=None_) - Сравнивает входящие данные с последовательностью неверных входов. Параметры:
  * _**values**_ - Последовательность неверных входных данных.
  * _**message**_ - Сообщение об ошибке, которое нужно поднять в случае ошибки проверки. `%(values)s` содержит список значений.
  * _**values\_formatter**_ - Функция, используемая для форматирования списка значений в сообщении об ошибке.

## Пользовательские валидаторы

Мы шаг за шагом рассмотрим процесс написания валидатора с проверкой длины **Length**, аналогичного встроенному валидатору длины, начиная с конкретного случая до универсального валидатора многократного использования.

Начнем с простой формы с полем имени и его проверкой:

```python
class MyForm(Form):
    name = StringField('Name', [InputRequired()])

    def validate_name(form, field):
        if len(field.data) > 50:
            raise ValidationError('Name must be less than 50 characters')
```

Выше мы показываем использование встроенного валидатора для проверки одного поля. Встроенные валидаторы хороши для проверки особых случаев, но их нелегко использовать повторно. Если в приведенном выше примере поле имени _**name**_ должно быть разделено на два поля для имени и фамилии, вам придется продублировать свою работу, чтобы проверить две длины.

Итак, давайте начнем процесс разделения валидатора для повторного использования:

```python
def my_length_check(form, field):
    if len(field.data) > 50:
        raise ValidationError('Field must be less than 50 characters')

class MyForm(Form):
    name = StringField('Name', [InputRequired(), my_length_check])
```

Все, что мы здесь сделали, это вынесли один и тот же код из класса и как функцию. Поскольку валидатором может быть любой вызываемый объект, который принимает форму _**form**_ и поле **field** как два позиционных аргумента, это прекрасно, но валидатор - это особый случай.

Вместо этого мы можем превратить наш валидатор в более мощный, сделав его фабрикой, возвращающей вызываемый объект:

```python
def length(min=-1, max=-1):
    message = 'Must be between %d and %d characters long.' % (min, max)

    def _length(form, field):
        l = field.data and len(field.data) or 0
        if l < min or max != -1 and l > max:
            raise ValidationError(message)

    return _length

class MyForm(Form):
    name = StringField('Name', [InputRequired(), length(max=50)])
```

Теперь у нас есть настраиваемый валидатор проверки длины, который обрабатывает как минимальную, так и максимальную длину. Когда `length (max = 50)` передается в вашем списке валидаторов, он возвращает заключенную в него функцию _**\_length**_ в качестве закрытия, которая используется в цепочке валидации поля.

Теперь это приемлемый валидатор, но мы рекомендуем для повторного использования использовать шаблон, позволяющий настраивать сообщение об ошибке путем передачи параметра `message=`:

```python
class Length(object):
    def __init__(self, min=-1, max=-1, message=None):
        self.min = min
        self.max = max
        if not message:
            message = u'Field must be between %i and %i characters long.' % (min, max)
        self.message = message

    def __call__(self, form, field):
        l = field.data and len(field.data) or 0
        if l < self.min or self.max != -1 and l > self.max:
            raise ValidationError(self.message)

length = Length
```

Мы не только разрешили настраивать сообщение об ошибке, но и преобразовали валидатор длины в класс. В этом не было необходимости, но мы сделали это, чтобы проиллюстрировать, как это сделать. Поскольку поля будут принимать любой вызываемый объект в качестве валидатора, вызываемые классы также применимы. Для сложных валидаторов или использующих наследование вы можете предпочесть это.

Мы вернули классу **Length** к исходному имени длины _**length**_ в приведенном выше примере. Это позволяет поддерживать совместимость API при перемещении валидаторов с фабрик в классы, и поэтому мы рекомендуем это для тех, кто пишет валидаторы, которыми они будут совместно пользоваться.

## Установка флагов на поле с валидаторами

Иногда полезно знать, присутствует ли валидатор в данном поле, например, для использования в коде шаблона. Для этого валидаторам разрешено указывать флаги, которые затем будут доступны для объекта **flags** поля. Некоторые встроенные валидаторы, такие как **Required**, уже делают это.

Чтобы указать флаги на вашем валидаторе, установите атрибут _**field\_flags**_ на вашем валидаторе. Когда поле **Field** создано, флажки с тем же именем в вашем поле будут установлены в значение `True`. Например, представьте себе валидатор, который проверяет, является ли ввод допустимым BBCode. Затем мы можем установить флаг в поле, чтобы обозначить, что поле принимает BBCode:

```python
# class implementation
class ValidBBCode(object):
    field_flags = ('accepts_bbcode', )

    pass # validator implementation here

# factory implementation
def valid_bbcode():
    def _valid_bbcode(form, field):
        pass # validator implementation here

    _valid_bbcode.field_flags = ('accepts_bbcode', )
    return _valid_bbcode
```

Затем мы можем проверить это в нашем шаблоне, чтобы затем разместить примечание для пользователя:

```python
{{ field(rows=7, cols=70) }}
{% raw %}
{% if field.flags.accepts_bbcode %}
    <div class="note">This field accepts BBCode formatting as input.</div>
{% endif %}
{% endraw %}
```

Некоторые соображения по использованию флагов:

* Флаги могут устанавливать только логические значения, и другой валидатор не может их сбросить.
* Если несколько полей устанавливают один и тот же флаг, его значение по-прежнему равно `True`.
* Флаги устанавливаются из валидаторов только в `Field.__init__()`, поэтому встроенные валидаторы и дополнительные переданные валидаторы не могут их установить.
