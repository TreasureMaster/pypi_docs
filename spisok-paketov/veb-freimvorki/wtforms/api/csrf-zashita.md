# CSRF защита

Пакет CSRF включает инструменты, которые помогут вам реализовать проверку против подделки межсайтовых запросов («csrf»). Из-за большого количества вариантов подходов к CSRF (и того факта, что многие идут на компромиссы) базовая реализация позволяет вам использовать несколько подходов к проверке CSRF.

Реализации CSRF создаются путем создания подклассов CSRF. В качестве полезности мы предоставили одну возможную реализацию CSRF в пакете, которая может использоваться со многими фреймворками для безопасного хеширования ключей на основе сеанса, **SessionCSRF**.

### Использование CSRF

CSRF в **WTForms 2.0** теперь управляется рядом переменных в классе [**Meta**](meta-klass.md). Выбрав реализацию CSRF, импортируйте ее и настройте в классе **Meta** подкласса **Form**, например:

```python
from somemodule import SomeCSRF

class MyBaseForm(Form):
    class Meta:
        csrf = True  # Включить CSRF
        csrf_class = SomeCSRF  # Установите реализацию CSRF
        csrf_secret = b'foobar'  # Некоторым реализациям нужен секретный ключ.
        # Любые другие настройки CSRF здесь.
```

И как только вы это настроите, вы можете определить свои формы как подкласс **MyBaseForm**:

```python
class UserForm(MyBaseForm):
    name = TextField()
    age = IntegerField()

def view():
    form = UserForm(request.POST)
    if request.POST and form.validate():
        pass # Форма действительна, CSRF успешно завершен

    return render('user.html', form=form)
```

Внутри формы CSRF есть специальное поле (по умолчанию называется _**csrf\_token**_), которое вам нужно, чтобы убедиться, что вы отображаете в своем шаблоне:

```python
<form action="/user" method="POST">
{{ form.csrf_token }}
{% raw %}
{% if form.csrf_token.errors %}
    <div class="warning">You have submitted an invalid CSRF token</div>
{% endif %}
{% endraw %}
<div>{{ form.name }} {{ form.name.label }}</div>
<div>{{ form.age }}{{ form.age.label }}</div>
```

Помните, что с классом **Meta** вы всегда можете переопределить переменные в подклассе или в конструкторе для особых случаев:

```python
class SearchForm(MyBaseForm):
    """
    Мы ожидаем, что поисковые запросы будут поступать извне,
    поэтому нам не нужен CSRF даже если он настроен на базовой форме.
    """
    class Meta:
        # Это отменяет значение из базовой формы.
        csrf = False
```

### Как работает WTForms CSRF

Большинство реализаций CSRF основаны на создании специального токена, который помещается в скрытое поле формы с именем _**csrf\_token**_, которое должно быть отображено в вашем шаблоне для передачи из браузера обратно в ваше представление. Существует множество различных методов генерации этого токена, но обычно они являются результатом криптографической хеш-функции для некоторых данных, которые было бы трудно подделать.

#### &#x20;_class_ wtforms.csrf.core.CSRFTokenField(_\*args_, _\*\*kw_ )

Подкласс **HiddenField**, предназначенный для отправки токена CSRF, который используется для большинства схем защиты CSRF. Это поле заметно отличается от обычного поля, это поле всегда отображает текущий токен независимо от отправленного значения, а также не будет заполнено данными объекта через _**populate\_obj**_.

* &#x20;**\_\_init\_\_**(_\*args_, _\*\*kw_ ) - Создает новое поле. Параметры:
  * _**label**_ - Метка поля.
  * _**validators**_ - Последовательность валидаторов, вызываемых при вызове _**validate**_.
  * _**filters**_ - Последовательность фильтров, которые запускаются для входных данных процессом _**process**_.
  * _**description**_ - Описание поля, обычно используется для текста справки.
  * _**id**_ - Идентификатор, используемый для поля. Разумное значение по умолчанию задается формой, и вам не нужно устанавливать его вручную.
  * _**default**_ - Значение по умолчанию, присваиваемое полю, если не предусмотрена форма или ввод объекта. Может быть вызываемым.
  * _**widget**_ - Если предоставляется, переопределяет виджет, используемый для визуализации поля.
  * &#x20;_**render\_kw**_ (_dict_ ) - Если предоставляется, словарь, который предоставляет ключевые слова по умолчанию, которые будут переданы виджету во время рендеринга.
  * _**\_form**_ - Форма, содержащая это поле. Его пропускает сама форма при строительстве. Вы никогда не должны передавать это значение самостоятельно.
  * _**\_name**_ - Имя этого поля, передаваемое внешней формой во время его создания. Вы никогда не должны передавать это значение самостоятельно.
  * _**\_prefix**_ - Префикс, добавляемый к имени формы этого поля, передаваемый внешней формой во время построения.
  * _**\_translation**_ - Объект переводов, обеспечивающий переводы сообщений. Обычно при строительстве проходит мимо ограждающей формы. См. [документацию I18n](internacionalizaciya-i18n.md) для информации о переводах сообщений.
  * _**\_meta**_ - Если указано, это экземпляр «meta» из формы. Обычно вы сами этого не проходите.

Если _**\_form**_ и _**\_name**_ не указаны, вместо этого будет возвращено **UnboundField**. Вызовите его метод **bind ()** с экземпляром формы и именем для создания поля.

* &#x20;**current\_token** _= None_
* &#x20;**\_value**() - Мы хотим всегда возвращать текущий токен при рендеринге, независимо от того, был передан хороший или плохой токен.
* &#x20;**populate\_obj**(_\*args_) - Не заполняйте объекты токеном CSRF
* &#x20;**pre\_validate**(_form_) - Обработка проверки этого поля токена.
* &#x20;**process**(_\*args_) - Обработка входящих данных, вызов _**process\_data**_, _**process\_formdata**_ по мере необходимости и запуск фильтров. Если данные _**data**_ не предоставлены, по умолчанию для поля будет вызываться _**process\_data**_. Подклассы полей обычно не переопределяют это, вместо этого переопределяют методы _**process\_formdata**_ и _**process\_data**_. Переопределите это только для специальной расширенной обработки, например, когда поле инкапсулирует множество входных данных.

#### &#x20;_class_ **wtforms.csrf.core.CSRF**

* &#x20;**setup\_form**(_form_) - Получает форму, к которой мы прикреплены, и настройте поля. Реализация по умолчанию создает одно поле типа _**field\_class**_ с именем, взятым из _**csrf\_field\_name**_ мета класса. Параметры:
  * _**form**_ - Экземпляр формы, к которому мы прикрепляем.
  * _**возвращает**_ - Последовательность двух кортежей `(field_name, unbound_field)`, которые являются несвязанными полями, которые нужно добавить в форму.
* &#x20;**generate\_csrf\_token**(_csrf\_token\_field_) - Реализации должны переопределить это, чтобы предоставить метод, с помощью которого можно получить токен CSRF для этой формы. Токен CSRF обычно представляет собой строку, которая детерминированно генерируется на основе каких-то пользовательских данных, хотя это может быть что угодно, что вы можете проверить в последующем запросе. Параметры:
  * _**csrf\_token\_field**_ - Поле, которое используется для CSRF.
  * _**возвращает**_ - Сгенерированная строка CSRF.
* &#x20;**validate\_csrf\_token**(_form_, _field_) - Переопределите этот метод, чтобы предоставить настраиваемую логику проверки CSRF. Логика проверки CSRF по умолчанию просто проверяет, совпадает ли недавно созданный токен с тем, который мы получили как данные формы. Параметры:
  * _**form**_ - Форма с этим токеном CSRF.
  * _**field**_ - Поле токена CSRF.
* &#x20;**field\_class** _= \<class 'wtforms.csrf.core.CSRFTokenField'> -_ Класс поля токена, которое мы собираемся создать. При необходимости может быть переопределен в подклассах.

### Создание собственной реализации CSRF

Здесь мы набросаем простую теоретическую реализацию CSRF, которая генерирует хэш-токен на основе IP-адреса пользователя.

{% hint style="info" %}
**Примечание**. Это упрощенный пример, предназначенный для иллюстрации создания реализации CSRF. Его не рекомендуется использовать в производственной среде, поскольку токен детерминирован и не меняет IP-адрес, а это означает, что это не самая безопасная реализация CSRF.
{% endhint %}

Во-первых, давайте создадим наш класс CSRF:

```python
from wtforms.csrf.core import CSRF
from hashlib import md5

SECRET_KEY = '1234567890'

class IPAddressCSRF(CSRF):
    """
    Генерирует токен CSRF на основе IP-адреса пользователя. Это наверное не очень
     безопасно, так что не используйте меня.
    """
    def setup_form(self, form):
        self.csrf_context = form.meta.csrf_context
        return super(IPAddressCSRF, self).setup_form(form)

    def generate_csrf_token(self, csrf_token):
        token = md5(SECRET_KEY + self.csrf_context).hexdigest()
        return token

    def validate_csrf_token(self, form, field):
        if field.data != field.current_token:
            raise ValueError('Invalid CSRF')
```

Теперь, когда мы с этим позаботились, давайте напишем простую форму и представление, которые будут реализовывать это:

```python
class RegistrationForm(Form):
    class Meta:
        csrf = True
        csrf_class = IPAddressCSRF

    name = StringField('Your Name')
    email = StringField('Email', [validators.email()])

def register(request):
    form = RegistrationForm(
        request.POST,
        meta={'csrf_context': request.ip}
    )

    if request.method == 'POST' and form.validate():
        pass # У нас все в порядке, создайте пользователя или что там вы делаете
    elif form.csrf_token.errors:
        pass # Если мы здесь, мы подозреваем пользователя в подделке межсайтового запроса
    else:
        pass # Любые другие ошибки

    return render('register.html', form=form)
```

И напоследок простой шаблон:

```python
<form action="register" method="POST">
    {{ form.csrf_token }}
    <p>{{ form.name.label }}: {{ form.name }}</p>
    <p>{{ form.email.label }}: {{ form.email }}</p>
    <input type="submit" value="Register">
</form>
```

Обратите внимание, что реализация обнаружения CSRF не является надежной, и даже при наилучшей реализации защиты от CSRF запросы могут быть подделаны опытными злоумышленниками. Тем не менее, хорошая защита CSRF сделает невозможным для кого-либо с внешнего сайта перехватить отправку формы от другого пользователя и выполнить действия в соответствии с ними без дополнительных априорных знаний.

Кроме того, важно понимать, что очень часто, чем строже защита CSRF, тем выше вероятность возникновения ложных срабатываний (т. е. законных пользователей, заблокированных вашей защитой CSRF), и выбор реализации CSRF на самом деле является вопросом компромисса. В будущем мы попытаемся предоставить несколько полезных эталонных алгоритмов, встроенных в эту библиотеку, чтобы сделать этот выбор простым.

Некоторые советы по критериям, которые люди часто используют при оценке реализации CSRF:

* **Воспроизводимость.** Если токен основан на атрибутах пользователя, он получает то преимущество, что не требуется вторичное хранилище, в котором можно хранить значение между запросами. Однако, если те же атрибуты могут быть воспроизведены злоумышленником, злоумышленник потенциально может подделать эту информацию.
* **Возможность повторного использования**. Может возникнуть желание делать каждый раз совершенно другой токен и запрещать пользователям повторно использовать прошлые токены. Это чрезвычайно мощная защита, но она может иметь последствия, если пользователь использует кнопку «Назад» (или в некоторых случаях запускает формы одновременно на нескольких вкладках браузера) и отправляет старый токен или иным образом. Возможный компромисс - разрешить повторное использование во временном окне (подробнее об этом позже).
* **Временные диапазоны.** Многие подходы CSRF используют истечение срока, основанное на времени, чтобы гарантировать, что токен не может быть (повторно) использован после определенного момента. При выборе временных критериев необходимо соблюдать осторожность, чтобы не блокировать законных пользователей. Например, если пользователь может уйти, заполняя длинную форму, или пойти искать свою кредитную карту, время истечения срока должно учитывать это, чтобы обеспечить баланс между безопасностью и ограничением неудобств для пользователя.
* **Требования**. Некоторые методы предотвращения CSRF требуют использования файлов **cookie** браузера, а некоторые даже требуют поддержки сценариев на стороне клиента. Веб-мастер, реализующий CSRF, должен учитывать, что такие требования (хотя и эффективные) могут заблокировать определенных законных пользователей, и сделать это определение того, стоит ли их использовать. Например, для сайта, уже использующего файлы **cookie** для входа в систему, добавление еще одного файла для CSRF не представляет большого труда, но для других сайтов это может оказаться невозможным.

### Реализация CSRF на основе сеансов

Предоставляемая реализация CSRF, которая помещает данные CSRF в сеанс.

Это можно довольно удобно использовать со многими объектами типа `request.session`, включая хранилище сеансов **Werkzeug/Flask**, сеансы **Django** и потенциально другие подобные объекты, которые используют dict-подобный API для хранения ключей сеанса.

Основная концепция заключается в том, что случайно сгенерированное значение сохраняется в сеансе пользователя, и его **hmac-sha1** (вместе с необязательным сроком действия для дополнительной безопасности) используется в качестве значения _**csrf\_token**_. Если этот токен проверяется с помощью **hmac** случайного значения + время истечения срока действия, и время истечения срока действия не истекло, проверка CSRF пройдет.

#### &#x20;_class_ wtforms.csrf.session.SessionCSRF

#### Мета-значения

* _**csrf\_secret**_ - Строка байтов, которая является главным ключом, с помощью которого мы кодируем все значения. Установите достаточно длинную строку символов, которую трудно угадать или перебрать (рекомендуется не менее 16 символов), например вывод `os.urandom (16)`.
* **csrf\_time\_limit** - если `None`, токены действуют вечно (не рекомендуется). В противном случае установите значение `datetime.timedelta`, которое определит, как долго токены CSRF действительны. По умолчанию 30 минут.
* _**csrf\_context**_ - Это должен быть объект в стиле `request.session`. Обычно указывается в конструкторе формы.

#### Пример

```python
from wtforms.csrf.session import SessionCSRF
from datetime import timedelta

class MyBaseForm(Form):
    class Meta:
        csrf = True
        csrf_class = SessionCSRF
        csrf_secret = b'EPj00jpfj8Gx1SjnyLxwBBSQfnQ9DJYe0Ym'
        csrf_time_limit = timedelta(minutes=20)

class Registration(MyBaseForm):
    name = StringField()

def view(request):
    form = Registration(request.POST, meta={'csrf_context': request.session})
    # остальной вид здесь
```

Обратите внимание, что `request.session` передается как переопределение _**csrf\_context**_ в метаинформацию, чтобы токен CSRF можно было сохранить в вашем сеансе для сравнения при следующем запросе.

#### Пример интеграции

Примитивы **WTForms** предназначены для работы с большим разнообразием фреймворков, и поэтому иногда кажется, что их использовать труднее, но с некоторой интеллектуальной интеграцией вы действительно можете существенно очистить свой код.

Например, если вы собирались интегрироваться с **Flask** и хотели использовать реализацию **SessionCSRF**, вот один из способов сделать доступным контекст CSRF, не передавая его все время:

```python
from flask import session
from wtforms.csrf.session import SessionCSRF

class MyBaseForm(Form):
    class Meta:
        csrf = True
        csrf_class = SessionCSRF
        csrf_secret = app.config['CSRF_SECRET_KEY']

        @property
        def csrf_context(self):
            return session
```

Теперь с любыми подклассами **MyBaseForm** вам не нужно передавать контекст csrf, и, кроме того, мы получаем секретный ключ из вашей обычной конфигурации приложения.
